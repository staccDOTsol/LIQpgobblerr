/**
 * Nonce Account Manager & Transaction Helpers
 * Handles transaction submission with exponential backoff
 */

import {
  Connection,
  Keypair,
  NonceAccount,
  NONCE_ACCOUNT_LENGTH,
  PublicKey,
  SystemProgram,
  Transaction,
  TransactionInstruction,
  VersionedTransaction,
  TransactionMessage,
} from '@solana/web3.js';
import bs58 from 'bs58';

// Helius RPC
const HELIUS_API_KEY = process.env.HELIUS_API_KEY || '0d4b4fd6-c2fc-4f55-b615-a23bab1ffc85';
const HELIUS_RPC_URL = `https://mainnet.helius-rpc.com/?api-key=${HELIUS_API_KEY}`;
const connection = new Connection(HELIUS_RPC_URL, 'confirmed');

// Rent for nonce account
const NONCE_RENT_LAMPORTS = 1447680;

/**
 * Build instructions to create a nonce account
 */
export function buildCreateNonceAccountInstructions(
  payer: PublicKey,
  nonceKeypair: Keypair,
  authority: PublicKey
): TransactionInstruction[] {
  const createAccountIx = SystemProgram.createAccount({
    fromPubkey: payer,
    newAccountPubkey: nonceKeypair.publicKey,
    lamports: NONCE_RENT_LAMPORTS,
    space: NONCE_ACCOUNT_LENGTH,
    programId: SystemProgram.programId,
  });

  const initNonceIx = SystemProgram.nonceInitialize({
    noncePubkey: nonceKeypair.publicKey,
    authorizedPubkey: authority,
  });

  return [createAccountIx, initNonceIx];
}

/**
 * Build a transaction to create multiple nonce accounts
 */
export async function buildCreateNonceAccountsTransaction(
  payer: PublicKey,
  count: number,
  authority: PublicKey
): Promise<{
  transaction: string;
  nonceKeypairs: string[];
  noncePublicKeys: string[];
}> {
  const { blockhash } = await connection.getLatestBlockhash('confirmed');
  
  const nonceKeypairs: Keypair[] = [];
  const instructions: TransactionInstruction[] = [];
  
  for (let i = 0; i < count; i++) {
    const nonceKeypair = Keypair.generate();
    nonceKeypairs.push(nonceKeypair);
    
    const ixs = buildCreateNonceAccountInstructions(payer, nonceKeypair, authority);
    instructions.push(...ixs);
  }
  
  const message = new TransactionMessage({
    payerKey: payer,
    recentBlockhash: blockhash,
    instructions,
  }).compileToV0Message();
  
  const tx = new VersionedTransaction(message);
  
  for (const keypair of nonceKeypairs) {
    tx.sign([keypair]);
  }
  
  return {
    transaction: Buffer.from(tx.serialize()).toString('base64'),
    nonceKeypairs: nonceKeypairs.map(kp => bs58.encode(kp.secretKey)),
    noncePublicKeys: nonceKeypairs.map(kp => kp.publicKey.toBase58()),
  };
}

/**
 * Get the current nonce value from a nonce account
 */
export async function getNonceValue(nonceAccountPubkey: PublicKey): Promise<string | null> {
  try {
    const accountInfo = await connection.getAccountInfo(nonceAccountPubkey);
    if (!accountInfo) {
      console.error('Nonce account not found:', nonceAccountPubkey.toBase58());
      return null;
    }
    
    const nonceAccount = NonceAccount.fromAccountData(accountInfo.data);
    return nonceAccount.nonce;
  } catch (error) {
    console.error('Error getting nonce value:', error);
    return null;
  }
}

/**
 * Build an advance nonce instruction
 */
export function buildAdvanceNonceInstruction(
  noncePubkey: PublicKey,
  authorizedPubkey: PublicKey
): TransactionInstruction {
  return SystemProgram.nonceAdvance({
    noncePubkey,
    authorizedPubkey,
  });
}

/**
 * Submit a transaction with exponential backoff until confirmed
 */
export async function submitWithExponentialBackoff(
  signedTransaction: Buffer,
  maxRetries: number = 20,
  initialDelayMs: number = 500,
  maxDelayMs: number = 30000
): Promise<{
  success: boolean;
  signature: string | null;
  error: string | null;
  attempts: number;
}> {
  let delay = initialDelayMs;
  let attempts = 0;
  let lastSignature: string | null = null;
  let lastError: string | null = null;
  
  while (attempts < maxRetries) {
    attempts++;
    
    try {
      const signature = await connection.sendRawTransaction(signedTransaction, {
        skipPreflight: true,
        maxRetries: 0,
      });
      lastSignature = signature;
      console.log(`Attempt ${attempts}: Sent tx ${signature.slice(0, 20)}...`);
      
      await new Promise(r => setTimeout(r, 2000));
      
      const status = await connection.getSignatureStatus(signature, {
        searchTransactionHistory: true,
      });
      
      if (status.value) {
        if (status.value.err) {
          lastError = JSON.stringify(status.value.err);
          console.error(`Attempt ${attempts}: TX failed on-chain:`, lastError);
          
          const errStr = lastError.toLowerCase();
          if (errStr.includes('insufficient') || errStr.includes('already processed')) {
            return {
              success: false,
              signature,
              error: lastError,
              attempts,
            };
          }
        } else if (
          status.value.confirmationStatus === 'confirmed' ||
          status.value.confirmationStatus === 'finalized'
        ) {
          console.log(`Attempt ${attempts}: TX CONFIRMED!`);
          return {
            success: true,
            signature,
            error: null,
            attempts,
          };
        }
      }
      
    } catch (err: any) {
      const msg = err?.message || String(err);
      lastError = msg;
      
      if (msg.includes('Blockhash not found') || msg.includes('block height exceeded')) {
        console.error(`Attempt ${attempts}: Blockhash expired`);
        return {
          success: false,
          signature: lastSignature,
          error: 'Blockhash expired - transaction cannot land',
          attempts,
        };
      }
      
      if (msg.includes('AlreadyProcessed') || msg.includes('already been processed')) {
        console.log(`Attempt ${attempts}: Already processed, checking status...`);
        if (lastSignature) {
          const status = await connection.getSignatureStatus(lastSignature, {
            searchTransactionHistory: true,
          });
          if (status.value && !status.value.err) {
            return {
              success: true,
              signature: lastSignature,
              error: null,
              attempts,
            };
          }
        }
      }
      
      console.warn(`Attempt ${attempts}: Error: ${msg.slice(0, 100)}`);
    }
    
    console.log(`Waiting ${delay}ms before retry...`);
    await new Promise(r => setTimeout(r, delay));
    delay = Math.min(delay * 1.5, maxDelayMs);
  }
  
  return {
    success: false,
    signature: lastSignature,
    error: lastError || 'Max retries exceeded',
    attempts,
  };
}

/**
 * Submit multiple transactions sequentially with exponential backoff
 */
export async function submitSequentialTransactions(
  signedTransactions: string[],
  onProgress?: (index: number, total: number, status: 'pending' | 'confirmed' | 'failed', signature?: string) => void
): Promise<{
  success: boolean;
  signatures: string[];
  failedIndex: number | null;
  error: string | null;
}> {
  const signatures: string[] = [];
  
  for (let i = 0; i < signedTransactions.length; i++) {
    const txBase64 = signedTransactions[i];
    const txBuffer = Buffer.from(txBase64, 'base64');
    
    console.log(`\n=== Submitting TX ${i + 1}/${signedTransactions.length} ===`);
    onProgress?.(i, signedTransactions.length, 'pending');
    
    const result = await submitWithExponentialBackoff(txBuffer);
    
    if (result.success && result.signature) {
      signatures.push(result.signature);
      console.log(`TX ${i + 1} confirmed: ${result.signature}`);
      onProgress?.(i, signedTransactions.length, 'confirmed', result.signature);
    } else {
      console.error(`TX ${i + 1} failed after ${result.attempts} attempts: ${result.error}`);
      onProgress?.(i, signedTransactions.length, 'failed', result.signature || undefined);
      
      return {
        success: false,
        signatures,
        failedIndex: i,
        error: `Transaction ${i + 1} failed: ${result.error}`,
      };
    }
  }
  
  return {
    success: true,
    signatures,
    failedIndex: null,
    error: null,
  };
}

export { connection, NONCE_RENT_LAMPORTS };
