/**
 * Solana Backend Services
 * Handles Jupiter API integration and transaction submission
 */

import { Connection, PublicKey, Transaction, VersionedTransaction, SimulatedTransactionResponse } from '@solana/web3.js';
import {
  submitSequentialTransactions,
  submitWithExponentialBackoff,
  buildCreateNonceAccountsTransaction,
  getNonceValue,
  NONCE_RENT_LAMPORTS,
} from './nonce.js';

// Helius RPC endpoint
const HELIUS_API_KEY = process.env.HELIUS_API_KEY || '0d4b4fd6-c2fc-4f55-b615-a23bab1ffc85';
const HELIUS_RPC_URL = `https://mainnet.helius-rpc.com/?api-key=${HELIUS_API_KEY}`;
const connection = new Connection(HELIUS_RPC_URL, 'confirmed');

// Jupiter API
const JUPITER_API_KEY = process.env.JUPITER_API_KEY || '6c006183-e55a-47cd-90b7-bd9b3f206a1a';
const JUPITER_API_URL = 'https://api.jup.ag/swap/v1';
const JUPITER_HEADERS = {
  'Content-Type': 'application/json',
  'x-api-key': JUPITER_API_KEY,
};

// PROOF V3 Token for fee burn
const PROOF_V3_MINT = 'CLWeikxiw8pC9JEtZt14fqDzYfXF7uVwLuvnJPkrE7av';

export interface QuoteInput {
  inputMint: string;
  outputMint: string;
  amount: string;
  slippageBps?: number;
}

/**
 * Get Jupiter quote for a swap
 */
export async function getJupiterQuote(input: QuoteInput): Promise<{
  success: boolean;
  quote?: any;
  error?: string;
}> {
  try {
    const { inputMint, outputMint, amount, slippageBps = 50 } = input;
    
    const params = new URLSearchParams({
      inputMint,
      outputMint,
      amount,
      slippageBps: slippageBps.toString(),
    });

    const response = await fetch(`${JUPITER_API_URL}/quote?${params}`, {
      headers: JUPITER_HEADERS,
    });
    
    if (!response.ok) {
      const error = await response.text();
      console.error('[Jupiter] Quote failed:', error);
      return { success: false, error: `Jupiter quote failed: ${error}` };
    }

    const quote = await response.json();
    
    if (!quote || !quote.outAmount) {
      return { success: false, error: 'Invalid quote response from Jupiter' };
    }
    
    return { success: true, quote };
  } catch (error) {
    console.error('[Jupiter] Quote error:', error);
    return { success: false, error: error instanceof Error ? error.message : 'Unknown error' };
  }
}

/**
 * Get fee swap transaction (input token -> PROOF V3)
 */
export async function getFeeSwapTransaction(inputMint: string, amount: string, userPublicKey: string) {
  const quoteParams = new URLSearchParams({
    inputMint,
    outputMint: PROOF_V3_MINT,
    amount,
    slippageBps: '1500',
  });

  const quoteResponse = await fetch(`${JUPITER_API_URL}/quote?${quoteParams}`, {
    headers: JUPITER_HEADERS,
  });
  
  if (!quoteResponse.ok) {
    const error = await quoteResponse.text();
    console.error('Fee swap quote failed:', error);
    return { swapTransaction: null, error: `Quote failed: ${error}` };
  }

  const quote = await quoteResponse.json();
  console.log('Fee swap quote:', JSON.stringify(quote).slice(0, 200));

  const swapResponse = await fetch(`${JUPITER_API_URL}/swap`, {
    method: 'POST',
    headers: JUPITER_HEADERS,
    body: JSON.stringify({
      quoteResponse: quote,
      userPublicKey,
      wrapAndUnwrapSol: true,
      dynamicComputeUnitLimit: true,
      prioritizationFeeLamports: 'auto',
      asLegacyTransaction: false,
      skipSimulation: true,
    }),
  });

  if (!swapResponse.ok) {
    const error = await swapResponse.text();
    console.error('Fee swap transaction failed:', error);
    return { swapTransaction: null, error: `Swap failed: ${error}` };
  }

  const result = await swapResponse.json();
  
  if (result.simulationError) {
    console.warn('Fee swap simulation warning:', JSON.stringify(result.simulationError));
  }
  
  return {
    swapTransaction: result.swapTransaction,
    lastValidBlockHeight: result.lastValidBlockHeight,
    error: null,
  };
}

/**
 * Get Jupiter swap transaction
 */
export async function getJupiterSwapTransaction(quoteResponse: any, userPublicKey: string): Promise<{
  success: boolean;
  transaction?: string;
  error?: string;
}> {
  try {
    const response = await fetch(`${JUPITER_API_URL}/swap`, {
      method: 'POST',
      headers: JUPITER_HEADERS,
      body: JSON.stringify({
        quoteResponse,
        userPublicKey,
        wrapAndUnwrapSol: true,
        dynamicComputeUnitLimit: true,
        prioritizationFeeLamports: 'auto',
        asLegacyTransaction: false,
        skipSimulation: true,
      }),
    });

    if (!response.ok) {
      const error = await response.text();
      console.error('[Jupiter] Swap failed:', error);
      return { success: false, error: `Jupiter swap failed: ${error}` };
    }

    const result = await response.json();
    
    if (result.simulationError) {
      console.warn('[Jupiter] Simulation warning:', JSON.stringify(result.simulationError));
    }
    
    if (!result.swapTransaction) {
      return { success: false, error: 'No swap transaction returned from Jupiter' };
    }
    
    return { success: true, transaction: result.swapTransaction };
  } catch (error) {
    console.error('[Jupiter] Swap error:', error);
    return { success: false, error: error instanceof Error ? error.message : 'Unknown error' };
  }
}

/**
 * Simulate a transaction
 */
export async function simulateTransaction(serializedTransaction: string, isVersioned: boolean = true): Promise<{
  success: boolean;
  logs: string[];
  unitsConsumed: number | null;
  error: string | null;
}> {
  try {
    const txBuffer = Buffer.from(serializedTransaction, 'base64');
    
    let simulation: SimulatedTransactionResponse;
    
    if (isVersioned) {
      const tx = VersionedTransaction.deserialize(txBuffer);
      const result = await connection.simulateTransaction(tx, {
        sigVerify: false,
        replaceRecentBlockhash: true,
      });
      simulation = result.value;
    } else {
      const tx = Transaction.from(txBuffer);
      const result = await connection.simulateTransaction(tx);
      simulation = result.value;
    }

    return {
      success: simulation.err === null,
      logs: simulation.logs || [],
      unitsConsumed: simulation.unitsConsumed || null,
      error: simulation.err ? JSON.stringify(simulation.err) : null,
    };
  } catch (error) {
    return {
      success: false,
      logs: [],
      unitsConsumed: null,
      error: error instanceof Error ? error.message : 'Unknown simulation error',
    };
  }
}

/**
 * Submit transactions sequentially
 */
export async function submitJitoBundle(signedTransactions: string[]): Promise<{
  success: boolean;
  bundleId: string | null;
  signature: string | null;
  signatures: string[];
  error: string | null;
  usedFallback: boolean;
}> {
  console.log('=== submitJitoBundle called (Sequential with Exponential Backoff) ===');
  console.log('Number of transactions to submit:', signedTransactions.length);
  
  const result = await submitSequentialTransactions(signedTransactions, (index, total, status, sig) => {
    console.log(`Progress: TX ${index + 1}/${total} - ${status}${sig ? ` (${sig.slice(0, 20)}...)` : ''}`);
  });
  
  if (result.success) {
    console.log('All transactions confirmed!');
    console.log('Signatures:', result.signatures);
    
    const mainSignature = result.signatures.length > 1 
      ? result.signatures[Math.min(2, result.signatures.length - 1)]
      : result.signatures[0];
    
    return {
      success: true,
      bundleId: null,
      signature: mainSignature || null,
      signatures: result.signatures,
      error: null,
      usedFallback: false,
    };
  } else {
    console.error('Transaction sequence failed:', result.error);
    return {
      success: false,
      bundleId: null,
      signature: null,
      signatures: result.signatures,
      error: result.error,
      usedFallback: false,
    };
  }
}

export { connection };
