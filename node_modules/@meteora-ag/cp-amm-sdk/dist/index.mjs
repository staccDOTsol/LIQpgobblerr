var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __pow = Math.pow;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// src/CpAmm.ts
import { Program } from "@coral-xyz/anchor";
import { NATIVE_MINT as NATIVE_MINT2, TOKEN_2022_PROGRAM_ID as TOKEN_2022_PROGRAM_ID3 } from "@solana/spl-token";
import invariant from "invariant";

// src/idl/cp_amm.json
var cp_amm_default = {
  address: "cpamdpZCGKUy5JxQXB4dcpGPiikHawvSWAd6mEn1sGG",
  metadata: {
    name: "cp_amm",
    version: "0.1.7",
    spec: "0.1.0",
    description: "Created with Anchor"
  },
  instructions: [
    {
      name: "add_liquidity",
      discriminator: [
        181,
        157,
        89,
        67,
        143,
        182,
        52,
        72
      ],
      accounts: [
        {
          name: "pool",
          writable: true,
          relations: [
            "position"
          ]
        },
        {
          name: "position",
          writable: true
        },
        {
          name: "token_a_account",
          docs: [
            "The user token a account"
          ],
          writable: true
        },
        {
          name: "token_b_account",
          docs: [
            "The user token b account"
          ],
          writable: true
        },
        {
          name: "token_a_vault",
          docs: [
            "The vault token account for input token"
          ],
          writable: true,
          relations: [
            "pool"
          ]
        },
        {
          name: "token_b_vault",
          docs: [
            "The vault token account for output token"
          ],
          writable: true,
          relations: [
            "pool"
          ]
        },
        {
          name: "token_a_mint",
          docs: [
            "The mint of token a"
          ],
          relations: [
            "pool"
          ]
        },
        {
          name: "token_b_mint",
          docs: [
            "The mint of token b"
          ],
          relations: [
            "pool"
          ]
        },
        {
          name: "position_nft_account",
          docs: [
            "The token account for nft"
          ]
        },
        {
          name: "owner",
          docs: [
            "owner of position"
          ],
          signer: true
        },
        {
          name: "token_a_program",
          docs: [
            "Token a program"
          ]
        },
        {
          name: "token_b_program",
          docs: [
            "Token b program"
          ]
        },
        {
          name: "event_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  95,
                  95,
                  101,
                  118,
                  101,
                  110,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              }
            ]
          }
        },
        {
          name: "program"
        }
      ],
      args: [
        {
          name: "params",
          type: {
            defined: {
              name: "AddLiquidityParameters"
            }
          }
        }
      ]
    },
    {
      name: "claim_partner_fee",
      discriminator: [
        97,
        206,
        39,
        105,
        94,
        94,
        126,
        148
      ],
      accounts: [
        {
          name: "pool_authority",
          address: "HLnpSz9h2S4hiLQ43rnSD9XkcUThA7B8hQMKmDaiTLcC"
        },
        {
          name: "pool",
          writable: true
        },
        {
          name: "token_a_account",
          docs: [
            "The treasury token a account"
          ],
          writable: true
        },
        {
          name: "token_b_account",
          docs: [
            "The treasury token b account"
          ],
          writable: true
        },
        {
          name: "token_a_vault",
          docs: [
            "The vault token account for input token"
          ],
          writable: true,
          relations: [
            "pool"
          ]
        },
        {
          name: "token_b_vault",
          docs: [
            "The vault token account for output token"
          ],
          writable: true,
          relations: [
            "pool"
          ]
        },
        {
          name: "token_a_mint",
          docs: [
            "The mint of token a"
          ],
          relations: [
            "pool"
          ]
        },
        {
          name: "token_b_mint",
          docs: [
            "The mint of token b"
          ],
          relations: [
            "pool"
          ]
        },
        {
          name: "partner",
          signer: true,
          relations: [
            "pool"
          ]
        },
        {
          name: "token_a_program",
          docs: [
            "Token a program"
          ]
        },
        {
          name: "token_b_program",
          docs: [
            "Token b program"
          ]
        },
        {
          name: "event_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  95,
                  95,
                  101,
                  118,
                  101,
                  110,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              }
            ]
          }
        },
        {
          name: "program"
        }
      ],
      args: [
        {
          name: "max_amount_a",
          type: "u64"
        },
        {
          name: "max_amount_b",
          type: "u64"
        }
      ]
    },
    {
      name: "claim_position_fee",
      discriminator: [
        180,
        38,
        154,
        17,
        133,
        33,
        162,
        211
      ],
      accounts: [
        {
          name: "pool_authority",
          address: "HLnpSz9h2S4hiLQ43rnSD9XkcUThA7B8hQMKmDaiTLcC"
        },
        {
          name: "pool",
          relations: [
            "position"
          ]
        },
        {
          name: "position",
          writable: true
        },
        {
          name: "token_a_account",
          docs: [
            "The user token a account"
          ],
          writable: true
        },
        {
          name: "token_b_account",
          docs: [
            "The user token b account"
          ],
          writable: true
        },
        {
          name: "token_a_vault",
          docs: [
            "The vault token account for input token"
          ],
          writable: true,
          relations: [
            "pool"
          ]
        },
        {
          name: "token_b_vault",
          docs: [
            "The vault token account for output token"
          ],
          writable: true,
          relations: [
            "pool"
          ]
        },
        {
          name: "token_a_mint",
          docs: [
            "The mint of token a"
          ],
          relations: [
            "pool"
          ]
        },
        {
          name: "token_b_mint",
          docs: [
            "The mint of token b"
          ],
          relations: [
            "pool"
          ]
        },
        {
          name: "position_nft_account",
          docs: [
            "The token account for nft"
          ]
        },
        {
          name: "owner",
          docs: [
            "owner of position"
          ],
          signer: true
        },
        {
          name: "token_a_program",
          docs: [
            "Token a program"
          ]
        },
        {
          name: "token_b_program",
          docs: [
            "Token b program"
          ]
        },
        {
          name: "event_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  95,
                  95,
                  101,
                  118,
                  101,
                  110,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              }
            ]
          }
        },
        {
          name: "program"
        }
      ],
      args: []
    },
    {
      name: "claim_protocol_fee",
      discriminator: [
        165,
        228,
        133,
        48,
        99,
        249,
        255,
        33
      ],
      accounts: [
        {
          name: "pool_authority",
          address: "HLnpSz9h2S4hiLQ43rnSD9XkcUThA7B8hQMKmDaiTLcC"
        },
        {
          name: "pool",
          writable: true
        },
        {
          name: "token_a_vault",
          docs: [
            "The vault token account for input token"
          ],
          writable: true,
          relations: [
            "pool"
          ]
        },
        {
          name: "token_b_vault",
          docs: [
            "The vault token account for output token"
          ],
          writable: true,
          relations: [
            "pool"
          ]
        },
        {
          name: "token_a_mint",
          docs: [
            "The mint of token a"
          ],
          relations: [
            "pool"
          ]
        },
        {
          name: "token_b_mint",
          docs: [
            "The mint of token b"
          ],
          relations: [
            "pool"
          ]
        },
        {
          name: "token_a_account",
          writable: true
        },
        {
          name: "token_b_account",
          writable: true
        },
        {
          name: "operator",
          docs: [
            "Claim fee operator"
          ]
        },
        {
          name: "signer",
          docs: [
            "Operator"
          ],
          signer: true
        },
        {
          name: "token_a_program",
          docs: [
            "Token a program"
          ]
        },
        {
          name: "token_b_program",
          docs: [
            "Token b program"
          ]
        },
        {
          name: "event_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  95,
                  95,
                  101,
                  118,
                  101,
                  110,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              }
            ]
          }
        },
        {
          name: "program"
        }
      ],
      args: [
        {
          name: "max_amount_a",
          type: "u64"
        },
        {
          name: "max_amount_b",
          type: "u64"
        }
      ]
    },
    {
      name: "claim_reward",
      discriminator: [
        149,
        95,
        181,
        242,
        94,
        90,
        158,
        162
      ],
      accounts: [
        {
          name: "pool_authority",
          address: "HLnpSz9h2S4hiLQ43rnSD9XkcUThA7B8hQMKmDaiTLcC"
        },
        {
          name: "pool",
          writable: true,
          relations: [
            "position"
          ]
        },
        {
          name: "position",
          writable: true
        },
        {
          name: "reward_vault",
          docs: [
            "The vault token account for reward token"
          ],
          writable: true
        },
        {
          name: "reward_mint"
        },
        {
          name: "user_token_account",
          writable: true
        },
        {
          name: "position_nft_account",
          docs: [
            "The token account for nft"
          ]
        },
        {
          name: "owner",
          docs: [
            "owner of position"
          ],
          signer: true
        },
        {
          name: "token_program"
        },
        {
          name: "event_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  95,
                  95,
                  101,
                  118,
                  101,
                  110,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              }
            ]
          }
        },
        {
          name: "program"
        }
      ],
      args: [
        {
          name: "reward_index",
          type: "u8"
        },
        {
          name: "skip_reward",
          type: "u8"
        }
      ]
    },
    {
      name: "close_config",
      discriminator: [
        145,
        9,
        72,
        157,
        95,
        125,
        61,
        85
      ],
      accounts: [
        {
          name: "config",
          writable: true
        },
        {
          name: "operator"
        },
        {
          name: "signer",
          signer: true
        },
        {
          name: "rent_receiver",
          writable: true
        },
        {
          name: "event_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  95,
                  95,
                  101,
                  118,
                  101,
                  110,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              }
            ]
          }
        },
        {
          name: "program"
        }
      ],
      args: []
    },
    {
      name: "close_operator_account",
      discriminator: [
        171,
        9,
        213,
        74,
        120,
        23,
        3,
        29
      ],
      accounts: [
        {
          name: "operator",
          writable: true
        },
        {
          name: "signer",
          signer: true
        },
        {
          name: "rent_receiver",
          writable: true
        },
        {
          name: "event_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  95,
                  95,
                  101,
                  118,
                  101,
                  110,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              }
            ]
          }
        },
        {
          name: "program"
        }
      ],
      args: []
    },
    {
      name: "close_position",
      discriminator: [
        123,
        134,
        81,
        0,
        49,
        68,
        98,
        98
      ],
      accounts: [
        {
          name: "position_nft_mint",
          docs: [
            "position_nft_mint"
          ],
          writable: true
        },
        {
          name: "position_nft_account",
          docs: [
            "The token account for nft"
          ],
          writable: true
        },
        {
          name: "pool",
          writable: true,
          relations: [
            "position"
          ]
        },
        {
          name: "position",
          writable: true
        },
        {
          name: "pool_authority",
          address: "HLnpSz9h2S4hiLQ43rnSD9XkcUThA7B8hQMKmDaiTLcC"
        },
        {
          name: "rent_receiver",
          writable: true
        },
        {
          name: "owner",
          docs: [
            "Owner of position"
          ],
          signer: true
        },
        {
          name: "token_program",
          docs: [
            "Program to create NFT mint/token account and transfer for token22 account"
          ],
          address: "TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb"
        },
        {
          name: "event_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  95,
                  95,
                  101,
                  118,
                  101,
                  110,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              }
            ]
          }
        },
        {
          name: "program"
        }
      ],
      args: []
    },
    {
      name: "close_token_badge",
      discriminator: [
        108,
        146,
        86,
        110,
        179,
        254,
        10,
        104
      ],
      accounts: [
        {
          name: "token_badge",
          writable: true
        },
        {
          name: "operator"
        },
        {
          name: "signer",
          signer: true
        },
        {
          name: "rent_receiver",
          writable: true
        },
        {
          name: "event_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  95,
                  95,
                  101,
                  118,
                  101,
                  110,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              }
            ]
          }
        },
        {
          name: "program"
        }
      ],
      args: []
    },
    {
      name: "create_config",
      docs: [
        "OPERATOR FUNCTIONS /////"
      ],
      discriminator: [
        201,
        207,
        243,
        114,
        75,
        111,
        47,
        189
      ],
      accounts: [
        {
          name: "config",
          writable: true,
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  99,
                  111,
                  110,
                  102,
                  105,
                  103
                ]
              },
              {
                kind: "arg",
                path: "index"
              }
            ]
          }
        },
        {
          name: "operator"
        },
        {
          name: "signer",
          signer: true
        },
        {
          name: "payer",
          writable: true,
          signer: true
        },
        {
          name: "system_program",
          address: "11111111111111111111111111111111"
        },
        {
          name: "event_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  95,
                  95,
                  101,
                  118,
                  101,
                  110,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              }
            ]
          }
        },
        {
          name: "program"
        }
      ],
      args: [
        {
          name: "index",
          type: "u64"
        },
        {
          name: "config_parameters",
          type: {
            defined: {
              name: "StaticConfigParameters"
            }
          }
        }
      ]
    },
    {
      name: "create_dynamic_config",
      discriminator: [
        81,
        251,
        122,
        78,
        66,
        57,
        208,
        82
      ],
      accounts: [
        {
          name: "config",
          writable: true,
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  99,
                  111,
                  110,
                  102,
                  105,
                  103
                ]
              },
              {
                kind: "arg",
                path: "index"
              }
            ]
          }
        },
        {
          name: "operator"
        },
        {
          name: "signer",
          signer: true
        },
        {
          name: "payer",
          writable: true,
          signer: true
        },
        {
          name: "system_program",
          address: "11111111111111111111111111111111"
        },
        {
          name: "event_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  95,
                  95,
                  101,
                  118,
                  101,
                  110,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              }
            ]
          }
        },
        {
          name: "program"
        }
      ],
      args: [
        {
          name: "index",
          type: "u64"
        },
        {
          name: "config_parameters",
          type: {
            defined: {
              name: "DynamicConfigParameters"
            }
          }
        }
      ]
    },
    {
      name: "create_operator_account",
      docs: [
        "ADMIN FUNCTIONS /////"
      ],
      discriminator: [
        221,
        64,
        246,
        149,
        240,
        153,
        229,
        163
      ],
      accounts: [
        {
          name: "operator",
          writable: true,
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  111,
                  112,
                  101,
                  114,
                  97,
                  116,
                  111,
                  114
                ]
              },
              {
                kind: "account",
                path: "whitelisted_address"
              }
            ]
          }
        },
        {
          name: "whitelisted_address"
        },
        {
          name: "signer",
          signer: true
        },
        {
          name: "payer",
          writable: true,
          signer: true
        },
        {
          name: "system_program",
          address: "11111111111111111111111111111111"
        },
        {
          name: "event_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  95,
                  95,
                  101,
                  118,
                  101,
                  110,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              }
            ]
          }
        },
        {
          name: "program"
        }
      ],
      args: [
        {
          name: "permission",
          type: "u128"
        }
      ]
    },
    {
      name: "create_position",
      discriminator: [
        48,
        215,
        197,
        153,
        96,
        203,
        180,
        133
      ],
      accounts: [
        {
          name: "owner"
        },
        {
          name: "position_nft_mint",
          docs: [
            "position_nft_mint"
          ],
          writable: true,
          signer: true
        },
        {
          name: "position_nft_account",
          docs: [
            "position nft account"
          ],
          writable: true,
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  112,
                  111,
                  115,
                  105,
                  116,
                  105,
                  111,
                  110,
                  95,
                  110,
                  102,
                  116,
                  95,
                  97,
                  99,
                  99,
                  111,
                  117,
                  110,
                  116
                ]
              },
              {
                kind: "account",
                path: "position_nft_mint"
              }
            ]
          }
        },
        {
          name: "pool",
          writable: true
        },
        {
          name: "position",
          writable: true,
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  112,
                  111,
                  115,
                  105,
                  116,
                  105,
                  111,
                  110
                ]
              },
              {
                kind: "account",
                path: "position_nft_mint"
              }
            ]
          }
        },
        {
          name: "pool_authority",
          address: "HLnpSz9h2S4hiLQ43rnSD9XkcUThA7B8hQMKmDaiTLcC"
        },
        {
          name: "payer",
          docs: [
            "Address paying to create the position. Can be anyone"
          ],
          writable: true,
          signer: true
        },
        {
          name: "token_program",
          docs: [
            "Program to create NFT mint/token account and transfer for token22 account"
          ],
          address: "TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb"
        },
        {
          name: "system_program",
          address: "11111111111111111111111111111111"
        },
        {
          name: "event_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  95,
                  95,
                  101,
                  118,
                  101,
                  110,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              }
            ]
          }
        },
        {
          name: "program"
        }
      ],
      args: []
    },
    {
      name: "create_token_badge",
      discriminator: [
        88,
        206,
        0,
        91,
        60,
        175,
        151,
        118
      ],
      accounts: [
        {
          name: "token_badge",
          writable: true,
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  116,
                  111,
                  107,
                  101,
                  110,
                  95,
                  98,
                  97,
                  100,
                  103,
                  101
                ]
              },
              {
                kind: "account",
                path: "token_mint"
              }
            ]
          }
        },
        {
          name: "token_mint"
        },
        {
          name: "operator"
        },
        {
          name: "signer",
          signer: true
        },
        {
          name: "payer",
          writable: true,
          signer: true
        },
        {
          name: "system_program",
          address: "11111111111111111111111111111111"
        },
        {
          name: "event_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  95,
                  95,
                  101,
                  118,
                  101,
                  110,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              }
            ]
          }
        },
        {
          name: "program"
        }
      ],
      args: []
    },
    {
      name: "dummy_ix",
      discriminator: [
        234,
        95,
        176,
        185,
        7,
        42,
        35,
        159
      ],
      accounts: [
        {
          name: "pod_aligned_fee_time_scheduler"
        },
        {
          name: "pod_aligned_fee_rate_limiter"
        },
        {
          name: "pod_aligned_fee_market_cap_scheduler"
        }
      ],
      args: [
        {
          name: "_ixs",
          type: {
            defined: {
              name: "DummyParams"
            }
          }
        }
      ]
    },
    {
      name: "fund_reward",
      discriminator: [
        188,
        50,
        249,
        165,
        93,
        151,
        38,
        63
      ],
      accounts: [
        {
          name: "pool",
          writable: true
        },
        {
          name: "reward_vault",
          writable: true
        },
        {
          name: "reward_mint"
        },
        {
          name: "funder_token_account",
          writable: true
        },
        {
          name: "funder",
          signer: true
        },
        {
          name: "token_program"
        },
        {
          name: "event_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  95,
                  95,
                  101,
                  118,
                  101,
                  110,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              }
            ]
          }
        },
        {
          name: "program"
        }
      ],
      args: [
        {
          name: "reward_index",
          type: "u8"
        },
        {
          name: "amount",
          type: "u64"
        },
        {
          name: "carry_forward",
          type: "bool"
        }
      ]
    },
    {
      name: "initialize_customizable_pool",
      discriminator: [
        20,
        161,
        241,
        24,
        189,
        221,
        180,
        2
      ],
      accounts: [
        {
          name: "creator"
        },
        {
          name: "position_nft_mint",
          docs: [
            "position_nft_mint"
          ],
          writable: true,
          signer: true
        },
        {
          name: "position_nft_account",
          docs: [
            "position nft account"
          ],
          writable: true,
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  112,
                  111,
                  115,
                  105,
                  116,
                  105,
                  111,
                  110,
                  95,
                  110,
                  102,
                  116,
                  95,
                  97,
                  99,
                  99,
                  111,
                  117,
                  110,
                  116
                ]
              },
              {
                kind: "account",
                path: "position_nft_mint"
              }
            ]
          }
        },
        {
          name: "payer",
          docs: [
            "Address paying to create the pool. Can be anyone"
          ],
          writable: true,
          signer: true
        },
        {
          name: "pool_authority",
          address: "HLnpSz9h2S4hiLQ43rnSD9XkcUThA7B8hQMKmDaiTLcC"
        },
        {
          name: "pool",
          docs: [
            "Initialize an account to store the pool state"
          ],
          writable: true
        },
        {
          name: "position",
          writable: true,
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  112,
                  111,
                  115,
                  105,
                  116,
                  105,
                  111,
                  110
                ]
              },
              {
                kind: "account",
                path: "position_nft_mint"
              }
            ]
          }
        },
        {
          name: "token_a_mint",
          docs: [
            "Token a mint"
          ]
        },
        {
          name: "token_b_mint",
          docs: [
            "Token b mint"
          ]
        },
        {
          name: "token_a_vault",
          docs: [
            "Token a vault for the pool"
          ],
          writable: true,
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  116,
                  111,
                  107,
                  101,
                  110,
                  95,
                  118,
                  97,
                  117,
                  108,
                  116
                ]
              },
              {
                kind: "account",
                path: "token_a_mint"
              },
              {
                kind: "account",
                path: "pool"
              }
            ]
          }
        },
        {
          name: "token_b_vault",
          docs: [
            "Token b vault for the pool"
          ],
          writable: true,
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  116,
                  111,
                  107,
                  101,
                  110,
                  95,
                  118,
                  97,
                  117,
                  108,
                  116
                ]
              },
              {
                kind: "account",
                path: "token_b_mint"
              },
              {
                kind: "account",
                path: "pool"
              }
            ]
          }
        },
        {
          name: "payer_token_a",
          docs: [
            "payer token a account"
          ],
          writable: true
        },
        {
          name: "payer_token_b",
          docs: [
            "creator token b account"
          ],
          writable: true
        },
        {
          name: "token_a_program",
          docs: [
            "Program to create mint account and mint tokens"
          ]
        },
        {
          name: "token_b_program",
          docs: [
            "Program to create mint account and mint tokens"
          ]
        },
        {
          name: "token_2022_program",
          docs: [
            "Program to create NFT mint/token account and transfer for token22 account"
          ],
          address: "TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb"
        },
        {
          name: "system_program",
          address: "11111111111111111111111111111111"
        },
        {
          name: "event_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  95,
                  95,
                  101,
                  118,
                  101,
                  110,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              }
            ]
          }
        },
        {
          name: "program"
        }
      ],
      args: [
        {
          name: "params",
          type: {
            defined: {
              name: "InitializeCustomizablePoolParameters"
            }
          }
        }
      ]
    },
    {
      name: "initialize_pool",
      docs: [
        "USER FUNCTIONS ////"
      ],
      discriminator: [
        95,
        180,
        10,
        172,
        84,
        174,
        232,
        40
      ],
      accounts: [
        {
          name: "creator"
        },
        {
          name: "position_nft_mint",
          docs: [
            "position_nft_mint"
          ],
          writable: true,
          signer: true
        },
        {
          name: "position_nft_account",
          docs: [
            "position nft account"
          ],
          writable: true,
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  112,
                  111,
                  115,
                  105,
                  116,
                  105,
                  111,
                  110,
                  95,
                  110,
                  102,
                  116,
                  95,
                  97,
                  99,
                  99,
                  111,
                  117,
                  110,
                  116
                ]
              },
              {
                kind: "account",
                path: "position_nft_mint"
              }
            ]
          }
        },
        {
          name: "payer",
          docs: [
            "Address paying to create the pool. Can be anyone"
          ],
          writable: true,
          signer: true
        },
        {
          name: "config",
          docs: [
            "Which config the pool belongs to."
          ]
        },
        {
          name: "pool_authority",
          address: "HLnpSz9h2S4hiLQ43rnSD9XkcUThA7B8hQMKmDaiTLcC"
        },
        {
          name: "pool",
          docs: [
            "Initialize an account to store the pool state"
          ],
          writable: true
        },
        {
          name: "position",
          writable: true,
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  112,
                  111,
                  115,
                  105,
                  116,
                  105,
                  111,
                  110
                ]
              },
              {
                kind: "account",
                path: "position_nft_mint"
              }
            ]
          }
        },
        {
          name: "token_a_mint",
          docs: [
            "Token a mint"
          ]
        },
        {
          name: "token_b_mint",
          docs: [
            "Token b mint"
          ]
        },
        {
          name: "token_a_vault",
          docs: [
            "Token a vault for the pool"
          ],
          writable: true,
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  116,
                  111,
                  107,
                  101,
                  110,
                  95,
                  118,
                  97,
                  117,
                  108,
                  116
                ]
              },
              {
                kind: "account",
                path: "token_a_mint"
              },
              {
                kind: "account",
                path: "pool"
              }
            ]
          }
        },
        {
          name: "token_b_vault",
          docs: [
            "Token b vault for the pool"
          ],
          writable: true,
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  116,
                  111,
                  107,
                  101,
                  110,
                  95,
                  118,
                  97,
                  117,
                  108,
                  116
                ]
              },
              {
                kind: "account",
                path: "token_b_mint"
              },
              {
                kind: "account",
                path: "pool"
              }
            ]
          }
        },
        {
          name: "payer_token_a",
          docs: [
            "payer token a account"
          ],
          writable: true
        },
        {
          name: "payer_token_b",
          docs: [
            "creator token b account"
          ],
          writable: true
        },
        {
          name: "token_a_program",
          docs: [
            "Program to create mint account and mint tokens"
          ]
        },
        {
          name: "token_b_program",
          docs: [
            "Program to create mint account and mint tokens"
          ]
        },
        {
          name: "token_2022_program",
          docs: [
            "Program to create NFT mint/token account and transfer for token22 account"
          ],
          address: "TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb"
        },
        {
          name: "system_program",
          address: "11111111111111111111111111111111"
        },
        {
          name: "event_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  95,
                  95,
                  101,
                  118,
                  101,
                  110,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              }
            ]
          }
        },
        {
          name: "program"
        }
      ],
      args: [
        {
          name: "params",
          type: {
            defined: {
              name: "InitializePoolParameters"
            }
          }
        }
      ]
    },
    {
      name: "initialize_pool_with_dynamic_config",
      discriminator: [
        149,
        82,
        72,
        197,
        253,
        252,
        68,
        15
      ],
      accounts: [
        {
          name: "creator"
        },
        {
          name: "position_nft_mint",
          docs: [
            "position_nft_mint"
          ],
          writable: true,
          signer: true
        },
        {
          name: "position_nft_account",
          docs: [
            "position nft account"
          ],
          writable: true,
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  112,
                  111,
                  115,
                  105,
                  116,
                  105,
                  111,
                  110,
                  95,
                  110,
                  102,
                  116,
                  95,
                  97,
                  99,
                  99,
                  111,
                  117,
                  110,
                  116
                ]
              },
              {
                kind: "account",
                path: "position_nft_mint"
              }
            ]
          }
        },
        {
          name: "payer",
          docs: [
            "Address paying to create the pool. Can be anyone"
          ],
          writable: true,
          signer: true
        },
        {
          name: "pool_creator_authority",
          signer: true,
          relations: [
            "config"
          ]
        },
        {
          name: "config",
          docs: [
            "Which config the pool belongs to."
          ]
        },
        {
          name: "pool_authority",
          address: "HLnpSz9h2S4hiLQ43rnSD9XkcUThA7B8hQMKmDaiTLcC"
        },
        {
          name: "pool",
          docs: [
            "Initialize an account to store the pool state"
          ],
          writable: true
        },
        {
          name: "position",
          writable: true,
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  112,
                  111,
                  115,
                  105,
                  116,
                  105,
                  111,
                  110
                ]
              },
              {
                kind: "account",
                path: "position_nft_mint"
              }
            ]
          }
        },
        {
          name: "token_a_mint",
          docs: [
            "Token a mint"
          ]
        },
        {
          name: "token_b_mint",
          docs: [
            "Token b mint"
          ]
        },
        {
          name: "token_a_vault",
          docs: [
            "Token a vault for the pool"
          ],
          writable: true,
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  116,
                  111,
                  107,
                  101,
                  110,
                  95,
                  118,
                  97,
                  117,
                  108,
                  116
                ]
              },
              {
                kind: "account",
                path: "token_a_mint"
              },
              {
                kind: "account",
                path: "pool"
              }
            ]
          }
        },
        {
          name: "token_b_vault",
          docs: [
            "Token b vault for the pool"
          ],
          writable: true,
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  116,
                  111,
                  107,
                  101,
                  110,
                  95,
                  118,
                  97,
                  117,
                  108,
                  116
                ]
              },
              {
                kind: "account",
                path: "token_b_mint"
              },
              {
                kind: "account",
                path: "pool"
              }
            ]
          }
        },
        {
          name: "payer_token_a",
          docs: [
            "payer token a account"
          ],
          writable: true
        },
        {
          name: "payer_token_b",
          docs: [
            "creator token b account"
          ],
          writable: true
        },
        {
          name: "token_a_program",
          docs: [
            "Program to create mint account and mint tokens"
          ]
        },
        {
          name: "token_b_program",
          docs: [
            "Program to create mint account and mint tokens"
          ]
        },
        {
          name: "token_2022_program",
          docs: [
            "Program to create NFT mint/token account and transfer for token22 account"
          ],
          address: "TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb"
        },
        {
          name: "system_program",
          address: "11111111111111111111111111111111"
        },
        {
          name: "event_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  95,
                  95,
                  101,
                  118,
                  101,
                  110,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              }
            ]
          }
        },
        {
          name: "program"
        }
      ],
      args: [
        {
          name: "params",
          type: {
            defined: {
              name: "InitializeCustomizablePoolParameters"
            }
          }
        }
      ]
    },
    {
      name: "initialize_reward",
      discriminator: [
        95,
        135,
        192,
        196,
        242,
        129,
        230,
        68
      ],
      accounts: [
        {
          name: "pool_authority",
          address: "HLnpSz9h2S4hiLQ43rnSD9XkcUThA7B8hQMKmDaiTLcC"
        },
        {
          name: "pool",
          writable: true
        },
        {
          name: "reward_vault",
          writable: true,
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  114,
                  101,
                  119,
                  97,
                  114,
                  100,
                  95,
                  118,
                  97,
                  117,
                  108,
                  116
                ]
              },
              {
                kind: "account",
                path: "pool"
              },
              {
                kind: "arg",
                path: "reward_index"
              }
            ]
          }
        },
        {
          name: "reward_mint"
        },
        {
          name: "signer",
          signer: true
        },
        {
          name: "payer",
          writable: true,
          signer: true
        },
        {
          name: "token_program"
        },
        {
          name: "system_program",
          address: "11111111111111111111111111111111"
        },
        {
          name: "event_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  95,
                  95,
                  101,
                  118,
                  101,
                  110,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              }
            ]
          }
        },
        {
          name: "program"
        }
      ],
      args: [
        {
          name: "reward_index",
          type: "u8"
        },
        {
          name: "reward_duration",
          type: "u64"
        },
        {
          name: "funder",
          type: "pubkey"
        }
      ]
    },
    {
      name: "lock_position",
      discriminator: [
        227,
        62,
        2,
        252,
        247,
        10,
        171,
        185
      ],
      accounts: [
        {
          name: "pool",
          relations: [
            "position"
          ]
        },
        {
          name: "position",
          writable: true
        },
        {
          name: "vesting",
          writable: true,
          signer: true
        },
        {
          name: "position_nft_account",
          docs: [
            "The token account for nft"
          ]
        },
        {
          name: "owner",
          docs: [
            "owner of position"
          ],
          signer: true
        },
        {
          name: "payer",
          writable: true,
          signer: true
        },
        {
          name: "system_program",
          address: "11111111111111111111111111111111"
        },
        {
          name: "event_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  95,
                  95,
                  101,
                  118,
                  101,
                  110,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              }
            ]
          }
        },
        {
          name: "program"
        }
      ],
      args: [
        {
          name: "params",
          type: {
            defined: {
              name: "VestingParameters"
            }
          }
        }
      ]
    },
    {
      name: "permanent_lock_position",
      discriminator: [
        165,
        176,
        125,
        6,
        231,
        171,
        186,
        213
      ],
      accounts: [
        {
          name: "pool",
          writable: true,
          relations: [
            "position"
          ]
        },
        {
          name: "position",
          writable: true
        },
        {
          name: "position_nft_account",
          docs: [
            "The token account for nft"
          ]
        },
        {
          name: "owner",
          docs: [
            "owner of position"
          ],
          signer: true
        },
        {
          name: "event_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  95,
                  95,
                  101,
                  118,
                  101,
                  110,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              }
            ]
          }
        },
        {
          name: "program"
        }
      ],
      args: [
        {
          name: "permanent_lock_liquidity",
          type: "u128"
        }
      ]
    },
    {
      name: "refresh_vesting",
      discriminator: [
        9,
        94,
        216,
        14,
        116,
        204,
        247,
        0
      ],
      accounts: [
        {
          name: "pool",
          relations: [
            "position"
          ]
        },
        {
          name: "position",
          writable: true
        },
        {
          name: "position_nft_account",
          docs: [
            "The token account for nft"
          ]
        },
        {
          name: "owner"
        }
      ],
      args: []
    },
    {
      name: "remove_all_liquidity",
      discriminator: [
        10,
        51,
        61,
        35,
        112,
        105,
        24,
        85
      ],
      accounts: [
        {
          name: "pool_authority",
          address: "HLnpSz9h2S4hiLQ43rnSD9XkcUThA7B8hQMKmDaiTLcC"
        },
        {
          name: "pool",
          writable: true,
          relations: [
            "position"
          ]
        },
        {
          name: "position",
          writable: true
        },
        {
          name: "token_a_account",
          docs: [
            "The user token a account"
          ],
          writable: true
        },
        {
          name: "token_b_account",
          docs: [
            "The user token b account"
          ],
          writable: true
        },
        {
          name: "token_a_vault",
          docs: [
            "The vault token account for input token"
          ],
          writable: true,
          relations: [
            "pool"
          ]
        },
        {
          name: "token_b_vault",
          docs: [
            "The vault token account for output token"
          ],
          writable: true,
          relations: [
            "pool"
          ]
        },
        {
          name: "token_a_mint",
          docs: [
            "The mint of token a"
          ],
          relations: [
            "pool"
          ]
        },
        {
          name: "token_b_mint",
          docs: [
            "The mint of token b"
          ],
          relations: [
            "pool"
          ]
        },
        {
          name: "position_nft_account",
          docs: [
            "The token account for nft"
          ]
        },
        {
          name: "owner",
          docs: [
            "owner of position"
          ],
          signer: true
        },
        {
          name: "token_a_program",
          docs: [
            "Token a program"
          ]
        },
        {
          name: "token_b_program",
          docs: [
            "Token b program"
          ]
        },
        {
          name: "event_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  95,
                  95,
                  101,
                  118,
                  101,
                  110,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              }
            ]
          }
        },
        {
          name: "program"
        }
      ],
      args: [
        {
          name: "token_a_amount_threshold",
          type: "u64"
        },
        {
          name: "token_b_amount_threshold",
          type: "u64"
        }
      ]
    },
    {
      name: "remove_liquidity",
      discriminator: [
        80,
        85,
        209,
        72,
        24,
        206,
        177,
        108
      ],
      accounts: [
        {
          name: "pool_authority",
          address: "HLnpSz9h2S4hiLQ43rnSD9XkcUThA7B8hQMKmDaiTLcC"
        },
        {
          name: "pool",
          writable: true,
          relations: [
            "position"
          ]
        },
        {
          name: "position",
          writable: true
        },
        {
          name: "token_a_account",
          docs: [
            "The user token a account"
          ],
          writable: true
        },
        {
          name: "token_b_account",
          docs: [
            "The user token b account"
          ],
          writable: true
        },
        {
          name: "token_a_vault",
          docs: [
            "The vault token account for input token"
          ],
          writable: true,
          relations: [
            "pool"
          ]
        },
        {
          name: "token_b_vault",
          docs: [
            "The vault token account for output token"
          ],
          writable: true,
          relations: [
            "pool"
          ]
        },
        {
          name: "token_a_mint",
          docs: [
            "The mint of token a"
          ],
          relations: [
            "pool"
          ]
        },
        {
          name: "token_b_mint",
          docs: [
            "The mint of token b"
          ],
          relations: [
            "pool"
          ]
        },
        {
          name: "position_nft_account",
          docs: [
            "The token account for nft"
          ]
        },
        {
          name: "owner",
          docs: [
            "owner of position"
          ],
          signer: true
        },
        {
          name: "token_a_program",
          docs: [
            "Token a program"
          ]
        },
        {
          name: "token_b_program",
          docs: [
            "Token b program"
          ]
        },
        {
          name: "event_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  95,
                  95,
                  101,
                  118,
                  101,
                  110,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              }
            ]
          }
        },
        {
          name: "program"
        }
      ],
      args: [
        {
          name: "params",
          type: {
            defined: {
              name: "RemoveLiquidityParameters"
            }
          }
        }
      ]
    },
    {
      name: "set_pool_status",
      discriminator: [
        112,
        87,
        135,
        223,
        83,
        204,
        132,
        53
      ],
      accounts: [
        {
          name: "pool",
          writable: true
        },
        {
          name: "operator"
        },
        {
          name: "signer",
          signer: true
        },
        {
          name: "event_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  95,
                  95,
                  101,
                  118,
                  101,
                  110,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              }
            ]
          }
        },
        {
          name: "program"
        }
      ],
      args: [
        {
          name: "status",
          type: "u8"
        }
      ]
    },
    {
      name: "split_position",
      discriminator: [
        172,
        241,
        221,
        138,
        161,
        29,
        253,
        42
      ],
      accounts: [
        {
          name: "pool",
          writable: true,
          relations: [
            "first_position",
            "second_position"
          ]
        },
        {
          name: "first_position",
          docs: [
            "The first position"
          ],
          writable: true
        },
        {
          name: "first_position_nft_account",
          docs: [
            "The token account for position nft"
          ]
        },
        {
          name: "second_position",
          docs: [
            "The second position"
          ],
          writable: true
        },
        {
          name: "second_position_nft_account",
          docs: [
            "The token account for position nft"
          ]
        },
        {
          name: "first_owner",
          docs: [
            "Owner of first position"
          ],
          signer: true
        },
        {
          name: "second_owner",
          docs: [
            "Owner of second position"
          ],
          signer: true
        },
        {
          name: "event_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  95,
                  95,
                  101,
                  118,
                  101,
                  110,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              }
            ]
          }
        },
        {
          name: "program"
        }
      ],
      args: [
        {
          name: "params",
          type: {
            defined: {
              name: "SplitPositionParameters"
            }
          }
        }
      ]
    },
    {
      name: "split_position2",
      discriminator: [
        221,
        147,
        228,
        207,
        140,
        212,
        17,
        119
      ],
      accounts: [
        {
          name: "pool",
          writable: true,
          relations: [
            "first_position",
            "second_position"
          ]
        },
        {
          name: "first_position",
          docs: [
            "The first position"
          ],
          writable: true
        },
        {
          name: "first_position_nft_account",
          docs: [
            "The token account for position nft"
          ]
        },
        {
          name: "second_position",
          docs: [
            "The second position"
          ],
          writable: true
        },
        {
          name: "second_position_nft_account",
          docs: [
            "The token account for position nft"
          ]
        },
        {
          name: "first_owner",
          docs: [
            "Owner of first position"
          ],
          signer: true
        },
        {
          name: "second_owner",
          docs: [
            "Owner of second position"
          ],
          signer: true
        },
        {
          name: "event_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  95,
                  95,
                  101,
                  118,
                  101,
                  110,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              }
            ]
          }
        },
        {
          name: "program"
        }
      ],
      args: [
        {
          name: "numerator",
          type: "u32"
        }
      ]
    },
    {
      name: "swap",
      discriminator: [
        248,
        198,
        158,
        145,
        225,
        117,
        135,
        200
      ],
      accounts: [
        {
          name: "pool_authority",
          address: "HLnpSz9h2S4hiLQ43rnSD9XkcUThA7B8hQMKmDaiTLcC"
        },
        {
          name: "pool",
          docs: [
            "Pool account"
          ],
          writable: true
        },
        {
          name: "input_token_account",
          docs: [
            "The user token account for input token"
          ],
          writable: true
        },
        {
          name: "output_token_account",
          docs: [
            "The user token account for output token"
          ],
          writable: true
        },
        {
          name: "token_a_vault",
          docs: [
            "The vault token account for input token"
          ],
          writable: true,
          relations: [
            "pool"
          ]
        },
        {
          name: "token_b_vault",
          docs: [
            "The vault token account for output token"
          ],
          writable: true,
          relations: [
            "pool"
          ]
        },
        {
          name: "token_a_mint",
          docs: [
            "The mint of token a"
          ]
        },
        {
          name: "token_b_mint",
          docs: [
            "The mint of token b"
          ]
        },
        {
          name: "payer",
          docs: [
            "The user performing the swap"
          ],
          signer: true
        },
        {
          name: "token_a_program",
          docs: [
            "Token a program"
          ]
        },
        {
          name: "token_b_program",
          docs: [
            "Token b program"
          ]
        },
        {
          name: "referral_token_account",
          docs: [
            "referral token account"
          ],
          writable: true,
          optional: true
        },
        {
          name: "event_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  95,
                  95,
                  101,
                  118,
                  101,
                  110,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              }
            ]
          }
        },
        {
          name: "program"
        }
      ],
      args: [
        {
          name: "_params",
          type: {
            defined: {
              name: "SwapParameters"
            }
          }
        }
      ]
    },
    {
      name: "swap2",
      discriminator: [
        65,
        75,
        63,
        76,
        235,
        91,
        91,
        136
      ],
      accounts: [
        {
          name: "pool_authority",
          address: "HLnpSz9h2S4hiLQ43rnSD9XkcUThA7B8hQMKmDaiTLcC"
        },
        {
          name: "pool",
          docs: [
            "Pool account"
          ],
          writable: true
        },
        {
          name: "input_token_account",
          docs: [
            "The user token account for input token"
          ],
          writable: true
        },
        {
          name: "output_token_account",
          docs: [
            "The user token account for output token"
          ],
          writable: true
        },
        {
          name: "token_a_vault",
          docs: [
            "The vault token account for input token"
          ],
          writable: true,
          relations: [
            "pool"
          ]
        },
        {
          name: "token_b_vault",
          docs: [
            "The vault token account for output token"
          ],
          writable: true,
          relations: [
            "pool"
          ]
        },
        {
          name: "token_a_mint",
          docs: [
            "The mint of token a"
          ]
        },
        {
          name: "token_b_mint",
          docs: [
            "The mint of token b"
          ]
        },
        {
          name: "payer",
          docs: [
            "The user performing the swap"
          ],
          signer: true
        },
        {
          name: "token_a_program",
          docs: [
            "Token a program"
          ]
        },
        {
          name: "token_b_program",
          docs: [
            "Token b program"
          ]
        },
        {
          name: "referral_token_account",
          docs: [
            "referral token account"
          ],
          writable: true,
          optional: true
        },
        {
          name: "event_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  95,
                  95,
                  101,
                  118,
                  101,
                  110,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              }
            ]
          }
        },
        {
          name: "program"
        }
      ],
      args: [
        {
          name: "_params",
          type: {
            defined: {
              name: "SwapParameters2"
            }
          }
        }
      ]
    },
    {
      name: "update_pool_fees",
      discriminator: [
        118,
        217,
        203,
        179,
        60,
        8,
        70,
        89
      ],
      accounts: [
        {
          name: "pool",
          writable: true
        },
        {
          name: "operator"
        },
        {
          name: "signer",
          signer: true
        },
        {
          name: "event_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  95,
                  95,
                  101,
                  118,
                  101,
                  110,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              }
            ]
          }
        },
        {
          name: "program"
        }
      ],
      args: [
        {
          name: "params",
          type: {
            defined: {
              name: "UpdatePoolFeesParameters"
            }
          }
        }
      ]
    },
    {
      name: "update_reward_duration",
      discriminator: [
        138,
        174,
        196,
        169,
        213,
        235,
        254,
        107
      ],
      accounts: [
        {
          name: "pool",
          writable: true
        },
        {
          name: "signer",
          signer: true
        },
        {
          name: "event_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  95,
                  95,
                  101,
                  118,
                  101,
                  110,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              }
            ]
          }
        },
        {
          name: "program"
        }
      ],
      args: [
        {
          name: "reward_index",
          type: "u8"
        },
        {
          name: "new_duration",
          type: "u64"
        }
      ]
    },
    {
      name: "update_reward_funder",
      discriminator: [
        211,
        28,
        48,
        32,
        215,
        160,
        35,
        23
      ],
      accounts: [
        {
          name: "pool",
          writable: true
        },
        {
          name: "signer",
          signer: true
        },
        {
          name: "event_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  95,
                  95,
                  101,
                  118,
                  101,
                  110,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              }
            ]
          }
        },
        {
          name: "program"
        }
      ],
      args: [
        {
          name: "reward_index",
          type: "u8"
        },
        {
          name: "new_funder",
          type: "pubkey"
        }
      ]
    },
    {
      name: "withdraw_ineligible_reward",
      discriminator: [
        148,
        206,
        42,
        195,
        247,
        49,
        103,
        8
      ],
      accounts: [
        {
          name: "pool_authority",
          address: "HLnpSz9h2S4hiLQ43rnSD9XkcUThA7B8hQMKmDaiTLcC"
        },
        {
          name: "pool",
          writable: true
        },
        {
          name: "reward_vault",
          writable: true
        },
        {
          name: "reward_mint"
        },
        {
          name: "funder_token_account",
          writable: true
        },
        {
          name: "funder",
          signer: true
        },
        {
          name: "token_program"
        },
        {
          name: "event_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  95,
                  95,
                  101,
                  118,
                  101,
                  110,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              }
            ]
          }
        },
        {
          name: "program"
        }
      ],
      args: [
        {
          name: "reward_index",
          type: "u8"
        }
      ]
    },
    {
      name: "zap_protocol_fee",
      discriminator: [
        213,
        155,
        187,
        34,
        56,
        182,
        91,
        240
      ],
      accounts: [
        {
          name: "pool_authority",
          address: "HLnpSz9h2S4hiLQ43rnSD9XkcUThA7B8hQMKmDaiTLcC"
        },
        {
          name: "pool",
          writable: true
        },
        {
          name: "token_vault",
          writable: true
        },
        {
          name: "token_mint"
        },
        {
          name: "receiver_token",
          writable: true
        },
        {
          name: "operator",
          docs: [
            "zap claim fee operator"
          ]
        },
        {
          name: "signer",
          docs: [
            "Operator"
          ],
          signer: true
        },
        {
          name: "token_program",
          docs: [
            "Token program"
          ]
        },
        {
          name: "sysvar_instructions",
          address: "Sysvar1nstructions1111111111111111111111111"
        }
      ],
      args: [
        {
          name: "max_amount",
          type: "u64"
        }
      ]
    }
  ],
  accounts: [
    {
      name: "Config",
      discriminator: [
        155,
        12,
        170,
        224,
        30,
        250,
        204,
        130
      ]
    },
    {
      name: "Operator",
      discriminator: [
        219,
        31,
        188,
        145,
        69,
        139,
        204,
        117
      ]
    },
    {
      name: "PodAlignedFeeMarketCapScheduler",
      discriminator: [
        251,
        130,
        208,
        253,
        245,
        27,
        145,
        203
      ]
    },
    {
      name: "PodAlignedFeeRateLimiter",
      discriminator: [
        160,
        219,
        8,
        251,
        179,
        7,
        16,
        117
      ]
    },
    {
      name: "PodAlignedFeeTimeScheduler",
      discriminator: [
        239,
        132,
        138,
        213,
        67,
        154,
        130,
        70
      ]
    },
    {
      name: "Pool",
      discriminator: [
        241,
        154,
        109,
        4,
        17,
        177,
        109,
        188
      ]
    },
    {
      name: "Position",
      discriminator: [
        170,
        188,
        143,
        228,
        122,
        64,
        247,
        208
      ]
    },
    {
      name: "TokenBadge",
      discriminator: [
        116,
        219,
        204,
        229,
        249,
        116,
        255,
        150
      ]
    },
    {
      name: "Vesting",
      discriminator: [
        100,
        149,
        66,
        138,
        95,
        200,
        128,
        241
      ]
    }
  ],
  events: [
    {
      name: "EvtClaimPartnerFee",
      discriminator: [
        118,
        99,
        77,
        10,
        226,
        1,
        1,
        87
      ]
    },
    {
      name: "EvtClaimPositionFee",
      discriminator: [
        198,
        182,
        183,
        52,
        97,
        12,
        49,
        56
      ]
    },
    {
      name: "EvtClaimProtocolFee",
      discriminator: [
        186,
        244,
        75,
        251,
        188,
        13,
        25,
        33
      ]
    },
    {
      name: "EvtClaimReward",
      discriminator: [
        218,
        86,
        147,
        200,
        235,
        188,
        215,
        231
      ]
    },
    {
      name: "EvtCloseConfig",
      discriminator: [
        36,
        30,
        239,
        45,
        58,
        132,
        14,
        5
      ]
    },
    {
      name: "EvtClosePosition",
      discriminator: [
        20,
        145,
        144,
        68,
        143,
        142,
        214,
        178
      ]
    },
    {
      name: "EvtCreateConfig",
      discriminator: [
        131,
        207,
        180,
        174,
        180,
        73,
        165,
        54
      ]
    },
    {
      name: "EvtCreateDynamicConfig",
      discriminator: [
        231,
        197,
        13,
        164,
        248,
        213,
        133,
        152
      ]
    },
    {
      name: "EvtCreatePosition",
      discriminator: [
        156,
        15,
        119,
        198,
        29,
        181,
        221,
        55
      ]
    },
    {
      name: "EvtCreateTokenBadge",
      discriminator: [
        141,
        120,
        134,
        116,
        34,
        28,
        114,
        160
      ]
    },
    {
      name: "EvtFundReward",
      discriminator: [
        104,
        233,
        237,
        122,
        199,
        191,
        121,
        85
      ]
    },
    {
      name: "EvtInitializePool",
      discriminator: [
        228,
        50,
        246,
        85,
        203,
        66,
        134,
        37
      ]
    },
    {
      name: "EvtInitializeReward",
      discriminator: [
        129,
        91,
        188,
        3,
        246,
        52,
        185,
        249
      ]
    },
    {
      name: "EvtLiquidityChange",
      discriminator: [
        197,
        171,
        78,
        127,
        224,
        211,
        87,
        13
      ]
    },
    {
      name: "EvtLockPosition",
      discriminator: [
        168,
        63,
        108,
        83,
        219,
        82,
        2,
        200
      ]
    },
    {
      name: "EvtPermanentLockPosition",
      discriminator: [
        145,
        143,
        162,
        218,
        218,
        80,
        67,
        11
      ]
    },
    {
      name: "EvtSetPoolStatus",
      discriminator: [
        100,
        213,
        74,
        3,
        95,
        91,
        228,
        146
      ]
    },
    {
      name: "EvtSplitPosition2",
      discriminator: [
        165,
        32,
        203,
        174,
        72,
        100,
        233,
        103
      ]
    },
    {
      name: "EvtSwap2",
      discriminator: [
        189,
        66,
        51,
        168,
        38,
        80,
        117,
        153
      ]
    },
    {
      name: "EvtUpdatePoolFees",
      discriminator: [
        76,
        165,
        246,
        102,
        102,
        217,
        156,
        44
      ]
    },
    {
      name: "EvtUpdateRewardDuration",
      discriminator: [
        149,
        135,
        65,
        231,
        129,
        153,
        65,
        57
      ]
    },
    {
      name: "EvtUpdateRewardFunder",
      discriminator: [
        76,
        154,
        208,
        13,
        40,
        115,
        246,
        146
      ]
    },
    {
      name: "EvtWithdrawIneligibleReward",
      discriminator: [
        248,
        215,
        184,
        78,
        31,
        180,
        179,
        168
      ]
    }
  ],
  errors: [
    {
      code: 6e3,
      name: "MathOverflow",
      msg: "Math operation overflow"
    },
    {
      code: 6001,
      name: "InvalidFee",
      msg: "Invalid fee setup"
    },
    {
      code: 6002,
      name: "ExceededSlippage",
      msg: "Exceeded slippage tolerance"
    },
    {
      code: 6003,
      name: "PoolDisabled",
      msg: "Pool disabled"
    },
    {
      code: 6004,
      name: "ExceedMaxFeeBps",
      msg: "Exceeded max fee bps"
    },
    {
      code: 6005,
      name: "InvalidAdmin",
      msg: "Invalid admin"
    },
    {
      code: 6006,
      name: "AmountIsZero",
      msg: "Amount is zero"
    },
    {
      code: 6007,
      name: "TypeCastFailed",
      msg: "Type cast error"
    },
    {
      code: 6008,
      name: "UnableToModifyActivationPoint",
      msg: "Unable to modify activation point"
    },
    {
      code: 6009,
      name: "InvalidAuthorityToCreateThePool",
      msg: "Invalid authority to create the pool"
    },
    {
      code: 6010,
      name: "InvalidActivationType",
      msg: "Invalid activation type"
    },
    {
      code: 6011,
      name: "InvalidActivationPoint",
      msg: "Invalid activation point"
    },
    {
      code: 6012,
      name: "InvalidQuoteMint",
      msg: "Quote token must be SOL,USDC"
    },
    {
      code: 6013,
      name: "InvalidFeeCurve",
      msg: "Invalid fee curve"
    },
    {
      code: 6014,
      name: "InvalidPriceRange",
      msg: "Invalid Price Range"
    },
    {
      code: 6015,
      name: "PriceRangeViolation",
      msg: "Trade is over price range"
    },
    {
      code: 6016,
      name: "InvalidParameters",
      msg: "Invalid parameters"
    },
    {
      code: 6017,
      name: "InvalidCollectFeeMode",
      msg: "Invalid collect fee mode"
    },
    {
      code: 6018,
      name: "InvalidInput",
      msg: "Invalid input"
    },
    {
      code: 6019,
      name: "CannotCreateTokenBadgeOnSupportedMint",
      msg: "Cannot create token badge on supported mint"
    },
    {
      code: 6020,
      name: "InvalidTokenBadge",
      msg: "Invalid token badge"
    },
    {
      code: 6021,
      name: "InvalidMinimumLiquidity",
      msg: "Invalid minimum liquidity"
    },
    {
      code: 6022,
      name: "InvalidVestingInfo",
      msg: "Invalid vesting information"
    },
    {
      code: 6023,
      name: "InsufficientLiquidity",
      msg: "Insufficient liquidity"
    },
    {
      code: 6024,
      name: "InvalidVestingAccount",
      msg: "Invalid vesting account"
    },
    {
      code: 6025,
      name: "InvalidPoolStatus",
      msg: "Invalid pool status"
    },
    {
      code: 6026,
      name: "UnsupportNativeMintToken2022",
      msg: "Unsupported native mint token2022"
    },
    {
      code: 6027,
      name: "InvalidRewardIndex",
      msg: "Invalid reward index"
    },
    {
      code: 6028,
      name: "InvalidRewardDuration",
      msg: "Invalid reward duration"
    },
    {
      code: 6029,
      name: "RewardInitialized",
      msg: "Reward already initialized"
    },
    {
      code: 6030,
      name: "RewardUninitialized",
      msg: "Reward not initialized"
    },
    {
      code: 6031,
      name: "InvalidRewardVault",
      msg: "Invalid reward vault"
    },
    {
      code: 6032,
      name: "MustWithdrawnIneligibleReward",
      msg: "Must withdraw ineligible reward"
    },
    {
      code: 6033,
      name: "IdenticalRewardDuration",
      msg: "Reward duration is the same"
    },
    {
      code: 6034,
      name: "RewardCampaignInProgress",
      msg: "Reward campaign in progress"
    },
    {
      code: 6035,
      name: "IdenticalFunder",
      msg: "Identical funder"
    },
    {
      code: 6036,
      name: "InvalidFunder",
      msg: "Invalid funder"
    },
    {
      code: 6037,
      name: "RewardNotEnded",
      msg: "Reward not ended"
    },
    {
      code: 6038,
      name: "FeeInverseIsIncorrect",
      msg: "Fee inverse is incorrect"
    },
    {
      code: 6039,
      name: "PositionIsNotEmpty",
      msg: "Position is not empty"
    },
    {
      code: 6040,
      name: "InvalidPoolCreatorAuthority",
      msg: "Invalid pool creator authority"
    },
    {
      code: 6041,
      name: "InvalidConfigType",
      msg: "Invalid config type"
    },
    {
      code: 6042,
      name: "InvalidPoolCreator",
      msg: "Invalid pool creator"
    },
    {
      code: 6043,
      name: "RewardVaultFrozenSkipRequired",
      msg: "Reward vault is frozen, must skip reward to proceed"
    },
    {
      code: 6044,
      name: "InvalidSplitPositionParameters",
      msg: "Invalid parameters for split position"
    },
    {
      code: 6045,
      name: "UnsupportPositionHasVestingLock",
      msg: "Unsupported split position has vesting lock"
    },
    {
      code: 6046,
      name: "SamePosition",
      msg: "Same position"
    },
    {
      code: 6047,
      name: "InvalidBaseFeeMode",
      msg: "Invalid base fee mode"
    },
    {
      code: 6048,
      name: "InvalidFeeRateLimiter",
      msg: "Invalid fee rate limiter"
    },
    {
      code: 6049,
      name: "FailToValidateSingleSwapInstruction",
      msg: "Fail to validate single swap instruction in rate limiter"
    },
    {
      code: 6050,
      name: "InvalidFeeTimeScheduler",
      msg: "Invalid fee scheduler"
    },
    {
      code: 6051,
      name: "UndeterminedError",
      msg: "Undetermined error"
    },
    {
      code: 6052,
      name: "InvalidPoolVersion",
      msg: "Invalid pool version"
    },
    {
      code: 6053,
      name: "InvalidAuthority",
      msg: "Invalid authority to do that action"
    },
    {
      code: 6054,
      name: "InvalidPermission",
      msg: "Invalid permission"
    },
    {
      code: 6055,
      name: "InvalidFeeMarketCapScheduler",
      msg: "Invalid fee market cap scheduler"
    },
    {
      code: 6056,
      name: "CannotUpdateBaseFee",
      msg: "Cannot update base fee"
    },
    {
      code: 6057,
      name: "InvalidDynamicFeeParameters",
      msg: "Invalid dynamic fee parameters"
    },
    {
      code: 6058,
      name: "InvalidUpdatePoolFeesParameters",
      msg: "Invalid update pool fees parameters"
    },
    {
      code: 6059,
      name: "MissingOperatorAccount",
      msg: "Missing operator account"
    },
    {
      code: 6060,
      name: "IncorrectATA",
      msg: "Incorrect ATA"
    },
    {
      code: 6061,
      name: "InvalidZapOutParameters",
      msg: "Invalid zap out parameters"
    },
    {
      code: 6062,
      name: "InvalidWithdrawProtocolFeeZapAccounts",
      msg: "Invalid withdraw protocol fee zap accounts"
    },
    {
      code: 6063,
      name: "MintRestrictedFromZap",
      msg: "SOL,USDC protocol fee cannot be withdrawn via zap"
    },
    {
      code: 6064,
      name: "CpiDisabled",
      msg: "CPI disabled"
    },
    {
      code: 6065,
      name: "MissingZapOutInstruction",
      msg: "Missing zap out instruction"
    },
    {
      code: 6066,
      name: "InvalidZapAccounts",
      msg: "Invalid zap accounts"
    }
  ],
  types: [
    {
      name: "AddLiquidityParameters",
      type: {
        kind: "struct",
        fields: [
          {
            name: "liquidity_delta",
            docs: [
              "delta liquidity"
            ],
            type: "u128"
          },
          {
            name: "token_a_amount_threshold",
            docs: [
              "maximum token a amount"
            ],
            type: "u64"
          },
          {
            name: "token_b_amount_threshold",
            docs: [
              "maximum token b amount"
            ],
            type: "u64"
          }
        ]
      }
    },
    {
      name: "BaseFeeInfo",
      serialization: "bytemuck",
      repr: {
        kind: "c"
      },
      type: {
        kind: "struct",
        fields: [
          {
            name: "data",
            type: {
              array: [
                "u8",
                32
              ]
            }
          }
        ]
      }
    },
    {
      name: "BaseFeeParameters",
      type: {
        kind: "struct",
        fields: [
          {
            name: "data",
            type: {
              array: [
                "u8",
                30
              ]
            }
          }
        ]
      }
    },
    {
      name: "BaseFeeStruct",
      serialization: "bytemuck",
      repr: {
        kind: "c"
      },
      type: {
        kind: "struct",
        fields: [
          {
            name: "base_fee_info",
            type: {
              defined: {
                name: "BaseFeeInfo"
              }
            }
          },
          {
            name: "padding_1",
            type: "u64"
          }
        ]
      }
    },
    {
      name: "BorshFeeMarketCapScheduler",
      type: {
        kind: "struct",
        fields: [
          {
            name: "cliff_fee_numerator",
            type: "u64"
          },
          {
            name: "number_of_period",
            type: "u16"
          },
          {
            name: "sqrt_price_step_bps",
            type: "u32"
          },
          {
            name: "scheduler_expiration_duration",
            type: "u32"
          },
          {
            name: "reduction_factor",
            type: "u64"
          },
          {
            name: "base_fee_mode",
            type: "u8"
          },
          {
            name: "padding",
            type: {
              array: [
                "u8",
                3
              ]
            }
          }
        ]
      }
    },
    {
      name: "BorshFeeRateLimiter",
      docs: [
        "we denote reference_amount = x0, cliff_fee_numerator = c, fee_increment = i",
        "if input_amount <= x0, then fee = input_amount * c",
        "",
        "if input_amount > x0, then input_amount = x0 + (a * x0 + b)",
        "if a < max_index",
        "then fee = x0 * c + x0 * (c + i) + .... + x0 * (c + i*a) + b * (c + i * (a+1))",
        "then fee = x0 * (c + c*a + i*a*(a+1)/2) + b * (c + i * (a+1))",
        "",
        "if a >= max_index",
        "if a = max_index + d, input_amount = x0 + max_index * x0 + (d * x0 + b)",
        "then fee = x0 * (c + c*max_index + i*max_index*(max_index+1)/2) + (d * x0 + b) * MAX_FEE"
      ],
      type: {
        kind: "struct",
        fields: [
          {
            name: "cliff_fee_numerator",
            type: "u64"
          },
          {
            name: "fee_increment_bps",
            type: "u16"
          },
          {
            name: "max_limiter_duration",
            type: "u32"
          },
          {
            name: "max_fee_bps",
            type: "u32"
          },
          {
            name: "reference_amount",
            type: "u64"
          },
          {
            name: "base_fee_mode",
            type: "u8"
          },
          {
            name: "padding",
            type: {
              array: [
                "u8",
                3
              ]
            }
          }
        ]
      }
    },
    {
      name: "BorshFeeTimeScheduler",
      type: {
        kind: "struct",
        fields: [
          {
            name: "cliff_fee_numerator",
            type: "u64"
          },
          {
            name: "number_of_period",
            type: "u16"
          },
          {
            name: "period_frequency",
            type: "u64"
          },
          {
            name: "reduction_factor",
            type: "u64"
          },
          {
            name: "base_fee_mode",
            type: "u8"
          },
          {
            name: "padding",
            type: {
              array: [
                "u8",
                3
              ]
            }
          }
        ]
      }
    },
    {
      name: "Config",
      serialization: "bytemuck",
      repr: {
        kind: "c"
      },
      type: {
        kind: "struct",
        fields: [
          {
            name: "vault_config_key",
            docs: [
              "Vault config key"
            ],
            type: "pubkey"
          },
          {
            name: "pool_creator_authority",
            docs: [
              "Only pool_creator_authority can use the current config to initialize new pool. When it's Pubkey::default, it's a public config."
            ],
            type: "pubkey"
          },
          {
            name: "pool_fees",
            docs: [
              "Pool fee"
            ],
            type: {
              defined: {
                name: "PoolFeesConfig"
              }
            }
          },
          {
            name: "activation_type",
            docs: [
              "Activation type"
            ],
            type: "u8"
          },
          {
            name: "collect_fee_mode",
            docs: [
              "Collect fee mode"
            ],
            type: "u8"
          },
          {
            name: "config_type",
            docs: [
              "Config type mode, 0 for static, 1 for dynamic"
            ],
            type: "u8"
          },
          {
            name: "_padding_0",
            docs: [
              "padding 0"
            ],
            type: {
              array: [
                "u8",
                5
              ]
            }
          },
          {
            name: "index",
            docs: [
              "config index"
            ],
            type: "u64"
          },
          {
            name: "sqrt_min_price",
            docs: [
              "sqrt min price"
            ],
            type: "u128"
          },
          {
            name: "sqrt_max_price",
            docs: [
              "sqrt max price"
            ],
            type: "u128"
          },
          {
            name: "_padding_1",
            docs: [
              "Fee curve point",
              "Padding for further use"
            ],
            type: {
              array: [
                "u64",
                10
              ]
            }
          }
        ]
      }
    },
    {
      name: "DummyParams",
      type: {
        kind: "struct",
        fields: [
          {
            name: "borsh_fee_time_scheduler_params",
            type: {
              defined: {
                name: "BorshFeeTimeScheduler"
              }
            }
          },
          {
            name: "borsh_fee_rate_limiter_params",
            type: {
              defined: {
                name: "BorshFeeRateLimiter"
              }
            }
          },
          {
            name: "borsh_fee_market_cap_scheduler_params",
            type: {
              defined: {
                name: "BorshFeeMarketCapScheduler"
              }
            }
          }
        ]
      }
    },
    {
      name: "DynamicConfigParameters",
      type: {
        kind: "struct",
        fields: [
          {
            name: "pool_creator_authority",
            type: "pubkey"
          }
        ]
      }
    },
    {
      name: "DynamicFeeConfig",
      serialization: "bytemuck",
      repr: {
        kind: "c"
      },
      type: {
        kind: "struct",
        fields: [
          {
            name: "initialized",
            type: "u8"
          },
          {
            name: "padding",
            type: {
              array: [
                "u8",
                7
              ]
            }
          },
          {
            name: "max_volatility_accumulator",
            type: "u32"
          },
          {
            name: "variable_fee_control",
            type: "u32"
          },
          {
            name: "bin_step",
            type: "u16"
          },
          {
            name: "filter_period",
            type: "u16"
          },
          {
            name: "decay_period",
            type: "u16"
          },
          {
            name: "reduction_factor",
            type: "u16"
          },
          {
            name: "padding_1",
            type: {
              array: [
                "u8",
                8
              ]
            }
          },
          {
            name: "bin_step_u128",
            type: "u128"
          }
        ]
      }
    },
    {
      name: "DynamicFeeParameters",
      type: {
        kind: "struct",
        fields: [
          {
            name: "bin_step",
            type: "u16"
          },
          {
            name: "bin_step_u128",
            type: "u128"
          },
          {
            name: "filter_period",
            type: "u16"
          },
          {
            name: "decay_period",
            type: "u16"
          },
          {
            name: "reduction_factor",
            type: "u16"
          },
          {
            name: "max_volatility_accumulator",
            type: "u32"
          },
          {
            name: "variable_fee_control",
            type: "u32"
          }
        ]
      }
    },
    {
      name: "DynamicFeeStruct",
      serialization: "bytemuck",
      repr: {
        kind: "c"
      },
      type: {
        kind: "struct",
        fields: [
          {
            name: "initialized",
            type: "u8"
          },
          {
            name: "padding",
            type: {
              array: [
                "u8",
                7
              ]
            }
          },
          {
            name: "max_volatility_accumulator",
            type: "u32"
          },
          {
            name: "variable_fee_control",
            type: "u32"
          },
          {
            name: "bin_step",
            type: "u16"
          },
          {
            name: "filter_period",
            type: "u16"
          },
          {
            name: "decay_period",
            type: "u16"
          },
          {
            name: "reduction_factor",
            type: "u16"
          },
          {
            name: "last_update_timestamp",
            type: "u64"
          },
          {
            name: "bin_step_u128",
            type: "u128"
          },
          {
            name: "sqrt_price_reference",
            type: "u128"
          },
          {
            name: "volatility_accumulator",
            type: "u128"
          },
          {
            name: "volatility_reference",
            type: "u128"
          }
        ]
      }
    },
    {
      name: "EvtClaimPartnerFee",
      type: {
        kind: "struct",
        fields: [
          {
            name: "pool",
            type: "pubkey"
          },
          {
            name: "token_a_amount",
            type: "u64"
          },
          {
            name: "token_b_amount",
            type: "u64"
          }
        ]
      }
    },
    {
      name: "EvtClaimPositionFee",
      type: {
        kind: "struct",
        fields: [
          {
            name: "pool",
            type: "pubkey"
          },
          {
            name: "position",
            type: "pubkey"
          },
          {
            name: "owner",
            type: "pubkey"
          },
          {
            name: "fee_a_claimed",
            type: "u64"
          },
          {
            name: "fee_b_claimed",
            type: "u64"
          }
        ]
      }
    },
    {
      name: "EvtClaimProtocolFee",
      type: {
        kind: "struct",
        fields: [
          {
            name: "pool",
            type: "pubkey"
          },
          {
            name: "token_a_amount",
            type: "u64"
          },
          {
            name: "token_b_amount",
            type: "u64"
          }
        ]
      }
    },
    {
      name: "EvtClaimReward",
      type: {
        kind: "struct",
        fields: [
          {
            name: "pool",
            type: "pubkey"
          },
          {
            name: "position",
            type: "pubkey"
          },
          {
            name: "owner",
            type: "pubkey"
          },
          {
            name: "mint_reward",
            type: "pubkey"
          },
          {
            name: "reward_index",
            type: "u8"
          },
          {
            name: "total_reward",
            type: "u64"
          }
        ]
      }
    },
    {
      name: "EvtCloseConfig",
      docs: [
        "Close config"
      ],
      type: {
        kind: "struct",
        fields: [
          {
            name: "config",
            docs: [
              "Config pubkey"
            ],
            type: "pubkey"
          },
          {
            name: "admin",
            docs: [
              "admin pk"
            ],
            type: "pubkey"
          }
        ]
      }
    },
    {
      name: "EvtClosePosition",
      type: {
        kind: "struct",
        fields: [
          {
            name: "pool",
            type: "pubkey"
          },
          {
            name: "owner",
            type: "pubkey"
          },
          {
            name: "position",
            type: "pubkey"
          },
          {
            name: "position_nft_mint",
            type: "pubkey"
          }
        ]
      }
    },
    {
      name: "EvtCreateConfig",
      docs: [
        "Create static config"
      ],
      type: {
        kind: "struct",
        fields: [
          {
            name: "pool_fees",
            type: {
              defined: {
                name: "PoolFeeParameters"
              }
            }
          },
          {
            name: "vault_config_key",
            type: "pubkey"
          },
          {
            name: "pool_creator_authority",
            type: "pubkey"
          },
          {
            name: "activation_type",
            type: "u8"
          },
          {
            name: "sqrt_min_price",
            type: "u128"
          },
          {
            name: "sqrt_max_price",
            type: "u128"
          },
          {
            name: "collect_fee_mode",
            type: "u8"
          },
          {
            name: "index",
            type: "u64"
          },
          {
            name: "config",
            type: "pubkey"
          }
        ]
      }
    },
    {
      name: "EvtCreateDynamicConfig",
      docs: [
        "Create dynamic config"
      ],
      type: {
        kind: "struct",
        fields: [
          {
            name: "config",
            type: "pubkey"
          },
          {
            name: "pool_creator_authority",
            type: "pubkey"
          },
          {
            name: "index",
            type: "u64"
          }
        ]
      }
    },
    {
      name: "EvtCreatePosition",
      type: {
        kind: "struct",
        fields: [
          {
            name: "pool",
            type: "pubkey"
          },
          {
            name: "owner",
            type: "pubkey"
          },
          {
            name: "position",
            type: "pubkey"
          },
          {
            name: "position_nft_mint",
            type: "pubkey"
          }
        ]
      }
    },
    {
      name: "EvtCreateTokenBadge",
      docs: [
        "Create token badge"
      ],
      type: {
        kind: "struct",
        fields: [
          {
            name: "token_mint",
            type: "pubkey"
          }
        ]
      }
    },
    {
      name: "EvtFundReward",
      type: {
        kind: "struct",
        fields: [
          {
            name: "pool",
            type: "pubkey"
          },
          {
            name: "funder",
            type: "pubkey"
          },
          {
            name: "mint_reward",
            type: "pubkey"
          },
          {
            name: "reward_index",
            type: "u8"
          },
          {
            name: "amount",
            type: "u64"
          },
          {
            name: "transfer_fee_excluded_amount_in",
            type: "u64"
          },
          {
            name: "reward_duration_end",
            type: "u64"
          },
          {
            name: "pre_reward_rate",
            type: "u128"
          },
          {
            name: "post_reward_rate",
            type: "u128"
          }
        ]
      }
    },
    {
      name: "EvtInitializePool",
      type: {
        kind: "struct",
        fields: [
          {
            name: "pool",
            type: "pubkey"
          },
          {
            name: "token_a_mint",
            type: "pubkey"
          },
          {
            name: "token_b_mint",
            type: "pubkey"
          },
          {
            name: "creator",
            type: "pubkey"
          },
          {
            name: "payer",
            type: "pubkey"
          },
          {
            name: "alpha_vault",
            type: "pubkey"
          },
          {
            name: "pool_fees",
            type: {
              defined: {
                name: "PoolFeeParameters"
              }
            }
          },
          {
            name: "sqrt_min_price",
            type: "u128"
          },
          {
            name: "sqrt_max_price",
            type: "u128"
          },
          {
            name: "activation_type",
            type: "u8"
          },
          {
            name: "collect_fee_mode",
            type: "u8"
          },
          {
            name: "liquidity",
            type: "u128"
          },
          {
            name: "sqrt_price",
            type: "u128"
          },
          {
            name: "activation_point",
            type: "u64"
          },
          {
            name: "token_a_flag",
            type: "u8"
          },
          {
            name: "token_b_flag",
            type: "u8"
          },
          {
            name: "token_a_amount",
            type: "u64"
          },
          {
            name: "token_b_amount",
            type: "u64"
          },
          {
            name: "total_amount_a",
            type: "u64"
          },
          {
            name: "total_amount_b",
            type: "u64"
          },
          {
            name: "pool_type",
            type: "u8"
          }
        ]
      }
    },
    {
      name: "EvtInitializeReward",
      type: {
        kind: "struct",
        fields: [
          {
            name: "pool",
            type: "pubkey"
          },
          {
            name: "reward_mint",
            type: "pubkey"
          },
          {
            name: "funder",
            type: "pubkey"
          },
          {
            name: "creator",
            type: "pubkey"
          },
          {
            name: "reward_index",
            type: "u8"
          },
          {
            name: "reward_duration",
            type: "u64"
          }
        ]
      }
    },
    {
      name: "EvtLiquidityChange",
      type: {
        kind: "struct",
        fields: [
          {
            name: "pool",
            type: "pubkey"
          },
          {
            name: "position",
            type: "pubkey"
          },
          {
            name: "owner",
            type: "pubkey"
          },
          {
            name: "token_a_amount",
            type: "u64"
          },
          {
            name: "token_b_amount",
            type: "u64"
          },
          {
            name: "transfer_fee_included_token_a_amount",
            type: "u64"
          },
          {
            name: "transfer_fee_included_token_b_amount",
            type: "u64"
          },
          {
            name: "reserve_a_amount",
            type: "u64"
          },
          {
            name: "reserve_b_amount",
            type: "u64"
          },
          {
            name: "liquidity_delta",
            type: "u128"
          },
          {
            name: "token_a_amount_threshold",
            type: "u64"
          },
          {
            name: "token_b_amount_threshold",
            type: "u64"
          },
          {
            name: "change_type",
            type: "u8"
          }
        ]
      }
    },
    {
      name: "EvtLockPosition",
      type: {
        kind: "struct",
        fields: [
          {
            name: "pool",
            type: "pubkey"
          },
          {
            name: "position",
            type: "pubkey"
          },
          {
            name: "owner",
            type: "pubkey"
          },
          {
            name: "vesting",
            type: "pubkey"
          },
          {
            name: "cliff_point",
            type: "u64"
          },
          {
            name: "period_frequency",
            type: "u64"
          },
          {
            name: "cliff_unlock_liquidity",
            type: "u128"
          },
          {
            name: "liquidity_per_period",
            type: "u128"
          },
          {
            name: "number_of_period",
            type: "u16"
          }
        ]
      }
    },
    {
      name: "EvtPermanentLockPosition",
      type: {
        kind: "struct",
        fields: [
          {
            name: "pool",
            type: "pubkey"
          },
          {
            name: "position",
            type: "pubkey"
          },
          {
            name: "lock_liquidity_amount",
            type: "u128"
          },
          {
            name: "total_permanent_locked_liquidity",
            type: "u128"
          }
        ]
      }
    },
    {
      name: "EvtSetPoolStatus",
      type: {
        kind: "struct",
        fields: [
          {
            name: "pool",
            type: "pubkey"
          },
          {
            name: "status",
            type: "u8"
          }
        ]
      }
    },
    {
      name: "EvtSplitPosition2",
      type: {
        kind: "struct",
        fields: [
          {
            name: "pool",
            type: "pubkey"
          },
          {
            name: "first_owner",
            type: "pubkey"
          },
          {
            name: "second_owner",
            type: "pubkey"
          },
          {
            name: "first_position",
            type: "pubkey"
          },
          {
            name: "second_position",
            type: "pubkey"
          },
          {
            name: "current_sqrt_price",
            type: "u128"
          },
          {
            name: "amount_splits",
            type: {
              defined: {
                name: "SplitAmountInfo"
              }
            }
          },
          {
            name: "first_position_info",
            type: {
              defined: {
                name: "SplitPositionInfo"
              }
            }
          },
          {
            name: "second_position_info",
            type: {
              defined: {
                name: "SplitPositionInfo"
              }
            }
          },
          {
            name: "split_position_parameters",
            type: {
              defined: {
                name: "SplitPositionParameters2"
              }
            }
          }
        ]
      }
    },
    {
      name: "EvtSwap2",
      type: {
        kind: "struct",
        fields: [
          {
            name: "pool",
            type: "pubkey"
          },
          {
            name: "trade_direction",
            type: "u8"
          },
          {
            name: "collect_fee_mode",
            type: "u8"
          },
          {
            name: "has_referral",
            type: "bool"
          },
          {
            name: "params",
            type: {
              defined: {
                name: "SwapParameters2"
              }
            }
          },
          {
            name: "swap_result",
            type: {
              defined: {
                name: "SwapResult2"
              }
            }
          },
          {
            name: "included_transfer_fee_amount_in",
            type: "u64"
          },
          {
            name: "included_transfer_fee_amount_out",
            type: "u64"
          },
          {
            name: "excluded_transfer_fee_amount_out",
            type: "u64"
          },
          {
            name: "current_timestamp",
            type: "u64"
          },
          {
            name: "reserve_a_amount",
            type: "u64"
          },
          {
            name: "reserve_b_amount",
            type: "u64"
          }
        ]
      }
    },
    {
      name: "EvtUpdatePoolFees",
      type: {
        kind: "struct",
        fields: [
          {
            name: "pool",
            type: "pubkey"
          },
          {
            name: "operator",
            type: "pubkey"
          },
          {
            name: "params",
            type: {
              defined: {
                name: "UpdatePoolFeesParameters"
              }
            }
          }
        ]
      }
    },
    {
      name: "EvtUpdateRewardDuration",
      type: {
        kind: "struct",
        fields: [
          {
            name: "pool",
            type: "pubkey"
          },
          {
            name: "reward_index",
            type: "u8"
          },
          {
            name: "old_reward_duration",
            type: "u64"
          },
          {
            name: "new_reward_duration",
            type: "u64"
          }
        ]
      }
    },
    {
      name: "EvtUpdateRewardFunder",
      type: {
        kind: "struct",
        fields: [
          {
            name: "pool",
            type: "pubkey"
          },
          {
            name: "reward_index",
            type: "u8"
          },
          {
            name: "old_funder",
            type: "pubkey"
          },
          {
            name: "new_funder",
            type: "pubkey"
          }
        ]
      }
    },
    {
      name: "EvtWithdrawIneligibleReward",
      type: {
        kind: "struct",
        fields: [
          {
            name: "pool",
            type: "pubkey"
          },
          {
            name: "reward_mint",
            type: "pubkey"
          },
          {
            name: "amount",
            type: "u64"
          }
        ]
      }
    },
    {
      name: "InitializeCustomizablePoolParameters",
      type: {
        kind: "struct",
        fields: [
          {
            name: "pool_fees",
            docs: [
              "pool fees"
            ],
            type: {
              defined: {
                name: "PoolFeeParameters"
              }
            }
          },
          {
            name: "sqrt_min_price",
            docs: [
              "sqrt min price"
            ],
            type: "u128"
          },
          {
            name: "sqrt_max_price",
            docs: [
              "sqrt max price"
            ],
            type: "u128"
          },
          {
            name: "has_alpha_vault",
            docs: [
              "has alpha vault"
            ],
            type: "bool"
          },
          {
            name: "liquidity",
            docs: [
              "initialize liquidity"
            ],
            type: "u128"
          },
          {
            name: "sqrt_price",
            docs: [
              "The init price of the pool as a sqrt(token_b/token_a) Q64.64 value. Market cap fee scheduler minimum price will be derived from this value"
            ],
            type: "u128"
          },
          {
            name: "activation_type",
            docs: [
              "activation type"
            ],
            type: "u8"
          },
          {
            name: "collect_fee_mode",
            docs: [
              "collect fee mode"
            ],
            type: "u8"
          },
          {
            name: "activation_point",
            docs: [
              "activation point"
            ],
            type: {
              option: "u64"
            }
          }
        ]
      }
    },
    {
      name: "InitializePoolParameters",
      type: {
        kind: "struct",
        fields: [
          {
            name: "liquidity",
            docs: [
              "initialize liquidity"
            ],
            type: "u128"
          },
          {
            name: "sqrt_price",
            docs: [
              "The init price of the pool as a sqrt(token_b/token_a) Q64.64 value"
            ],
            type: "u128"
          },
          {
            name: "activation_point",
            docs: [
              "activation point"
            ],
            type: {
              option: "u64"
            }
          }
        ]
      }
    },
    {
      name: "Operator",
      serialization: "bytemuck",
      repr: {
        kind: "c"
      },
      type: {
        kind: "struct",
        fields: [
          {
            name: "whitelisted_address",
            type: "pubkey"
          },
          {
            name: "permission",
            type: "u128"
          },
          {
            name: "padding",
            type: {
              array: [
                "u64",
                2
              ]
            }
          }
        ]
      }
    },
    {
      name: "PodAlignedFeeMarketCapScheduler",
      serialization: "bytemuck",
      repr: {
        kind: "c"
      },
      type: {
        kind: "struct",
        fields: [
          {
            name: "cliff_fee_numerator",
            type: "u64"
          },
          {
            name: "base_fee_mode",
            type: "u8"
          },
          {
            name: "padding",
            type: {
              array: [
                "u8",
                5
              ]
            }
          },
          {
            name: "number_of_period",
            type: "u16"
          },
          {
            name: "sqrt_price_step_bps",
            type: "u32"
          },
          {
            name: "scheduler_expiration_duration",
            type: "u32"
          },
          {
            name: "reduction_factor",
            type: "u64"
          }
        ]
      }
    },
    {
      name: "PodAlignedFeeRateLimiter",
      serialization: "bytemuck",
      repr: {
        kind: "c"
      },
      type: {
        kind: "struct",
        fields: [
          {
            name: "cliff_fee_numerator",
            type: "u64"
          },
          {
            name: "base_fee_mode",
            type: "u8"
          },
          {
            name: "padding",
            type: {
              array: [
                "u8",
                5
              ]
            }
          },
          {
            name: "fee_increment_bps",
            type: "u16"
          },
          {
            name: "max_limiter_duration",
            type: "u32"
          },
          {
            name: "max_fee_bps",
            type: "u32"
          },
          {
            name: "reference_amount",
            type: "u64"
          }
        ]
      }
    },
    {
      name: "PodAlignedFeeTimeScheduler",
      serialization: "bytemuck",
      repr: {
        kind: "c"
      },
      type: {
        kind: "struct",
        fields: [
          {
            name: "cliff_fee_numerator",
            type: "u64"
          },
          {
            name: "base_fee_mode",
            type: "u8"
          },
          {
            name: "padding",
            type: {
              array: [
                "u8",
                5
              ]
            }
          },
          {
            name: "number_of_period",
            type: "u16"
          },
          {
            name: "period_frequency",
            type: "u64"
          },
          {
            name: "reduction_factor",
            type: "u64"
          }
        ]
      }
    },
    {
      name: "Pool",
      serialization: "bytemuck",
      repr: {
        kind: "c"
      },
      type: {
        kind: "struct",
        fields: [
          {
            name: "pool_fees",
            docs: [
              "Pool fee"
            ],
            type: {
              defined: {
                name: "PoolFeesStruct"
              }
            }
          },
          {
            name: "token_a_mint",
            docs: [
              "token a mint"
            ],
            type: "pubkey"
          },
          {
            name: "token_b_mint",
            docs: [
              "token b mint"
            ],
            type: "pubkey"
          },
          {
            name: "token_a_vault",
            docs: [
              "token a vault"
            ],
            type: "pubkey"
          },
          {
            name: "token_b_vault",
            docs: [
              "token b vault"
            ],
            type: "pubkey"
          },
          {
            name: "whitelisted_vault",
            docs: [
              "Whitelisted vault to be able to buy pool before activation_point"
            ],
            type: "pubkey"
          },
          {
            name: "partner",
            docs: [
              "partner"
            ],
            type: "pubkey"
          },
          {
            name: "liquidity",
            docs: [
              "liquidity share"
            ],
            type: "u128"
          },
          {
            name: "_padding",
            docs: [
              "padding, previous reserve amount, be careful to use that field"
            ],
            type: "u128"
          },
          {
            name: "protocol_a_fee",
            docs: [
              "protocol a fee"
            ],
            type: "u64"
          },
          {
            name: "protocol_b_fee",
            docs: [
              "protocol b fee"
            ],
            type: "u64"
          },
          {
            name: "partner_a_fee",
            docs: [
              "partner a fee"
            ],
            type: "u64"
          },
          {
            name: "partner_b_fee",
            docs: [
              "partner b fee"
            ],
            type: "u64"
          },
          {
            name: "sqrt_min_price",
            docs: [
              "min price"
            ],
            type: "u128"
          },
          {
            name: "sqrt_max_price",
            docs: [
              "max price"
            ],
            type: "u128"
          },
          {
            name: "sqrt_price",
            docs: [
              "current price"
            ],
            type: "u128"
          },
          {
            name: "activation_point",
            docs: [
              "Activation point, can be slot or timestamp"
            ],
            type: "u64"
          },
          {
            name: "activation_type",
            docs: [
              "Activation type, 0 means by slot, 1 means by timestamp"
            ],
            type: "u8"
          },
          {
            name: "pool_status",
            docs: [
              "pool status, 0: enable, 1 disable"
            ],
            type: "u8"
          },
          {
            name: "token_a_flag",
            docs: [
              "token a flag"
            ],
            type: "u8"
          },
          {
            name: "token_b_flag",
            docs: [
              "token b flag"
            ],
            type: "u8"
          },
          {
            name: "collect_fee_mode",
            docs: [
              "0 is collect fee in both token, 1 only collect fee only in token b"
            ],
            type: "u8"
          },
          {
            name: "pool_type",
            docs: [
              "pool type"
            ],
            type: "u8"
          },
          {
            name: "version",
            docs: [
              "pool version, 0: max_fee is still capped at 50%, 1: max_fee is capped at 99%"
            ],
            type: "u8"
          },
          {
            name: "_padding_0",
            docs: [
              "padding"
            ],
            type: "u8"
          },
          {
            name: "fee_a_per_liquidity",
            docs: [
              "cumulative"
            ],
            type: {
              array: [
                "u8",
                32
              ]
            }
          },
          {
            name: "fee_b_per_liquidity",
            docs: [
              "cumulative"
            ],
            type: {
              array: [
                "u8",
                32
              ]
            }
          },
          {
            name: "permanent_lock_liquidity",
            type: "u128"
          },
          {
            name: "metrics",
            docs: [
              "metrics"
            ],
            type: {
              defined: {
                name: "PoolMetrics"
              }
            }
          },
          {
            name: "creator",
            docs: [
              "pool creator"
            ],
            type: "pubkey"
          },
          {
            name: "_padding_1",
            docs: [
              "Padding for further use"
            ],
            type: {
              array: [
                "u64",
                6
              ]
            }
          },
          {
            name: "reward_infos",
            docs: [
              "Farming reward information"
            ],
            type: {
              array: [
                {
                  defined: {
                    name: "RewardInfo"
                  }
                },
                2
              ]
            }
          }
        ]
      }
    },
    {
      name: "PoolFeeParameters",
      docs: [
        "Information regarding fee charges"
      ],
      type: {
        kind: "struct",
        fields: [
          {
            name: "base_fee",
            docs: [
              "Base fee"
            ],
            type: {
              defined: {
                name: "BaseFeeParameters"
              }
            }
          },
          {
            name: "dynamic_fee",
            docs: [
              "dynamic fee"
            ],
            type: {
              option: {
                defined: {
                  name: "DynamicFeeParameters"
                }
              }
            }
          }
        ]
      }
    },
    {
      name: "PoolFeesConfig",
      serialization: "bytemuck",
      repr: {
        kind: "c"
      },
      type: {
        kind: "struct",
        fields: [
          {
            name: "base_fee",
            type: {
              defined: {
                name: "BaseFeeInfo"
              }
            }
          },
          {
            name: "dynamic_fee",
            type: {
              defined: {
                name: "DynamicFeeConfig"
              }
            }
          },
          {
            name: "protocol_fee_percent",
            type: "u8"
          },
          {
            name: "partner_fee_percent",
            type: "u8"
          },
          {
            name: "referral_fee_percent",
            type: "u8"
          },
          {
            name: "padding_0",
            type: {
              array: [
                "u8",
                5
              ]
            }
          },
          {
            name: "padding_1",
            type: {
              array: [
                "u64",
                5
              ]
            }
          }
        ]
      }
    },
    {
      name: "PoolFeesStruct",
      docs: [
        "Information regarding fee charges",
        "trading_fee = amount * trade_fee_numerator / denominator",
        "protocol_fee = trading_fee * protocol_fee_percentage / 100",
        "referral_fee = protocol_fee * referral_percentage / 100",
        "partner_fee = (protocol_fee - referral_fee) * partner_fee_percentage / denominator"
      ],
      serialization: "bytemuck",
      repr: {
        kind: "c"
      },
      type: {
        kind: "struct",
        fields: [
          {
            name: "base_fee",
            docs: [
              "Trade fees are extra token amounts that are held inside the token",
              "accounts during a trade, making the value of liquidity tokens rise.",
              "Trade fee numerator"
            ],
            type: {
              defined: {
                name: "BaseFeeStruct"
              }
            }
          },
          {
            name: "protocol_fee_percent",
            docs: [
              "Protocol trading fees are extra token amounts that are held inside the token",
              "accounts during a trade, with the equivalent in pool tokens minted to",
              "the protocol of the program.",
              "Protocol trade fee numerator"
            ],
            type: "u8"
          },
          {
            name: "partner_fee_percent",
            docs: [
              "partner fee"
            ],
            type: "u8"
          },
          {
            name: "referral_fee_percent",
            docs: [
              "referral fee"
            ],
            type: "u8"
          },
          {
            name: "padding_0",
            docs: [
              "padding"
            ],
            type: {
              array: [
                "u8",
                5
              ]
            }
          },
          {
            name: "dynamic_fee",
            docs: [
              "dynamic fee"
            ],
            type: {
              defined: {
                name: "DynamicFeeStruct"
              }
            }
          },
          {
            name: "init_sqrt_price",
            type: "u128"
          }
        ]
      }
    },
    {
      name: "PoolMetrics",
      serialization: "bytemuck",
      repr: {
        kind: "c"
      },
      type: {
        kind: "struct",
        fields: [
          {
            name: "total_lp_a_fee",
            type: "u128"
          },
          {
            name: "total_lp_b_fee",
            type: "u128"
          },
          {
            name: "total_protocol_a_fee",
            type: "u64"
          },
          {
            name: "total_protocol_b_fee",
            type: "u64"
          },
          {
            name: "total_partner_a_fee",
            type: "u64"
          },
          {
            name: "total_partner_b_fee",
            type: "u64"
          },
          {
            name: "total_position",
            type: "u64"
          },
          {
            name: "padding",
            type: "u64"
          }
        ]
      }
    },
    {
      name: "Position",
      serialization: "bytemuck",
      repr: {
        kind: "c"
      },
      type: {
        kind: "struct",
        fields: [
          {
            name: "pool",
            type: "pubkey"
          },
          {
            name: "nft_mint",
            docs: [
              "nft mint"
            ],
            type: "pubkey"
          },
          {
            name: "fee_a_per_token_checkpoint",
            docs: [
              "fee a checkpoint"
            ],
            type: {
              array: [
                "u8",
                32
              ]
            }
          },
          {
            name: "fee_b_per_token_checkpoint",
            docs: [
              "fee b checkpoint"
            ],
            type: {
              array: [
                "u8",
                32
              ]
            }
          },
          {
            name: "fee_a_pending",
            docs: [
              "fee a pending"
            ],
            type: "u64"
          },
          {
            name: "fee_b_pending",
            docs: [
              "fee b pending"
            ],
            type: "u64"
          },
          {
            name: "unlocked_liquidity",
            docs: [
              "unlock liquidity"
            ],
            type: "u128"
          },
          {
            name: "vested_liquidity",
            docs: [
              "vesting liquidity"
            ],
            type: "u128"
          },
          {
            name: "permanent_locked_liquidity",
            docs: [
              "permanent locked liquidity"
            ],
            type: "u128"
          },
          {
            name: "metrics",
            docs: [
              "metrics"
            ],
            type: {
              defined: {
                name: "PositionMetrics"
              }
            }
          },
          {
            name: "reward_infos",
            docs: [
              "Farming reward information"
            ],
            type: {
              array: [
                {
                  defined: {
                    name: "UserRewardInfo"
                  }
                },
                2
              ]
            }
          },
          {
            name: "padding",
            docs: [
              "padding for future usage"
            ],
            type: {
              array: [
                "u128",
                6
              ]
            }
          }
        ]
      }
    },
    {
      name: "PositionMetrics",
      serialization: "bytemuck",
      repr: {
        kind: "c"
      },
      type: {
        kind: "struct",
        fields: [
          {
            name: "total_claimed_a_fee",
            type: "u64"
          },
          {
            name: "total_claimed_b_fee",
            type: "u64"
          }
        ]
      }
    },
    {
      name: "RemoveLiquidityParameters",
      type: {
        kind: "struct",
        fields: [
          {
            name: "liquidity_delta",
            docs: [
              "delta liquidity"
            ],
            type: "u128"
          },
          {
            name: "token_a_amount_threshold",
            docs: [
              "minimum token a amount"
            ],
            type: "u64"
          },
          {
            name: "token_b_amount_threshold",
            docs: [
              "minimum token b amount"
            ],
            type: "u64"
          }
        ]
      }
    },
    {
      name: "RewardInfo",
      docs: [
        "Stores the state relevant for tracking liquidity mining rewards"
      ],
      serialization: "bytemuck",
      repr: {
        kind: "c"
      },
      type: {
        kind: "struct",
        fields: [
          {
            name: "initialized",
            docs: [
              "Indicates if the reward has been initialized"
            ],
            type: "u8"
          },
          {
            name: "reward_token_flag",
            docs: [
              "reward token flag"
            ],
            type: "u8"
          },
          {
            name: "_padding_0",
            docs: [
              "padding"
            ],
            type: {
              array: [
                "u8",
                6
              ]
            }
          },
          {
            name: "_padding_1",
            docs: [
              "Padding to ensure `reward_rate: u128` is 16-byte aligned"
            ],
            type: {
              array: [
                "u8",
                8
              ]
            }
          },
          {
            name: "mint",
            docs: [
              "Reward token mint."
            ],
            type: "pubkey"
          },
          {
            name: "vault",
            docs: [
              "Reward vault token account."
            ],
            type: "pubkey"
          },
          {
            name: "funder",
            docs: [
              "Authority account that allows to fund rewards"
            ],
            type: "pubkey"
          },
          {
            name: "reward_duration",
            docs: [
              "reward duration"
            ],
            type: "u64"
          },
          {
            name: "reward_duration_end",
            docs: [
              "reward duration end"
            ],
            type: "u64"
          },
          {
            name: "reward_rate",
            docs: [
              "reward rate"
            ],
            type: "u128"
          },
          {
            name: "reward_per_token_stored",
            docs: [
              "Reward per token stored"
            ],
            type: {
              array: [
                "u8",
                32
              ]
            }
          },
          {
            name: "last_update_time",
            docs: [
              "The last time reward states were updated."
            ],
            type: "u64"
          },
          {
            name: "cumulative_seconds_with_empty_liquidity_reward",
            docs: [
              "Accumulated seconds when the farm distributed rewards but the bin was empty.",
              "These rewards will be carried over to the next reward time window."
            ],
            type: "u64"
          }
        ]
      }
    },
    {
      name: "SplitAmountInfo",
      type: {
        kind: "struct",
        fields: [
          {
            name: "permanent_locked_liquidity",
            type: "u128"
          },
          {
            name: "unlocked_liquidity",
            type: "u128"
          },
          {
            name: "fee_a",
            type: "u64"
          },
          {
            name: "fee_b",
            type: "u64"
          },
          {
            name: "reward_0",
            type: "u64"
          },
          {
            name: "reward_1",
            type: "u64"
          }
        ]
      }
    },
    {
      name: "SplitPositionInfo",
      type: {
        kind: "struct",
        fields: [
          {
            name: "liquidity",
            type: "u128"
          },
          {
            name: "fee_a",
            type: "u64"
          },
          {
            name: "fee_b",
            type: "u64"
          },
          {
            name: "reward_0",
            type: "u64"
          },
          {
            name: "reward_1",
            type: "u64"
          }
        ]
      }
    },
    {
      name: "SplitPositionParameters",
      type: {
        kind: "struct",
        fields: [
          {
            name: "unlocked_liquidity_percentage",
            docs: [
              "Percentage of unlocked liquidity to split to the second position"
            ],
            type: "u8"
          },
          {
            name: "permanent_locked_liquidity_percentage",
            docs: [
              "Percentage of permanent locked liquidity to split to the second position"
            ],
            type: "u8"
          },
          {
            name: "fee_a_percentage",
            docs: [
              "Percentage of fee A pending to split to the second position"
            ],
            type: "u8"
          },
          {
            name: "fee_b_percentage",
            docs: [
              "Percentage of fee B pending to split to the second position"
            ],
            type: "u8"
          },
          {
            name: "reward_0_percentage",
            docs: [
              "Percentage of reward 0 pending to split to the second position"
            ],
            type: "u8"
          },
          {
            name: "reward_1_percentage",
            docs: [
              "Percentage of reward 1 pending to split to the second position"
            ],
            type: "u8"
          },
          {
            name: "padding",
            docs: [
              "padding for future"
            ],
            type: {
              array: [
                "u8",
                16
              ]
            }
          }
        ]
      }
    },
    {
      name: "SplitPositionParameters2",
      type: {
        kind: "struct",
        fields: [
          {
            name: "unlocked_liquidity_numerator",
            type: "u32"
          },
          {
            name: "permanent_locked_liquidity_numerator",
            type: "u32"
          },
          {
            name: "fee_a_numerator",
            type: "u32"
          },
          {
            name: "fee_b_numerator",
            type: "u32"
          },
          {
            name: "reward_0_numerator",
            type: "u32"
          },
          {
            name: "reward_1_numerator",
            type: "u32"
          }
        ]
      }
    },
    {
      name: "StaticConfigParameters",
      type: {
        kind: "struct",
        fields: [
          {
            name: "pool_fees",
            type: {
              defined: {
                name: "PoolFeeParameters"
              }
            }
          },
          {
            name: "sqrt_min_price",
            type: "u128"
          },
          {
            name: "sqrt_max_price",
            type: "u128"
          },
          {
            name: "vault_config_key",
            type: "pubkey"
          },
          {
            name: "pool_creator_authority",
            type: "pubkey"
          },
          {
            name: "activation_type",
            type: "u8"
          },
          {
            name: "collect_fee_mode",
            type: "u8"
          }
        ]
      }
    },
    {
      name: "SwapParameters",
      type: {
        kind: "struct",
        fields: [
          {
            name: "amount_in",
            type: "u64"
          },
          {
            name: "minimum_amount_out",
            type: "u64"
          }
        ]
      }
    },
    {
      name: "SwapParameters2",
      type: {
        kind: "struct",
        fields: [
          {
            name: "amount_0",
            docs: [
              "When it's exact in, partial fill, this will be amount_in. When it's exact out, this will be amount_out"
            ],
            type: "u64"
          },
          {
            name: "amount_1",
            docs: [
              "When it's exact in, partial fill, this will be minimum_amount_out. When it's exact out, this will be maximum_amount_in"
            ],
            type: "u64"
          },
          {
            name: "swap_mode",
            docs: [
              "Swap mode, refer [SwapMode]"
            ],
            type: "u8"
          }
        ]
      }
    },
    {
      name: "SwapResult2",
      type: {
        kind: "struct",
        fields: [
          {
            name: "included_fee_input_amount",
            type: "u64"
          },
          {
            name: "excluded_fee_input_amount",
            type: "u64"
          },
          {
            name: "amount_left",
            type: "u64"
          },
          {
            name: "output_amount",
            type: "u64"
          },
          {
            name: "next_sqrt_price",
            type: "u128"
          },
          {
            name: "trading_fee",
            type: "u64"
          },
          {
            name: "protocol_fee",
            type: "u64"
          },
          {
            name: "partner_fee",
            type: "u64"
          },
          {
            name: "referral_fee",
            type: "u64"
          }
        ]
      }
    },
    {
      name: "TokenBadge",
      docs: [
        "Parameter that set by the protocol"
      ],
      serialization: "bytemuck",
      repr: {
        kind: "c"
      },
      type: {
        kind: "struct",
        fields: [
          {
            name: "token_mint",
            docs: [
              "token mint"
            ],
            type: "pubkey"
          },
          {
            name: "_padding",
            docs: [
              "Reserve"
            ],
            type: {
              array: [
                "u8",
                128
              ]
            }
          }
        ]
      }
    },
    {
      name: "UpdatePoolFeesParameters",
      type: {
        kind: "struct",
        fields: [
          {
            name: "cliff_fee_numerator",
            docs: [
              "Base fee update mode:",
              "- None: skip base fee update",
              "- Some: update new cliff_fee_numerator if base fee is static"
            ],
            type: {
              option: "u64"
            }
          },
          {
            name: "dynamic_fee",
            docs: [
              "Dynamic fee update mode:",
              "- None: skip dynamic fee update",
              "- Some(with default value): disable dynamic fee",
              "- Some(with non default value): enable dynamic fee if disabled or update dynamic fee if enabled"
            ],
            type: {
              option: {
                defined: {
                  name: "DynamicFeeParameters"
                }
              }
            }
          }
        ]
      }
    },
    {
      name: "UserRewardInfo",
      serialization: "bytemuck",
      repr: {
        kind: "c"
      },
      type: {
        kind: "struct",
        fields: [
          {
            name: "reward_per_token_checkpoint",
            docs: [
              "The latest update reward checkpoint"
            ],
            type: {
              array: [
                "u8",
                32
              ]
            }
          },
          {
            name: "reward_pendings",
            docs: [
              "Current pending rewards"
            ],
            type: "u64"
          },
          {
            name: "total_claimed_rewards",
            docs: [
              "Total claimed rewards"
            ],
            type: "u64"
          }
        ]
      }
    },
    {
      name: "Vesting",
      serialization: "bytemuck",
      repr: {
        kind: "c"
      },
      type: {
        kind: "struct",
        fields: [
          {
            name: "position",
            type: "pubkey"
          },
          {
            name: "cliff_point",
            type: "u64"
          },
          {
            name: "period_frequency",
            type: "u64"
          },
          {
            name: "cliff_unlock_liquidity",
            type: "u128"
          },
          {
            name: "liquidity_per_period",
            type: "u128"
          },
          {
            name: "total_released_liquidity",
            type: "u128"
          },
          {
            name: "number_of_period",
            type: "u16"
          },
          {
            name: "padding",
            type: {
              array: [
                "u8",
                14
              ]
            }
          },
          {
            name: "padding2",
            type: {
              array: [
                "u128",
                4
              ]
            }
          }
        ]
      }
    },
    {
      name: "VestingParameters",
      type: {
        kind: "struct",
        fields: [
          {
            name: "cliff_point",
            type: {
              option: "u64"
            }
          },
          {
            name: "period_frequency",
            type: "u64"
          },
          {
            name: "cliff_unlock_liquidity",
            type: "u128"
          },
          {
            name: "liquidity_per_period",
            type: "u128"
          },
          {
            name: "number_of_period",
            type: "u16"
          }
        ]
      }
    }
  ],
  constants: [
    {
      name: "BIN_STEP_BPS_DEFAULT",
      type: "u16",
      value: "1"
    },
    {
      name: "BIN_STEP_U128_DEFAULT_LE_BYTES",
      type: {
        array: [
          "u8",
          16
        ]
      },
      value: "[203, 16, 199, 186, 184, 141, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0]"
    },
    {
      name: "CUSTOMIZABLE_POOL_PREFIX",
      type: "bytes",
      value: "[99, 112, 111, 111, 108]"
    },
    {
      name: "FEE_DENOMINATOR",
      docs: [
        "Default fee denominator. DO NOT simply update it as it will break logic that depends on it as default value."
      ],
      type: "u64",
      value: "1000000000"
    },
    {
      name: "MAX_BASIS_POINT",
      docs: [
        "Max basis point. 100% in pct"
      ],
      type: "u64",
      value: "10000"
    },
    {
      name: "MAX_SQRT_PRICE_LE_BYTES",
      type: {
        array: [
          "u8",
          16
        ]
      },
      value: "[155, 87, 105, 78, 169, 26, 92, 132, 177, 196, 254, 255, 0, 0, 0, 0]"
    },
    {
      name: "MIN_SQRT_PRICE_LE_BYTES",
      type: {
        array: [
          "u8",
          16
        ]
      },
      value: "[80, 59, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]"
    },
    {
      name: "POOL_AUTHORITY_PREFIX",
      type: "bytes",
      value: "[112, 111, 111, 108, 95, 97, 117, 116, 104, 111, 114, 105, 116, 121]"
    },
    {
      name: "POOL_PREFIX",
      type: "bytes",
      value: "[112, 111, 111, 108]"
    },
    {
      name: "POSITION_NFT_ACCOUNT_PREFIX",
      type: "bytes",
      value: "[112, 111, 115, 105, 116, 105, 111, 110, 95, 110, 102, 116, 95, 97, 99, 99, 111, 117, 110, 116]"
    },
    {
      name: "POSITION_PREFIX",
      type: "bytes",
      value: "[112, 111, 115, 105, 116, 105, 111, 110]"
    },
    {
      name: "SPLIT_POSITION_DENOMINATOR",
      type: "u32",
      value: "1000000000"
    },
    {
      name: "TOKEN_VAULT_PREFIX",
      type: "bytes",
      value: "[116, 111, 107, 101, 110, 95, 118, 97, 117, 108, 116]"
    }
  ]
};

// src/CpAmm.ts
import {
  Transaction,
  SystemProgram as SystemProgram2,
  SYSVAR_INSTRUCTIONS_PUBKEY
} from "@solana/web3.js";

// src/types.ts
var Rounding = /* @__PURE__ */ ((Rounding2) => {
  Rounding2[Rounding2["Up"] = 0] = "Up";
  Rounding2[Rounding2["Down"] = 1] = "Down";
  return Rounding2;
})(Rounding || {});
var ActivationPoint = /* @__PURE__ */ ((ActivationPoint2) => {
  ActivationPoint2[ActivationPoint2["Timestamp"] = 0] = "Timestamp";
  ActivationPoint2[ActivationPoint2["Slot"] = 1] = "Slot";
  return ActivationPoint2;
})(ActivationPoint || {});
var BaseFeeMode = /* @__PURE__ */ ((BaseFeeMode3) => {
  BaseFeeMode3[BaseFeeMode3["FeeTimeSchedulerLinear"] = 0] = "FeeTimeSchedulerLinear";
  BaseFeeMode3[BaseFeeMode3["FeeTimeSchedulerExponential"] = 1] = "FeeTimeSchedulerExponential";
  BaseFeeMode3[BaseFeeMode3["RateLimiter"] = 2] = "RateLimiter";
  BaseFeeMode3[BaseFeeMode3["FeeMarketCapSchedulerLinear"] = 3] = "FeeMarketCapSchedulerLinear";
  BaseFeeMode3[BaseFeeMode3["FeeMarketCapSchedulerExponential"] = 4] = "FeeMarketCapSchedulerExponential";
  return BaseFeeMode3;
})(BaseFeeMode || {});
var CollectFeeMode = /* @__PURE__ */ ((CollectFeeMode3) => {
  CollectFeeMode3[CollectFeeMode3["BothToken"] = 0] = "BothToken";
  CollectFeeMode3[CollectFeeMode3["OnlyB"] = 1] = "OnlyB";
  return CollectFeeMode3;
})(CollectFeeMode || {});
var TradeDirection = /* @__PURE__ */ ((TradeDirection3) => {
  TradeDirection3[TradeDirection3["AtoB"] = 0] = "AtoB";
  TradeDirection3[TradeDirection3["BtoA"] = 1] = "BtoA";
  return TradeDirection3;
})(TradeDirection || {});
var ActivationType = /* @__PURE__ */ ((ActivationType3) => {
  ActivationType3[ActivationType3["Slot"] = 0] = "Slot";
  ActivationType3[ActivationType3["Timestamp"] = 1] = "Timestamp";
  return ActivationType3;
})(ActivationType || {});
var PoolVersion = /* @__PURE__ */ ((PoolVersion4) => {
  PoolVersion4[PoolVersion4["V0"] = 0] = "V0";
  PoolVersion4[PoolVersion4["V1"] = 1] = "V1";
  return PoolVersion4;
})(PoolVersion || {});
var PoolStatus = /* @__PURE__ */ ((PoolStatus2) => {
  PoolStatus2[PoolStatus2["Enable"] = 0] = "Enable";
  PoolStatus2[PoolStatus2["Disable"] = 1] = "Disable";
  return PoolStatus2;
})(PoolStatus || {});
var SwapMode = /* @__PURE__ */ ((SwapMode2) => {
  SwapMode2[SwapMode2["ExactIn"] = 0] = "ExactIn";
  SwapMode2[SwapMode2["PartialFill"] = 1] = "PartialFill";
  SwapMode2[SwapMode2["ExactOut"] = 2] = "ExactOut";
  return SwapMode2;
})(SwapMode || {});

// src/pda.ts
import { PublicKey as PublicKey2 } from "@solana/web3.js";

// src/constants.ts
import { PublicKey } from "@solana/web3.js";
import BN from "bn.js";
var CP_AMM_PROGRAM_ID = new PublicKey(
  "cpamdpZCGKUy5JxQXB4dcpGPiikHawvSWAd6mEn1sGG"
);
var LIQUIDITY_SCALE = 128;
var SCALE_OFFSET = 64;
var BASIS_POINT_MAX = 1e4;
var FEE_DENOMINATOR = 1e9;
var ONE_Q64 = new BN(1).shln(SCALE_OFFSET);
var MAX_EXPONENTIAL = new BN(524288);
var MAX = new BN(2).pow(new BN(128)).sub(new BN(1));
var MIN_FEE_BPS = 1;
var MIN_FEE_NUMERATOR = 1e5;
var MAX_FEE_BPS_V0 = 5e3;
var MAX_FEE_NUMERATOR_V0 = 5e8;
var MAX_FEE_BPS_V1 = 9900;
var MAX_FEE_NUMERATOR_V1 = 99e7;
var MIN_SQRT_PRICE = new BN("4295048016");
var MAX_SQRT_PRICE = new BN("79226673521066979257578248091");
var MIN_CU_BUFFER = 5e4;
var MAX_CU_BUFFER = 2e5;
var DYNAMIC_FEE_SCALING_FACTOR = new BN(1e11);
var DYNAMIC_FEE_ROUNDING_OFFSET = new BN(99999999999);
var DYNAMIC_FEE_FILTER_PERIOD_DEFAULT = 10;
var DYNAMIC_FEE_DECAY_PERIOD_DEFAULT = 120;
var DYNAMIC_FEE_REDUCTION_FACTOR_DEFAULT = 5e3;
var BIN_STEP_BPS_DEFAULT = 1;
var BIN_STEP_BPS_U128_DEFAULT = new BN("1844674407370955");
var MAX_PRICE_CHANGE_BPS_DEFAULT = 1500;
var U128_MAX = new BN("340282366920938463463374607431768211455");
var U64_MAX = new BN("18446744073709551615");
var U16_MAX = 65535;
var MAX_RATE_LIMITER_DURATION_IN_SECONDS = 43200;
var MAX_RATE_LIMITER_DURATION_IN_SLOTS = 108e3;
var SPLIT_POSITION_DENOMINATOR = 1e9;
var CURRENT_POOL_VERSION = 1 /* V1 */;
var FEE_PADDING = Array.from(Buffer.alloc(3));

// src/pda.ts
function getFirstKey(key1, key2) {
  const buf1 = key1.toBuffer();
  const buf2 = key2.toBuffer();
  if (Buffer.compare(buf1, buf2) === 1) {
    return buf1;
  }
  return buf2;
}
function getSecondKey(key1, key2) {
  const buf1 = key1.toBuffer();
  const buf2 = key2.toBuffer();
  if (Buffer.compare(buf1, buf2) === 1) {
    return buf2;
  }
  return buf1;
}
function derivePoolAuthority() {
  return PublicKey2.findProgramAddressSync(
    [Buffer.from("pool_authority")],
    CP_AMM_PROGRAM_ID
  )[0];
}
function deriveConfigAddress(index) {
  return PublicKey2.findProgramAddressSync(
    [Buffer.from("config"), index.toArrayLike(Buffer, "le", 8)],
    CP_AMM_PROGRAM_ID
  )[0];
}
function derivePoolAddress(config, tokenAMint, tokenBMint) {
  return PublicKey2.findProgramAddressSync(
    [
      Buffer.from("pool"),
      config.toBuffer(),
      getFirstKey(tokenAMint, tokenBMint),
      getSecondKey(tokenAMint, tokenBMint)
    ],
    CP_AMM_PROGRAM_ID
  )[0];
}
function derivePositionAddress(positionNft) {
  return PublicKey2.findProgramAddressSync(
    [Buffer.from("position"), positionNft.toBuffer()],
    CP_AMM_PROGRAM_ID
  )[0];
}
function deriveTokenVaultAddress(tokenMint, pool) {
  return PublicKey2.findProgramAddressSync(
    [Buffer.from("token_vault"), tokenMint.toBuffer(), pool.toBuffer()],
    CP_AMM_PROGRAM_ID
  )[0];
}
function deriveRewardVaultAddress(pool, rewardIndex) {
  return PublicKey2.findProgramAddressSync(
    [Buffer.from("reward_vault"), pool.toBuffer(), Buffer.from([rewardIndex])],
    CP_AMM_PROGRAM_ID
  )[0];
}
function deriveCustomizablePoolAddress(tokenAMint, tokenBMint) {
  return PublicKey2.findProgramAddressSync(
    [
      Buffer.from("cpool"),
      getFirstKey(tokenAMint, tokenBMint),
      getSecondKey(tokenAMint, tokenBMint)
    ],
    CP_AMM_PROGRAM_ID
  )[0];
}
function deriveTokenBadgeAddress(tokenMint) {
  return PublicKey2.findProgramAddressSync(
    [Buffer.from("token_badge"), tokenMint.toBuffer()],
    CP_AMM_PROGRAM_ID
  )[0];
}
function deriveClaimFeeOperatorAddress(operator) {
  return PublicKey2.findProgramAddressSync(
    [Buffer.from("cf_operator"), operator.toBuffer()],
    CP_AMM_PROGRAM_ID
  )[0];
}
function derivePositionNftAccount(positionNftMint) {
  return PublicKey2.findProgramAddressSync(
    [Buffer.from("position_nft_account"), positionNftMint.toBuffer()],
    CP_AMM_PROGRAM_ID
  )[0];
}
function deriveOperatorAddress(whitelistedAddress) {
  return PublicKey2.findProgramAddressSync(
    [Buffer.from("operator"), whitelistedAddress.toBuffer()],
    CP_AMM_PROGRAM_ID
  )[0];
}

// src/helpers/token.ts
import { bs58 } from "@coral-xyz/anchor/dist/cjs/utils/bytes";
import {
  AccountLayout,
  createAssociatedTokenAccountIdempotentInstruction,
  createCloseAccountInstruction,
  getAccount,
  getAssociatedTokenAddressSync,
  getMint,
  NATIVE_MINT,
  TOKEN_2022_PROGRAM_ID,
  TOKEN_PROGRAM_ID,
  TokenAccountNotFoundError,
  TokenInvalidAccountOwnerError
} from "@solana/spl-token";
import {
  SystemProgram,
  TransactionInstruction
} from "@solana/web3.js";
function getTokenProgram(flag) {
  return flag == 0 ? TOKEN_PROGRAM_ID : TOKEN_2022_PROGRAM_ID;
}
var getTokenDecimals = (connection, mint, tokenProgram) => __async(null, null, function* () {
  return (yield getMint(connection, mint, "confirmed", tokenProgram)).decimals;
});
var getOrCreateATAInstruction = (_0, _1, _2, ..._3) => __async(null, [_0, _1, _2, ..._3], function* (connection, tokenMint, owner, payer = owner, allowOwnerOffCurve = true, tokenProgram) {
  const toAccount = getAssociatedTokenAddressSync(
    tokenMint,
    owner,
    allowOwnerOffCurve,
    tokenProgram
  );
  try {
    yield getAccount(connection, toAccount);
    return { ataPubkey: toAccount, ix: void 0 };
  } catch (e) {
    if (e instanceof TokenAccountNotFoundError || e instanceof TokenInvalidAccountOwnerError) {
      const ix = createAssociatedTokenAccountIdempotentInstruction(
        payer,
        toAccount,
        owner,
        tokenMint,
        tokenProgram
      );
      return { ataPubkey: toAccount, ix };
    } else {
      console.error("Error::getOrCreateATAInstruction", e);
      throw e;
    }
  }
});
var wrapSOLInstruction = (from, to, amount) => {
  return [
    SystemProgram.transfer({
      fromPubkey: from,
      toPubkey: to,
      lamports: amount
    }),
    new TransactionInstruction({
      keys: [
        {
          pubkey: to,
          isSigner: false,
          isWritable: true
        }
      ],
      data: Buffer.from(new Uint8Array([17])),
      programId: TOKEN_PROGRAM_ID
    })
  ];
};
var unwrapSOLInstruction = (_0, ..._1) => __async(null, [_0, ..._1], function* (owner, receiver = owner, allowOwnerOffCurve = true) {
  const wSolATAAccount = getAssociatedTokenAddressSync(
    NATIVE_MINT,
    owner,
    allowOwnerOffCurve
  );
  if (wSolATAAccount) {
    const closedWrappedSolInstruction = createCloseAccountInstruction(
      wSolATAAccount,
      receiver,
      owner,
      [],
      TOKEN_PROGRAM_ID
    );
    return closedWrappedSolInstruction;
  }
  return null;
});
function getAllUserPositionNftAccount(connection, user) {
  return __async(this, null, function* () {
    const filters = [
      {
        memcmp: {
          offset: 32,
          bytes: user.toBase58()
        }
      },
      {
        memcmp: {
          offset: 64,
          bytes: bs58.encode(Buffer.from([1, 0, 0, 0, 0, 0, 0, 0]))
          // 1
        }
      }
    ];
    const tokenAccountsRaw = yield connection.getProgramAccounts(
      TOKEN_2022_PROGRAM_ID,
      {
        filters
      }
    );
    const userPositionNftAccount = [];
    for (const { account, pubkey } of tokenAccountsRaw) {
      const tokenAccountData = AccountLayout.decode(account.data);
      userPositionNftAccount.push({
        positionNft: tokenAccountData.mint,
        positionNftAccount: pubkey
      });
    }
    return userPositionNftAccount;
  });
}
function getAllPositionNftAccountByOwner(connection, user) {
  return __async(this, null, function* () {
    const tokenAccounts = yield connection.getTokenAccountsByOwner(user, {
      programId: TOKEN_2022_PROGRAM_ID
    });
    const userPositionNftAccount = [];
    for (const { account, pubkey } of tokenAccounts.value) {
      const tokenAccountData = AccountLayout.decode(account.data);
      if (tokenAccountData.amount.toString() === "1") {
        userPositionNftAccount.push({
          positionNft: tokenAccountData.mint,
          positionNftAccount: pubkey
        });
      }
    }
    return userPositionNftAccount;
  });
}

// src/helpers/computeUnits.ts
import {
  ComputeBudgetProgram,
  PublicKey as PublicKey4,
  TransactionMessage,
  VersionedTransaction
} from "@solana/web3.js";
var getSimulationComputeUnits = (connection, instructions, payer, lookupTables, commitment = "confirmed") => __async(null, null, function* () {
  var _a, _b, _c;
  const testInstructions = [
    // Set an arbitrarily high number in simulation
    // so we can be sure the transaction will succeed
    // and get the real compute units used
    ComputeBudgetProgram.setComputeUnitLimit({ units: 14e5 }),
    ...instructions
  ];
  const testTransaction = new VersionedTransaction(
    new TransactionMessage({
      instructions: testInstructions,
      payerKey: payer,
      // RecentBlockhash can by any public key during simulation
      // since 'replaceRecentBlockhash' is set to 'true' below
      recentBlockhash: PublicKey4.default.toString()
    }).compileToV0Message(lookupTables)
  );
  const rpcResponse = yield connection.simulateTransaction(testTransaction, {
    replaceRecentBlockhash: true,
    sigVerify: false,
    commitment
  });
  if ((_a = rpcResponse == null ? void 0 : rpcResponse.value) == null ? void 0 : _a.err) {
    const logs = ((_b = rpcResponse.value.logs) == null ? void 0 : _b.join("\n  \u2022 ")) || "No logs available";
    throw new Error(
      `Transaction simulation failed:
  \u2022${logs}` + JSON.stringify((_c = rpcResponse == null ? void 0 : rpcResponse.value) == null ? void 0 : _c.err)
    );
  }
  return rpcResponse.value.unitsConsumed || null;
});
var getEstimatedComputeUnitUsageWithBuffer = (connection, instructions, feePayer, buffer) => __async(null, null, function* () {
  if (!buffer) {
    buffer = 0.1;
  }
  buffer = Math.max(0, buffer);
  buffer = Math.min(1, buffer);
  const estimatedComputeUnitUsage = yield getSimulationComputeUnits(
    connection,
    instructions,
    feePayer,
    []
  );
  if (!estimatedComputeUnitUsage) {
    return 0;
  }
  let extraComputeUnitBuffer = estimatedComputeUnitUsage * buffer;
  if (extraComputeUnitBuffer > MAX_CU_BUFFER) {
    extraComputeUnitBuffer = MAX_CU_BUFFER;
  } else if (extraComputeUnitBuffer < MIN_CU_BUFFER) {
    extraComputeUnitBuffer = MIN_CU_BUFFER;
  }
  return estimatedComputeUnitUsage + extraComputeUnitBuffer;
});
var getEstimatedComputeUnitIxWithBuffer = (connection, instructions, feePayer, buffer) => __async(null, null, function* () {
  const units = yield getEstimatedComputeUnitUsageWithBuffer(
    connection,
    instructions,
    feePayer,
    buffer
  ).catch((error) => {
    console.error("Error::getEstimatedComputeUnitUsageWithBuffer", error);
    return 14e5;
  });
  return ComputeBudgetProgram.setComputeUnitLimit({ units });
});

// src/helpers/utils.ts
import { BN as BN2 } from "@coral-xyz/anchor";
import Decimal from "decimal.js";
var getMaxAmountWithSlippage = (amount, rate) => {
  const slippage = (100 + rate) / 100 * BASIS_POINT_MAX;
  return amount.mul(new BN2(slippage)).div(new BN2(BASIS_POINT_MAX));
};
var getAmountWithSlippage = (amount, slippageBps, swapMode) => {
  let result;
  if (slippageBps > 0) {
    if (swapMode === 2 /* ExactOut */) {
      const slippageFactor = new BN2(BASIS_POINT_MAX + slippageBps);
      result = amount.mul(slippageFactor).div(new BN2(BASIS_POINT_MAX));
    } else {
      const slippageFactor = new BN2(BASIS_POINT_MAX - slippageBps);
      result = amount.mul(slippageFactor).div(new BN2(BASIS_POINT_MAX));
    }
  } else {
    result = amount;
  }
  return result;
};
var getPriceImpact = (amountIn, amountOut, currentSqrtPrice, aToB, tokenADecimal, tokenBDecimal) => {
  if (amountIn.eq(new BN2(0))) {
    return new Decimal(0);
  }
  if (amountOut.eq(new BN2(0))) {
    throw new Error("Amount out must be greater than 0");
  }
  const spotPrice = getPriceFromSqrtPrice(
    currentSqrtPrice,
    tokenADecimal,
    tokenBDecimal
  );
  const executionPrice = new Decimal(amountIn.toString()).div(new Decimal(amountOut.toString())).mul(
    Decimal.pow(
      10,
      aToB ? tokenBDecimal - tokenADecimal : tokenADecimal - tokenBDecimal
    )
  );
  let priceImpact;
  let actualExecutionPrice;
  if (aToB) {
    actualExecutionPrice = new Decimal(1).div(executionPrice);
  } else {
    actualExecutionPrice = executionPrice;
  }
  priceImpact = actualExecutionPrice.sub(spotPrice).abs().div(spotPrice).mul(100);
  return priceImpact;
};
var getPriceChange = (nextSqrtPrice, currentSqrtPrice) => {
  const diff = nextSqrtPrice.pow(new BN2(2)).sub(currentSqrtPrice.pow(new BN2(2))).abs();
  return new Decimal(diff.toString()).div(new Decimal(currentSqrtPrice.pow(new BN2(2)).toString())).mul(100).toNumber();
};
var getPriceFromSqrtPrice = (sqrtPrice, tokenADecimal, tokenBDecimal) => {
  const decimalSqrtPrice = new Decimal(sqrtPrice.toString());
  const price = decimalSqrtPrice.mul(decimalSqrtPrice).mul(new Decimal(__pow(10, tokenADecimal - tokenBDecimal))).div(Decimal.pow(2, 128));
  return price;
};
var getSqrtPriceFromPrice = (price, tokenADecimal, tokenBDecimal) => {
  const decimalPrice = new Decimal(price);
  const adjustedByDecimals = decimalPrice.div(
    new Decimal(__pow(10, tokenADecimal - tokenBDecimal))
  );
  const sqrtValue = Decimal.sqrt(adjustedByDecimals);
  const sqrtValueQ64 = sqrtValue.mul(Decimal.pow(2, 64));
  return new BN2(sqrtValueQ64.floor().toFixed());
};
var getUnClaimLpFee = (poolState, positionState) => {
  const totalPositionLiquidity = positionState.unlockedLiquidity.add(positionState.vestedLiquidity).add(positionState.permanentLockedLiquidity);
  const feeAPerTokenStored = new BN2(
    Buffer.from(poolState.feeAPerLiquidity).reverse()
  ).sub(new BN2(Buffer.from(positionState.feeAPerTokenCheckpoint).reverse()));
  const feeBPerTokenStored = new BN2(
    Buffer.from(poolState.feeBPerLiquidity).reverse()
  ).sub(new BN2(Buffer.from(positionState.feeBPerTokenCheckpoint).reverse()));
  const feeA = totalPositionLiquidity.mul(feeAPerTokenStored).shrn(LIQUIDITY_SCALE);
  const feeB = totalPositionLiquidity.mul(feeBPerTokenStored).shrn(LIQUIDITY_SCALE);
  return {
    feeTokenA: positionState.feeAPending.add(feeA),
    feeTokenB: positionState.feeBPending.add(feeB),
    rewards: positionState.rewardInfos.length > 0 ? positionState.rewardInfos.map((item) => item.rewardPendings) : []
  };
};
function getRewardPerTokenStore(poolReward, poolLiquidity, currentTime) {
  if (poolLiquidity.eq(new BN2(0))) {
    return new BN2(0);
  }
  const lastTimeRewardApplicable = BN2.min(
    currentTime,
    poolReward.rewardDurationEnd
  );
  const timePeriod = lastTimeRewardApplicable.sub(poolReward.lastUpdateTime);
  const currentTotalReward = timePeriod.mul(poolReward.rewardRate);
  const rewardPerTokenStore = currentTotalReward.shln(128).div(poolLiquidity);
  const totalRewardPerTokenStore = new BN2(
    Buffer.from(poolReward.rewardPerTokenStored).reverse()
  ).add(rewardPerTokenStore);
  return totalRewardPerTokenStore;
}
function getRewardPerPeriod(poolReward, currentTime, periodTime) {
  const timeRewardAppicable = currentTime.add(periodTime);
  const period = timeRewardAppicable <= poolReward.rewardDurationEnd ? periodTime : poolReward.rewardDurationEnd.sub(currentTime);
  const rewardPerPeriod = poolReward.rewardRate.mul(period);
  return rewardPerPeriod;
}
function getRewardInfo(poolState, rewardIndex, periodTime, currentTime) {
  const poolReward = poolState.rewardInfos[rewardIndex];
  const rewardPerTokenStore = getRewardPerTokenStore(
    poolReward,
    poolState.liquidity,
    currentTime
  );
  const totalRewardDistributed = rewardPerTokenStore.mul(poolState.liquidity).shrn(192);
  if (poolReward.rewardDurationEnd <= currentTime) {
    return {
      rewardPerPeriod: new BN2(0),
      rewardBalance: new BN2(0),
      totalRewardDistributed
    };
  }
  const rewardPerPeriod = getRewardPerPeriod(
    poolReward,
    currentTime,
    periodTime
  );
  const remainTime = poolReward.rewardDurationEnd.sub(currentTime);
  const rewardBalance = poolReward.rewardRate.mul(remainTime).shrn(64);
  if (poolState.liquidity.eq(new BN2(0))) {
    return {
      rewardPerPeriod,
      rewardBalance,
      totalRewardDistributed: new BN2(0)
    };
  }
  return {
    rewardPerPeriod: rewardPerPeriod.shrn(64),
    rewardBalance,
    totalRewardDistributed
  };
}
function getUserRewardPending(poolState, positionState, rewardIndex, currentTime, periodTime) {
  if (poolState.liquidity.eq(new BN2(0))) {
    return {
      userRewardPerPeriod: new BN2(0),
      userPendingReward: new BN2(0)
    };
  }
  const poolReward = poolState.rewardInfos[rewardIndex];
  const userRewardInfo = positionState.rewardInfos[rewardIndex];
  const rewardPerTokenStore = getRewardPerTokenStore(
    poolReward,
    poolState.liquidity,
    currentTime
  );
  const totalPositionLiquidity = positionState.unlockedLiquidity.add(positionState.vestedLiquidity).add(positionState.permanentLockedLiquidity);
  const userRewardPerTokenCheckPoint = new BN2(
    Buffer.from(userRewardInfo.rewardPerTokenCheckpoint).reverse()
  );
  const newReward = totalPositionLiquidity.mul(rewardPerTokenStore.sub(userRewardPerTokenCheckPoint)).shrn(192);
  if (poolReward.rewardDurationEnd <= currentTime) {
    return {
      userPendingReward: userRewardInfo.rewardPendings.add(newReward),
      userRewardPerPeriod: new BN2(0)
    };
  }
  const rewardPerPeriod = getRewardPerPeriod(
    poolReward,
    currentTime,
    periodTime
  );
  const rewardPerTokenStorePerPeriod = rewardPerPeriod.shln(128).div(poolState.liquidity);
  const userRewardPerPeriod = totalPositionLiquidity.mul(rewardPerTokenStorePerPeriod).shrn(192);
  return {
    userPendingReward: userRewardInfo.rewardPendings.add(newReward),
    userRewardPerPeriod
  };
}

// src/helpers/accountFilters.ts
import { PublicKey as PublicKey5 } from "@solana/web3.js";
var positionByPoolFilter = (pool) => {
  return {
    memcmp: {
      bytes: pool.toBase58(),
      offset: 8
    }
  };
};
var vestingByPositionFilter = (position) => {
  return {
    memcmp: {
      bytes: position.toBase58(),
      offset: 8
    }
  };
};
function offsetBasedFilter(value, offset) {
  const valueKey = typeof value === "string" ? new PublicKey5(value) : value;
  return [
    {
      memcmp: {
        offset,
        bytes: valueKey.toBase58(),
        encoding: "base58"
      }
    }
  ];
}

// src/helpers/token2022.ts
import { BN as BN3 } from "@coral-xyz/anchor";
import {
  calculateFee,
  getEpochFee,
  getTransferFeeConfig,
  MAX_FEE_BASIS_POINTS,
  TOKEN_2022_PROGRAM_ID as TOKEN_2022_PROGRAM_ID2
} from "@solana/spl-token";
function calculatePreFeeAmount(transferFee, postFeeAmount) {
  if (postFeeAmount.isZero()) {
    return new BN3(0);
  }
  if (transferFee.transferFeeBasisPoints === 0) {
    return postFeeAmount;
  }
  const maximumFee = new BN3(transferFee.maximumFee.toString());
  if (transferFee.transferFeeBasisPoints === MAX_FEE_BASIS_POINTS) {
    return postFeeAmount.add(maximumFee);
  }
  const ONE_IN_BASIS_POINTS = new BN3(MAX_FEE_BASIS_POINTS);
  const numerator = postFeeAmount.mul(ONE_IN_BASIS_POINTS);
  const denominator = ONE_IN_BASIS_POINTS.sub(
    new BN3(transferFee.transferFeeBasisPoints)
  );
  const rawPreFeeAmount = numerator.add(denominator).sub(new BN3(1)).div(denominator);
  if (rawPreFeeAmount.sub(postFeeAmount).gte(maximumFee)) {
    return postFeeAmount.add(maximumFee);
  }
  return rawPreFeeAmount;
}
function calculateInverseFee(transferFee, postFeeAmount) {
  const preFeeAmount = calculatePreFeeAmount(transferFee, postFeeAmount);
  return new BN3(
    calculateFee(transferFee, BigInt(preFeeAmount.toString())).toString()
  );
}
function calculateTransferFeeIncludedAmount(transferFeeExcludedAmount, mint, currentEpoch) {
  if (transferFeeExcludedAmount.isZero()) {
    return {
      amount: new BN3(0),
      transferFee: new BN3(0)
    };
  }
  const transferFeeConfig = getTransferFeeConfig(mint);
  if (transferFeeConfig === null) {
    return {
      amount: transferFeeExcludedAmount,
      transferFee: new BN3(0)
    };
  }
  const epochFee = getEpochFee(transferFeeConfig, BigInt(currentEpoch));
  const transferFee = epochFee.transferFeeBasisPoints == MAX_FEE_BASIS_POINTS ? new BN3(epochFee.maximumFee.toString()) : calculateInverseFee(epochFee, transferFeeExcludedAmount);
  const transferFeeIncludedAmount = transferFeeExcludedAmount.add(transferFee);
  return {
    amount: transferFeeIncludedAmount,
    transferFee
  };
}
function calculateTransferFeeExcludedAmount(transferFeeIncludedAmount, mint, currentEpoch) {
  const transferFeeConfig = getTransferFeeConfig(mint);
  if (transferFeeConfig === null) {
    return {
      amount: transferFeeIncludedAmount,
      transferFee: new BN3(0)
    };
  }
  const transferFeeIncludedAmountN = BigInt(
    transferFeeIncludedAmount.toString()
  );
  const transferFee = calculateFee(
    getEpochFee(transferFeeConfig, BigInt(currentEpoch)),
    transferFeeIncludedAmountN
  );
  const transferFeeExcludedAmount = new BN3(
    (transferFeeIncludedAmountN - transferFee).toString()
  );
  return {
    amount: transferFeeExcludedAmount,
    transferFee: new BN3(transferFee.toString())
  };
}
function hasTransferHookExtension(connection, mint) {
  return __async(this, null, function* () {
    try {
      const mintAccountInfo = yield connection.getAccountInfo(mint);
      if (!mintAccountInfo) {
        return { hasTransferHook: false };
      }
      const isToken2022 = mintAccountInfo.owner.equals(TOKEN_2022_PROGRAM_ID2);
      if (!isToken2022) {
        return { hasTransferHook: false };
      }
      const parsedInfo = yield connection.getParsedAccountInfo(mint);
      if (parsedInfo.value && "parsed" in parsedInfo.value.data) {
        const parsedData = parsedInfo.value.data.parsed;
        if (parsedData && parsedData.info && parsedData.info.extensions) {
          const extensions = parsedData.info.extensions;
          const transferHookExtension = extensions.find(
            (ext) => ext.extension === "transferHook"
          );
          if (transferHookExtension && transferHookExtension.state) {
            return {
              hasTransferHook: true,
              transferHookState: {
                authority: transferHookExtension.state.authority,
                programId: transferHookExtension.state.programId
              }
            };
          }
        }
      }
      return { hasTransferHook: false };
    } catch (error) {
      return { hasTransferHook: false };
    }
  });
}
function validateNoTransferHook(connection, tokenAMint, tokenBMint) {
  return __async(this, null, function* () {
    var _a, _b;
    const [tokenACheck, tokenBCheck] = yield Promise.all([
      hasTransferHookExtension(connection, tokenAMint),
      hasTransferHookExtension(connection, tokenBMint)
    ]);
    if (tokenACheck.hasTransferHook) {
      throw new Error(
        `Token A (${tokenAMint.toBase58()}) has a transfer hook extension. Transfer hook might prevent permissionless pool creation. Transfer hook program: ${(_a = tokenACheck.transferHookState) == null ? void 0 : _a.programId}`
      );
    }
    if (tokenBCheck.hasTransferHook) {
      throw new Error(
        `Token B (${tokenBMint.toBase58()}) has a transfer hook extension. Transfer hook might prevent permissionless pool creation. Transfer hook program: ${(_b = tokenBCheck.transferHookState) == null ? void 0 : _b.programId}`
      );
    }
  });
}

// src/helpers/vestings.ts
import { BN as BN4 } from "@coral-xyz/anchor";
import { min } from "bn.js";
function isVestingComplete(vestingData, currentPoint) {
  const cliffPoint = vestingData.cliffPoint;
  const periodFrequency = vestingData.periodFrequency;
  const numberOfPeriods = vestingData.numberOfPeriod;
  const endPoint = cliffPoint.add(periodFrequency.muln(numberOfPeriods));
  return currentPoint.gte(endPoint);
}
function getTotalLockedLiquidity(vestingData) {
  return vestingData.cliffUnlockLiquidity.add(
    vestingData.liquidityPerPeriod.mul(new BN4(vestingData.numberOfPeriod))
  );
}
function getAvailableVestingLiquidity(vestingData, currentPoint) {
  const {
    cliffPoint,
    periodFrequency,
    cliffUnlockLiquidity,
    liquidityPerPeriod,
    numberOfPeriod,
    totalReleasedLiquidity
  } = vestingData;
  if (currentPoint.lt(cliffPoint)) {
    return new BN4(0);
  }
  if (periodFrequency.isZero()) {
    return cliffUnlockLiquidity;
  }
  let passedPeriod = new BN4(currentPoint).sub(cliffPoint).div(periodFrequency);
  passedPeriod = min(passedPeriod, new BN4(numberOfPeriod));
  const unlockedLiquidity = cliffUnlockLiquidity.add(
    passedPeriod.mul(liquidityPerPeriod)
  );
  const availableReleasingLiquidity = unlockedLiquidity.sub(
    totalReleasedLiquidity
  );
  return availableReleasingLiquidity;
}

// src/helpers/validation.ts
import BN16 from "bn.js";

// src/math/poolFees/baseFee.ts
import BN11 from "bn.js";

// src/math/poolFees/rateLimiter.ts
import BN7 from "bn.js";

// src/math/feeMath.ts
import { BN as BN6 } from "@coral-xyz/anchor";

// src/math/utilsMath.ts
import Decimal2 from "decimal.js";
import BN5 from "bn.js";
function mulDiv(x, y, denominator, rounding) {
  const { div, mod } = x.mul(y).divmod(denominator);
  if (rounding == 0 /* Up */ && !mod.isZero()) {
    return div.add(new BN5(1));
  }
  return div;
}
function q64ToDecimal(num, decimalPlaces) {
  return new Decimal2(num.toString()).div(Decimal2.pow(2, 64)).toDecimalPlaces(decimalPlaces);
}
function decimalToQ64(num) {
  return new BN5(num.mul(Decimal2.pow(2, 64)).floor().toFixed());
}
function sqrt(value) {
  if (value.isZero()) {
    return new BN5(0);
  }
  if (value.eq(new BN5(1))) {
    return new BN5(1);
  }
  let x = value;
  let y = value.add(new BN5(1)).div(new BN5(2));
  while (y.lt(x)) {
    x = y;
    y = x.add(value.div(x)).div(new BN5(2));
  }
  return x;
}
function pow(base, exp) {
  let invert = exp.isNeg();
  if (exp.isZero()) {
    return ONE_Q64;
  }
  exp = invert ? exp.abs() : exp;
  if (exp.gt(MAX_EXPONENTIAL)) {
    return new BN5(0);
  }
  let squaredBase = base;
  let result = ONE_Q64;
  if (squaredBase.gte(result)) {
    squaredBase = MAX.div(squaredBase);
    invert = !invert;
  }
  if (!exp.and(new BN5(1)).isZero()) {
    result = result.mul(squaredBase).shrn(SCALE_OFFSET);
  }
  squaredBase = squaredBase.mul(squaredBase).shrn(SCALE_OFFSET);
  if (!exp.and(new BN5(2)).isZero()) {
    result = result.mul(squaredBase).shrn(SCALE_OFFSET);
  }
  squaredBase = squaredBase.mul(squaredBase).shrn(SCALE_OFFSET);
  if (!exp.and(new BN5(4)).isZero()) {
    result = result.mul(squaredBase).shrn(SCALE_OFFSET);
  }
  squaredBase = squaredBase.mul(squaredBase).shrn(SCALE_OFFSET);
  if (!exp.and(new BN5(8)).isZero()) {
    result = result.mul(squaredBase).shrn(SCALE_OFFSET);
  }
  squaredBase = squaredBase.mul(squaredBase).shrn(SCALE_OFFSET);
  if (!exp.and(new BN5(16)).isZero()) {
    result = result.mul(squaredBase).shrn(SCALE_OFFSET);
  }
  squaredBase = squaredBase.mul(squaredBase).shrn(SCALE_OFFSET);
  if (!exp.and(new BN5(32)).isZero()) {
    result = result.mul(squaredBase).shrn(SCALE_OFFSET);
  }
  squaredBase = squaredBase.mul(squaredBase).shrn(SCALE_OFFSET);
  if (!exp.and(new BN5(64)).isZero()) {
    result = result.mul(squaredBase).shrn(SCALE_OFFSET);
  }
  squaredBase = squaredBase.mul(squaredBase).shrn(SCALE_OFFSET);
  if (!exp.and(new BN5(128)).isZero()) {
    result = result.mul(squaredBase).shrn(SCALE_OFFSET);
  }
  squaredBase = squaredBase.mul(squaredBase).shrn(SCALE_OFFSET);
  if (!exp.and(new BN5(256)).isZero()) {
    result = result.mul(squaredBase).shrn(SCALE_OFFSET);
  }
  squaredBase = squaredBase.mul(squaredBase).shrn(SCALE_OFFSET);
  if (!exp.and(new BN5(512)).isZero()) {
    result = result.mul(squaredBase).shrn(SCALE_OFFSET);
  }
  squaredBase = squaredBase.mul(squaredBase).shrn(SCALE_OFFSET);
  if (!exp.and(new BN5(1024)).isZero()) {
    result = result.mul(squaredBase).shrn(SCALE_OFFSET);
  }
  squaredBase = squaredBase.mul(squaredBase).shrn(SCALE_OFFSET);
  if (!exp.and(new BN5(2048)).isZero()) {
    result = result.mul(squaredBase).shrn(SCALE_OFFSET);
  }
  squaredBase = squaredBase.mul(squaredBase).shrn(SCALE_OFFSET);
  if (!exp.and(new BN5(4096)).isZero()) {
    result = result.mul(squaredBase).shrn(SCALE_OFFSET);
  }
  squaredBase = squaredBase.mul(squaredBase).shrn(SCALE_OFFSET);
  if (!exp.and(new BN5(8192)).isZero()) {
    result = result.mul(squaredBase).shrn(SCALE_OFFSET);
  }
  squaredBase = squaredBase.mul(squaredBase).shrn(SCALE_OFFSET);
  if (!exp.and(new BN5(16384)).isZero()) {
    result = result.mul(squaredBase).shrn(SCALE_OFFSET);
  }
  squaredBase = squaredBase.mul(squaredBase).shrn(SCALE_OFFSET);
  if (!exp.and(new BN5(32768)).isZero()) {
    result = result.mul(squaredBase).shrn(SCALE_OFFSET);
  }
  squaredBase = squaredBase.mul(squaredBase).shrn(SCALE_OFFSET);
  if (!exp.and(new BN5(65536)).isZero()) {
    result = result.mul(squaredBase).shrn(SCALE_OFFSET);
  }
  squaredBase = squaredBase.mul(squaredBase).shrn(SCALE_OFFSET);
  if (!exp.and(new BN5(131072)).isZero()) {
    result = result.mul(squaredBase).shrn(SCALE_OFFSET);
  }
  squaredBase = squaredBase.mul(squaredBase).shrn(SCALE_OFFSET);
  if (!exp.and(new BN5(262144)).isZero()) {
    result = result.mul(squaredBase).shrn(SCALE_OFFSET);
  }
  if (result.isZero()) {
    return new BN5(0);
  }
  if (invert) {
    result = MAX.div(result);
  }
  return result;
}

// src/math/feeMath.ts
function toNumerator(bps, feeDenominator) {
  const numerator = mulDiv(
    bps,
    feeDenominator,
    new BN6(BASIS_POINT_MAX),
    1 /* Down */
  );
  return numerator;
}
function getFeeInPeriod(cliffFeeNumerator, reductionFactor, passedPeriod) {
  if (reductionFactor.isZero()) {
    return cliffFeeNumerator;
  }
  const bps = reductionFactor.shln(SCALE_OFFSET).div(new BN6(BASIS_POINT_MAX));
  const base = ONE_Q64.sub(bps);
  const result = pow(base, new BN6(passedPeriod));
  if (result.gt(U128_MAX)) {
    throw new Error("Math overflow");
  }
  const fee = result.mul(cliffFeeNumerator).shrn(SCALE_OFFSET);
  return fee;
}
function getFeeMode(collectFeeMode, tradeDirection, hasReferral) {
  let feesOnInput;
  let feesOnTokenA;
  if (collectFeeMode === 0 /* BothToken */) {
    if (tradeDirection === 0 /* AtoB */) {
      feesOnInput = false;
      feesOnTokenA = false;
    } else {
      feesOnInput = false;
      feesOnTokenA = true;
    }
  } else {
    if (tradeDirection === 0 /* AtoB */) {
      feesOnInput = false;
      feesOnTokenA = false;
    } else {
      feesOnInput = true;
      feesOnTokenA = false;
    }
  }
  return {
    feesOnInput,
    feesOnTokenA,
    hasReferral
  };
}
function getTotalFeeNumerator(poolFees, baseFeeNumerator, maxFeeNumerator) {
  let dynamicFeeNumerator = new BN6(0);
  if (poolFees.dynamicFee.initialized !== 0) {
    dynamicFeeNumerator = getDynamicFeeNumerator(
      poolFees.dynamicFee.volatilityAccumulator,
      new BN6(poolFees.dynamicFee.binStep),
      new BN6(poolFees.dynamicFee.variableFeeControl)
    );
  }
  const totalFeeNumerator = dynamicFeeNumerator.add(baseFeeNumerator);
  return BN6.min(totalFeeNumerator, maxFeeNumerator);
}
function getTotalTradingFeeFromIncludedFeeAmount(poolFees, currentPoint, activationPoint, includedFeeAmount, tradeDirection, maxFeeNumerator, initSqrtPrice, currentSqrtPrice) {
  const baseFeeHandler = getBaseFeeHandler(poolFees.baseFee.baseFeeInfo.data);
  const baseFeeNumerator = baseFeeHandler.getBaseFeeNumeratorFromIncludedFeeAmount(
    currentPoint,
    activationPoint,
    tradeDirection,
    includedFeeAmount,
    initSqrtPrice,
    currentSqrtPrice
  );
  return getTotalFeeNumerator(poolFees, baseFeeNumerator, maxFeeNumerator);
}
function getTotalTradingFeeFromExcludedFeeAmount(poolFees, currentPoint, activationPoint, excludedFeeAmount, tradeDirection, maxFeeNumerator, initSqrtPrice, currentSqrtPrice) {
  const baseFeeHandler = getBaseFeeHandler(poolFees.baseFee.baseFeeInfo.data);
  const baseFeeNumerator = baseFeeHandler.getBaseFeeNumeratorFromExcludedFeeAmount(
    currentPoint,
    activationPoint,
    tradeDirection,
    excludedFeeAmount,
    initSqrtPrice,
    currentSqrtPrice
  );
  return getTotalFeeNumerator(poolFees, baseFeeNumerator, maxFeeNumerator);
}
function splitFees(poolFees, feeAmount, hasReferral, hasPartner2) {
  const protocolFee = feeAmount.muln(poolFees.protocolFeePercent).divn(100);
  const tradingFee = feeAmount.sub(protocolFee);
  let referralFee = new BN6(0);
  if (hasReferral) {
    referralFee = protocolFee.muln(poolFees.referralFeePercent).divn(100);
  }
  const protocolFeeAfterReferral = protocolFee.sub(referralFee);
  let partnerFee = new BN6(0);
  if (hasPartner2 && poolFees.partnerFeePercent > 0) {
    partnerFee = protocolFeeAfterReferral.muln(poolFees.partnerFeePercent).divn(100);
  }
  const finalProtocolFee = protocolFeeAfterReferral.sub(partnerFee);
  return {
    tradingFee,
    protocolFee: finalProtocolFee,
    referralFee,
    partnerFee
  };
}
function getFeeOnAmount(poolFees, amount, tradeFeeNumerator, hasReferral, hasPartner2) {
  const { excludedFeeAmount, tradingFee } = getExcludedFeeAmount(
    tradeFeeNumerator,
    amount
  );
  const splitFeesResult = splitFees(
    poolFees,
    tradingFee,
    hasReferral,
    hasPartner2
  );
  return {
    amount: excludedFeeAmount,
    tradingFee: splitFeesResult.tradingFee,
    protocolFee: splitFeesResult.protocolFee,
    partnerFee: splitFeesResult.partnerFee,
    referralFee: splitFeesResult.referralFee
  };
}
function getExcludedFeeAmount(tradeFeeNumerator, includedFeeAmount) {
  const tradingFee = mulDiv(
    includedFeeAmount,
    tradeFeeNumerator,
    new BN6(FEE_DENOMINATOR),
    0 /* Up */
  );
  const excludedFeeAmount = includedFeeAmount.sub(tradingFee);
  return { excludedFeeAmount, tradingFee };
}
function getIncludedFeeAmount(tradeFeeNumerator, excludedFeeAmount) {
  const denominator = new BN6(FEE_DENOMINATOR).sub(tradeFeeNumerator);
  if (denominator.isZero() || denominator.isNeg()) {
    throw new Error("Invalid fee numerator");
  }
  const includedFeeAmount = mulDiv(
    excludedFeeAmount,
    new BN6(FEE_DENOMINATOR),
    denominator,
    0 /* Up */
  );
  const feeAmount = includedFeeAmount.sub(excludedFeeAmount);
  return { includedFeeAmount, feeAmount };
}
function getMaxFeeNumerator(poolVersion) {
  switch (poolVersion) {
    case 0 /* V0 */:
      return new BN6(MAX_FEE_NUMERATOR_V0);
    case 1 /* V1 */:
      return new BN6(MAX_FEE_NUMERATOR_V1);
    default:
      throw new Error("Invalid pool version");
  }
}
function getMaxFeeBps(poolVersion) {
  switch (poolVersion) {
    case 0 /* V0 */:
      return MAX_FEE_BPS_V0;
    case 1 /* V1 */:
      return MAX_FEE_BPS_V1;
    default:
      throw new Error("Invalid pool version");
  }
}

// src/math/poolFees/rateLimiter.ts
function isZeroRateLimiter(referenceAmount, maxLimiterDuration, maxFeeBps, feeIncrementBps) {
  return referenceAmount.isZero() && maxLimiterDuration === 0 && maxFeeBps === 0 && feeIncrementBps === 0;
}
function isNonZeroRateLimiter(referenceAmount, maxLimiterDuration, maxFeeBps, feeIncrementBps) {
  return referenceAmount.isZero() && maxLimiterDuration !== 0 && maxFeeBps !== 0 && feeIncrementBps !== 0;
}
function isRateLimiterApplied(referenceAmount, maxLimiterDuration, maxFeeBps, feeIncrementBps, currentPoint, activationPoint, tradeDirection) {
  if (isZeroRateLimiter(
    referenceAmount,
    maxLimiterDuration,
    maxFeeBps,
    feeIncrementBps
  )) {
    return false;
  }
  if (tradeDirection === 0 /* AtoB */) {
    return false;
  }
  if (currentPoint.lt(activationPoint)) {
    return false;
  }
  const lastEffectiveRateLimiterPoint = activationPoint.add(
    new BN7(maxLimiterDuration)
  );
  if (currentPoint.gt(lastEffectiveRateLimiterPoint)) {
    return false;
  }
  return true;
}
function getMaxIndex(maxFeeBps, cliffFeeNumerator, feeIncrementBps) {
  const maxFeeNumerator = toNumerator(
    new BN7(maxFeeBps),
    new BN7(FEE_DENOMINATOR)
  );
  if (cliffFeeNumerator.gt(maxFeeNumerator)) {
    throw new Error("cliffFeeNumerator cannot be greater than maxFeeNumerator");
  }
  const deltaNumerator = maxFeeNumerator.sub(cliffFeeNumerator);
  const feeIncrementNumerator = toNumerator(
    new BN7(feeIncrementBps),
    new BN7(FEE_DENOMINATOR)
  );
  if (feeIncrementNumerator.isZero()) {
    throw new Error("feeIncrementNumerator cannot be zero");
  }
  const maxIndex = deltaNumerator.div(feeIncrementNumerator);
  return maxIndex;
}
function getFeeNumeratorFromIncludedFeeAmount(inputAmount, referenceAmount, cliffFeeNumerator, maxFeeBps, feeIncrementBps) {
  if (inputAmount.lte(referenceAmount)) {
    return cliffFeeNumerator;
  } else {
    const maxFeeNumerator = toNumerator(
      new BN7(maxFeeBps),
      new BN7(FEE_DENOMINATOR)
    );
    const c = cliffFeeNumerator;
    const inputMinusRef = inputAmount.sub(referenceAmount);
    const a = inputMinusRef.div(referenceAmount);
    const b = inputMinusRef.mod(referenceAmount);
    const maxIndex = getMaxIndex(maxFeeBps, cliffFeeNumerator, feeIncrementBps);
    const i = toNumerator(new BN7(feeIncrementBps), new BN7(FEE_DENOMINATOR));
    const x0 = referenceAmount;
    const one = new BN7(1);
    const two = new BN7(2);
    let tradingFeeNumerator;
    if (a.lt(maxIndex)) {
      const numerator1 = c.add(c.mul(a)).add(i.mul(a).mul(a.add(one)).div(two));
      const numerator2 = c.add(i.mul(a.add(one)));
      const firstFee = x0.mul(numerator1);
      const secondFee = b.mul(numerator2);
      tradingFeeNumerator = firstFee.add(secondFee);
    } else {
      const numerator1 = c.add(c.mul(maxIndex)).add(i.mul(maxIndex).mul(maxIndex.add(one)).div(two));
      const numerator2 = maxFeeNumerator;
      const firstFee = x0.mul(numerator1);
      const d = a.sub(maxIndex);
      const leftAmount = d.mul(x0).add(b);
      const secondFee = leftAmount.mul(numerator2);
      tradingFeeNumerator = firstFee.add(secondFee);
    }
    const denominator = new BN7(FEE_DENOMINATOR);
    const tradingFee = tradingFeeNumerator.add(denominator).sub(one).div(denominator);
    const numerator = mulDiv(tradingFee, denominator, inputAmount, 0 /* Up */);
    if (numerator.gt(new BN7(U64_MAX))) {
      throw new Error("Numerator does not fit in u64");
    }
    return numerator;
  }
}
function getExcludedFeeAmountFromIncludedFeeAmount(includedFeeAmount, referenceAmount, cliffFeeNumerator, maxFeeBps, feeIncrementBps) {
  const feeNumerator = getFeeNumeratorFromIncludedFeeAmount(
    includedFeeAmount,
    referenceAmount,
    cliffFeeNumerator,
    maxFeeBps,
    feeIncrementBps
  );
  const { excludedFeeAmount } = getExcludedFeeAmount(
    feeNumerator,
    includedFeeAmount
  );
  return excludedFeeAmount;
}
function getCheckedAmounts(referenceAmount, cliffFeeNumerator, maxFeeBps, feeIncrementBps) {
  const maxIndex = getMaxIndex(maxFeeBps, cliffFeeNumerator, feeIncrementBps);
  const x0 = referenceAmount;
  const one = new BN7(1);
  const maxIndexInputAmount = maxIndex.add(one).mul(x0);
  if (maxIndexInputAmount.lte(U64_MAX)) {
    const checkedIncludedFeeAmount = maxIndexInputAmount;
    const checkedExcludedFeeAmount = getExcludedFeeAmountFromIncludedFeeAmount(
      checkedIncludedFeeAmount,
      referenceAmount,
      cliffFeeNumerator,
      maxFeeBps,
      feeIncrementBps
    );
    return {
      checkedExcludedFeeAmount,
      checkedIncludedFeeAmount,
      isOverflow: false
    };
  } else {
    const checkedIncludedFeeAmount = U64_MAX;
    const checkedExcludedFeeAmount = getExcludedFeeAmountFromIncludedFeeAmount(
      checkedIncludedFeeAmount,
      referenceAmount,
      cliffFeeNumerator,
      maxFeeBps,
      feeIncrementBps
    );
    return {
      checkedExcludedFeeAmount,
      checkedIncludedFeeAmount,
      isOverflow: true
    };
  }
}
function getFeeNumeratorFromExcludedFeeAmount(excludedFeeAmount, referenceAmount, cliffFeeNumerator, maxFeeBps, feeIncrementBps) {
  const excludedFeeReferenceAmount = getExcludedFeeAmountFromIncludedFeeAmount(
    referenceAmount,
    referenceAmount,
    cliffFeeNumerator,
    maxFeeBps,
    feeIncrementBps
  );
  if (excludedFeeAmount.lte(excludedFeeReferenceAmount)) {
    return cliffFeeNumerator;
  }
  const { checkedExcludedFeeAmount, checkedIncludedFeeAmount, isOverflow } = getCheckedAmounts(
    referenceAmount,
    cliffFeeNumerator,
    maxFeeBps,
    feeIncrementBps
  );
  if (excludedFeeAmount.eq(checkedExcludedFeeAmount)) {
    return getFeeNumeratorFromIncludedFeeAmount(
      checkedIncludedFeeAmount,
      referenceAmount,
      cliffFeeNumerator,
      maxFeeBps,
      feeIncrementBps
    );
  }
  let includedFeeAmount;
  if (excludedFeeAmount.lt(checkedExcludedFeeAmount)) {
    const TWO = new BN7(2);
    const FOUR = new BN7(4);
    const i = toNumerator(new BN7(feeIncrementBps), new BN7(FEE_DENOMINATOR));
    const x0 = referenceAmount;
    const d = new BN7(FEE_DENOMINATOR);
    const c = cliffFeeNumerator;
    const ex = excludedFeeAmount;
    const x = i;
    const y = TWO.mul(d).mul(x0).add(i.mul(x0)).sub(TWO.mul(c).mul(x0));
    const z = TWO.mul(ex).mul(d).mul(x0);
    const discriminant = y.mul(y).sub(FOUR.mul(x).mul(z));
    const sqrtDiscriminant = sqrt(discriminant);
    includedFeeAmount = y.sub(sqrtDiscriminant).div(TWO.mul(x));
    const numerator = y.sub(sqrtDiscriminant);
    const denominator = TWO.mul(x);
    includedFeeAmount = numerator.div(denominator);
    const aPlusOne = includedFeeAmount.div(x0);
    const firstExcludedFeeAmount = getExcludedFeeAmountFromIncludedFeeAmount(
      includedFeeAmount,
      referenceAmount,
      cliffFeeNumerator,
      maxFeeBps,
      feeIncrementBps
    );
    const excludedFeeRemainingAmount = excludedFeeAmount.sub(
      firstExcludedFeeAmount
    );
    const remainingAmountFeeNumerator = c.add(i.mul(aPlusOne));
    const { includedFeeAmount: includedFeeRemainingAmount } = getIncludedFeeAmount(
      remainingAmountFeeNumerator,
      excludedFeeRemainingAmount
    );
    includedFeeAmount = includedFeeAmount.add(includedFeeRemainingAmount);
  } else {
    if (isOverflow) {
      throw new Error("Math overflow in getFeeNumeratorFromExcludedFeeAmount");
    }
    const excludedFeeRemainingAmount = excludedFeeAmount.sub(
      checkedExcludedFeeAmount
    );
    const maxFeeNumerator = toNumerator(
      new BN7(maxFeeBps),
      new BN7(FEE_DENOMINATOR)
    );
    const { includedFeeAmount: includedFeeRemainingAmount } = getIncludedFeeAmount(maxFeeNumerator, excludedFeeRemainingAmount);
    includedFeeAmount = includedFeeRemainingAmount.add(
      checkedIncludedFeeAmount
    );
  }
  const tradingFee = includedFeeAmount.sub(excludedFeeAmount);
  const feeNumerator = mulDiv(
    tradingFee,
    new BN7(FEE_DENOMINATOR),
    includedFeeAmount,
    0 /* Up */
  );
  if (feeNumerator.lt(cliffFeeNumerator)) {
    throw new Error("feeNumerator is less than cliffFeeNumerator");
  }
  return feeNumerator;
}

// src/math/poolFees/feeTimeScheduler.ts
import BN9 from "bn.js";

// src/math/poolFees/feeScheduler.ts
import BN8 from "bn.js";
function getFeeNumeratorOnLinearFeeScheduler(cliffFeeNumerator, reductionFactor, period) {
  const reduction = new BN8(period).mul(reductionFactor);
  return cliffFeeNumerator.sub(reduction);
}
function getFeeNumeratorOnExponentialFeeScheduler(cliffFeeNumerator, reductionFactor, period) {
  if (period === 0) {
    return cliffFeeNumerator;
  }
  const basisPointMax = new BN8(BASIS_POINT_MAX);
  const bps = new BN8(reductionFactor).shln(64).div(basisPointMax);
  const base = ONE_Q64.sub(bps);
  const result = pow(base, new BN8(period));
  return cliffFeeNumerator.mul(result).div(ONE_Q64);
}
function getMaxBaseFeeNumerator(cliffFeeNumerator) {
  return cliffFeeNumerator;
}

// src/math/poolFees/feeTimeScheduler.ts
function getFeeTimeBaseFeeNumeratorByPeriod(cliffFeeNumerator, numberOfPeriod, period, reductionFactor, feeTimeSchedulerMode) {
  const periodValue = BN9.min(period, new BN9(numberOfPeriod));
  const periodNumber = periodValue.toNumber();
  if (periodNumber > U16_MAX) {
    throw new Error("Math overflow");
  }
  switch (feeTimeSchedulerMode) {
    case 0 /* FeeTimeSchedulerLinear */: {
      const feeNumerator = getFeeNumeratorOnLinearFeeScheduler(
        cliffFeeNumerator,
        reductionFactor,
        periodNumber
      );
      return feeNumerator;
    }
    case 1 /* FeeTimeSchedulerExponential */: {
      const feeNumerator = getFeeNumeratorOnExponentialFeeScheduler(
        cliffFeeNumerator,
        reductionFactor,
        periodNumber
      );
      return feeNumerator;
    }
    default:
      throw new Error("Invalid fee time scheduler mode");
  }
}
function getFeeTimeBaseFeeNumerator(cliffFeeNumerator, numberOfPeriod, periodFrequency, reductionFactor, feeTimeSchedulerMode, currentPoint, activationPoint) {
  if (periodFrequency.isZero()) {
    return cliffFeeNumerator;
  }
  let period;
  if (currentPoint.lt(activationPoint)) {
    period = new BN9(numberOfPeriod);
  } else {
    period = currentPoint.sub(activationPoint).div(periodFrequency);
    if (period.gt(new BN9(numberOfPeriod))) {
      period = new BN9(numberOfPeriod);
    }
  }
  return getFeeTimeBaseFeeNumeratorByPeriod(
    cliffFeeNumerator,
    numberOfPeriod,
    period,
    reductionFactor,
    feeTimeSchedulerMode
  );
}
function getFeeTimeMinBaseFeeNumerator(cliffFeeNumerator, numberOfPeriod, reductionFactor, feeTimeSchedulerMode) {
  return getFeeTimeBaseFeeNumeratorByPeriod(
    cliffFeeNumerator,
    numberOfPeriod,
    new BN9(numberOfPeriod),
    reductionFactor,
    feeTimeSchedulerMode
  );
}

// src/math/poolFees/feeMarketCapScheduler.ts
import BN10 from "bn.js";
function getFeeMarketCapBaseFeeNumeratorByPeriod(cliffFeeNumerator, numberOfPeriod, period, reductionFactor, feeMarketCapSchedulerMode) {
  const periodValue = BN10.min(period, new BN10(numberOfPeriod));
  const periodNumber = periodValue.toNumber();
  switch (feeMarketCapSchedulerMode) {
    case 3 /* FeeMarketCapSchedulerLinear */: {
      const feeNumerator = getFeeNumeratorOnLinearFeeScheduler(
        cliffFeeNumerator,
        reductionFactor,
        periodNumber
      );
      return feeNumerator;
    }
    case 4 /* FeeMarketCapSchedulerExponential */: {
      const feeNumerator = getFeeNumeratorOnExponentialFeeScheduler(
        cliffFeeNumerator,
        reductionFactor,
        periodNumber
      );
      return feeNumerator;
    }
    default:
      throw new Error("Invalid fee market cap scheduler mode");
  }
}
function getFeeMarketCapBaseFeeNumerator(cliffFeeNumerator, numberOfPeriod, sqrtPriceStepBps, schedulerExpirationDuration, reductionFactor, feeMarketCapSchedulerMode, currentPoint, activationPoint, initSqrtPrice, currentSqrtPrice) {
  const schedulerExpirationPoint = activationPoint.add(
    new BN10(schedulerExpirationDuration)
  );
  let period;
  if (currentPoint.gt(schedulerExpirationPoint) || currentPoint.lt(activationPoint)) {
    period = new BN10(numberOfPeriod);
  } else {
    if (currentSqrtPrice.lte(initSqrtPrice)) {
      period = new BN10(0);
    } else {
      const maxBps = new BN10(BASIS_POINT_MAX);
      const stepBps = new BN10(sqrtPriceStepBps);
      const passedPeriod = currentSqrtPrice.sub(initSqrtPrice).mul(maxBps).div(initSqrtPrice).div(stepBps);
      if (passedPeriod.gt(new BN10(numberOfPeriod))) {
        period = new BN10(numberOfPeriod);
      } else {
        period = passedPeriod;
      }
    }
    period = BN10.min(period, new BN10(numberOfPeriod));
  }
  return getFeeMarketCapBaseFeeNumeratorByPeriod(
    cliffFeeNumerator,
    numberOfPeriod,
    period,
    reductionFactor,
    feeMarketCapSchedulerMode
  );
}
function getFeeMarketCapMinBaseFeeNumerator(cliffFeeNumerator, numberOfPeriod, reductionFactor, feeMarketCapSchedulerMode) {
  return getFeeMarketCapBaseFeeNumeratorByPeriod(
    cliffFeeNumerator,
    numberOfPeriod,
    new BN10(numberOfPeriod),
    reductionFactor,
    feeMarketCapSchedulerMode
  );
}

// src/math/poolFees/baseFee.ts
var FeeRateLimiter = class {
  constructor(cliffFeeNumerator, feeIncrementBps, maxFeeBps, maxLimiterDuration, referenceAmount) {
    this.cliffFeeNumerator = cliffFeeNumerator;
    this.feeIncrementBps = feeIncrementBps;
    this.maxFeeBps = maxFeeBps;
    this.maxLimiterDuration = maxLimiterDuration;
    this.referenceAmount = referenceAmount;
  }
  validate(collectFeeMode, activationType, poolVersion) {
    return validateFeeRateLimiter(
      this.cliffFeeNumerator,
      this.feeIncrementBps,
      this.maxFeeBps,
      this.maxLimiterDuration,
      this.referenceAmount,
      collectFeeMode,
      activationType,
      poolVersion
    );
  }
  getBaseFeeNumeratorFromIncludedFeeAmount(currentPoint, activationPoint, tradeDirection, includedFeeAmount, _initSqrtPrice, _currentSqrtPrice) {
    if (isRateLimiterApplied(
      this.referenceAmount,
      this.maxLimiterDuration,
      this.maxFeeBps,
      this.feeIncrementBps,
      currentPoint,
      activationPoint,
      tradeDirection
    )) {
      return getFeeNumeratorFromIncludedFeeAmount(
        includedFeeAmount,
        this.referenceAmount,
        this.cliffFeeNumerator,
        this.maxFeeBps,
        this.feeIncrementBps
      );
    } else {
      return this.cliffFeeNumerator;
    }
  }
  getBaseFeeNumeratorFromExcludedFeeAmount(currentPoint, activationPoint, tradeDirection, excludedFeeAmount, _initSqrtPrice, _currentSqrtPrice) {
    if (isRateLimiterApplied(
      this.referenceAmount,
      this.maxLimiterDuration,
      this.maxFeeBps,
      this.feeIncrementBps,
      currentPoint,
      activationPoint,
      tradeDirection
    )) {
      return getFeeNumeratorFromExcludedFeeAmount(
        excludedFeeAmount,
        this.referenceAmount,
        this.cliffFeeNumerator,
        this.maxFeeBps,
        this.feeIncrementBps
      );
    } else {
      return this.cliffFeeNumerator;
    }
  }
  validateBaseFeeIsStatic(currentPoint, activationPoint) {
    return validateFeeRateLimiterBaseFeeIsStatic(
      currentPoint,
      activationPoint,
      this.maxLimiterDuration,
      this.referenceAmount,
      this.maxFeeBps,
      this.feeIncrementBps
    );
  }
  getMinBaseFeeNumerator() {
    return this.cliffFeeNumerator;
  }
};
var FeeTimeScheduler = class {
  constructor(cliffFeeNumerator, numberOfPeriod, periodFrequency, reductionFactor, feeTimeSchedulerMode) {
    this.cliffFeeNumerator = cliffFeeNumerator;
    this.numberOfPeriod = numberOfPeriod;
    this.periodFrequency = periodFrequency;
    this.reductionFactor = reductionFactor;
    this.feeTimeSchedulerMode = feeTimeSchedulerMode;
  }
  validate(collectFeeMode, activationType, poolVersion) {
    return validateFeeTimeScheduler(
      this.numberOfPeriod,
      this.periodFrequency,
      this.reductionFactor,
      this.cliffFeeNumerator,
      this.feeTimeSchedulerMode,
      poolVersion
    );
  }
  getBaseFeeNumeratorFromIncludedFeeAmount(currentPoint, activationPoint, _tradeDirection, _includedFeeAmount, _initSqrtPrice, _currentSqrtPrice) {
    return getFeeTimeBaseFeeNumerator(
      this.cliffFeeNumerator,
      this.numberOfPeriod,
      this.periodFrequency,
      this.reductionFactor,
      this.feeTimeSchedulerMode,
      currentPoint,
      activationPoint
    );
  }
  getBaseFeeNumeratorFromExcludedFeeAmount(currentPoint, activationPoint, _tradeDirection, _excludedFeeAmount, _initSqrtPrice, _currentSqrtPrice) {
    return getFeeTimeBaseFeeNumerator(
      this.cliffFeeNumerator,
      this.numberOfPeriod,
      this.periodFrequency,
      this.reductionFactor,
      this.feeTimeSchedulerMode,
      currentPoint,
      activationPoint
    );
  }
  validateBaseFeeIsStatic(currentPoint, activationPoint) {
    return validateFeeTimeSchedulerBaseFeeIsStatic(
      currentPoint,
      activationPoint,
      new BN11(this.numberOfPeriod),
      this.periodFrequency
    );
  }
  getMinBaseFeeNumerator() {
    return getFeeTimeMinBaseFeeNumerator(
      this.cliffFeeNumerator,
      this.numberOfPeriod,
      this.reductionFactor,
      this.feeTimeSchedulerMode
    );
  }
};
var FeeMarketCapScheduler = class {
  constructor(cliffFeeNumerator, numberOfPeriod, sqrtPriceStepBps, schedulerExpirationDuration, reductionFactor, feeMarketCapSchedulerMode) {
    this.cliffFeeNumerator = cliffFeeNumerator;
    this.numberOfPeriod = numberOfPeriod;
    this.sqrtPriceStepBps = sqrtPriceStepBps;
    this.schedulerExpirationDuration = schedulerExpirationDuration;
    this.reductionFactor = reductionFactor;
    this.feeMarketCapSchedulerMode = feeMarketCapSchedulerMode;
  }
  validate(_collectFeeMode, _activationType, poolVersion) {
    return validateFeeMarketCapScheduler(
      this.cliffFeeNumerator,
      this.numberOfPeriod,
      new BN11(this.sqrtPriceStepBps),
      this.reductionFactor,
      new BN11(this.schedulerExpirationDuration),
      this.feeMarketCapSchedulerMode,
      poolVersion
    );
  }
  getBaseFeeNumeratorFromIncludedFeeAmount(currentPoint, activationPoint, _tradeDirection, _includedFeeAmount, initSqrtPrice, currentSqrtPrice) {
    return getFeeMarketCapBaseFeeNumerator(
      this.cliffFeeNumerator,
      this.numberOfPeriod,
      this.sqrtPriceStepBps,
      this.schedulerExpirationDuration,
      this.reductionFactor,
      this.feeMarketCapSchedulerMode,
      currentPoint,
      activationPoint,
      initSqrtPrice,
      currentSqrtPrice
    );
  }
  getBaseFeeNumeratorFromExcludedFeeAmount(currentPoint, activationPoint, _tradeDirection, _excludedFeeAmount, initSqrtPrice, currentSqrtPrice) {
    return getFeeMarketCapBaseFeeNumerator(
      this.cliffFeeNumerator,
      this.numberOfPeriod,
      this.sqrtPriceStepBps,
      this.schedulerExpirationDuration,
      this.reductionFactor,
      this.feeMarketCapSchedulerMode,
      currentPoint,
      activationPoint,
      initSqrtPrice,
      currentSqrtPrice
    );
  }
  validateBaseFeeIsStatic(currentPoint, activationPoint) {
    return validateFeeMarketCapBaseFeeIsStatic(
      currentPoint,
      activationPoint,
      new BN11(this.schedulerExpirationDuration)
    );
  }
  getMinBaseFeeNumerator() {
    return getFeeMarketCapMinBaseFeeNumerator(
      this.cliffFeeNumerator,
      this.numberOfPeriod,
      this.reductionFactor,
      this.feeMarketCapSchedulerMode
    );
  }
};
function getBaseFeeHandler(rawData) {
  const data = Buffer.from(rawData);
  const modeIndex = data.readUInt8(8);
  const baseFeeMode = modeIndex;
  switch (baseFeeMode) {
    case 0 /* FeeTimeSchedulerLinear */:
    case 1 /* FeeTimeSchedulerExponential */: {
      const poolFees = decodePodAlignedFeeTimeScheduler(data);
      return new FeeTimeScheduler(
        poolFees.cliffFeeNumerator,
        poolFees.numberOfPeriod,
        poolFees.periodFrequency,
        poolFees.reductionFactor,
        poolFees.baseFeeMode
      );
    }
    case 2 /* RateLimiter */: {
      const poolFees = decodePodAlignedFeeRateLimiter(data);
      return new FeeRateLimiter(
        poolFees.cliffFeeNumerator,
        poolFees.feeIncrementBps,
        poolFees.maxFeeBps,
        poolFees.maxLimiterDuration,
        poolFees.referenceAmount
      );
    }
    case 3 /* FeeMarketCapSchedulerLinear */:
    case 4 /* FeeMarketCapSchedulerExponential */: {
      const poolFees = decodePodAlignedFeeMarketCapScheduler(data);
      return new FeeMarketCapScheduler(
        poolFees.cliffFeeNumerator,
        poolFees.numberOfPeriod,
        poolFees.sqrtPriceStepBps,
        poolFees.schedulerExpirationDuration,
        poolFees.reductionFactor,
        poolFees.baseFeeMode
      );
    }
    default:
      throw new Error("Invalid base fee mode");
  }
}

// src/math/poolFees/dynamicFee.ts
import BN12 from "bn.js";
function isDynamicFeeEnabled(dynamicFee) {
  return dynamicFee.initialized !== 0;
}
function getDynamicFeeNumerator(volatilityAccumulator, binStep, variableFeeControl) {
  const squareVfaBin = volatilityAccumulator.mul(new BN12(binStep)).pow(new BN12(2));
  const vFee = variableFeeControl.mul(squareVfaBin);
  return vFee.add(new BN12(DYNAMIC_FEE_ROUNDING_OFFSET)).div(new BN12(DYNAMIC_FEE_SCALING_FACTOR));
}

// src/math/quote.ts
import BN14 from "bn.js";

// src/math/curve.ts
import BN13 from "bn.js";
function getNextSqrtPriceFromAmountInBRoundingDown(sqrtPrice, liquidity, amount) {
  const quotient = amount.shln(SCALE_OFFSET * 2).div(liquidity);
  const result = sqrtPrice.add(quotient);
  return result;
}
function getNextSqrtPriceFromAmountOutBRoundingDown(sqrtPrice, liquidity, amount) {
  const numerator = amount.shln(SCALE_OFFSET * 2);
  const quotient = numerator.add(liquidity).subn(1).div(liquidity);
  const result = sqrtPrice.sub(quotient);
  if (result.isNeg()) {
    throw new Error("sqrt price cannot be negative");
  }
  return result;
}
function getNextSqrtPriceFromAmountInARoundingUp(sqrtPrice, liquidity, amount) {
  if (amount.isZero()) {
    return sqrtPrice;
  }
  const product = amount.mul(sqrtPrice);
  const denominator = liquidity.add(product);
  const result = mulDiv(liquidity, sqrtPrice, denominator, 0 /* Up */);
  return result;
}
function getNextSqrtPriceFromAmountOutARoundingUp(sqrtPrice, liquidity, amount) {
  if (amount.isZero()) {
    return sqrtPrice;
  }
  const product = amount.mul(sqrtPrice);
  const denominator = liquidity.sub(product);
  if (denominator.lte(new BN13(0))) {
    throw new Error("MathOverflow: denominator is zero or negative");
  }
  return mulDiv(liquidity, sqrtPrice, denominator, 0 /* Up */);
}
function getNextSqrtPriceFromOutput(sqrtPrice, liquidity, amountOut, aForB) {
  if (sqrtPrice.lte(new BN13(0))) {
    throw new Error("sqrtPrice must be greater than 0");
  }
  if (liquidity.lte(new BN13(0))) {
    throw new Error("liquidity must be greater than 0");
  }
  if (aForB) {
    return getNextSqrtPriceFromAmountOutBRoundingDown(
      sqrtPrice,
      liquidity,
      amountOut
    );
  } else {
    return getNextSqrtPriceFromAmountOutARoundingUp(
      sqrtPrice,
      liquidity,
      amountOut
    );
  }
}
function getNextSqrtPriceFromInput(sqrtPrice, liquidity, amountIn, aForB) {
  if (sqrtPrice.lte(new BN13(0))) {
    throw new Error("sqrtPrice must be greater than 0");
  }
  if (liquidity.lte(new BN13(0))) {
    throw new Error("liquidity must be greater than 0");
  }
  if (aForB) {
    return getNextSqrtPriceFromAmountInARoundingUp(
      sqrtPrice,
      liquidity,
      amountIn
    );
  } else {
    return getNextSqrtPriceFromAmountInBRoundingDown(
      sqrtPrice,
      liquidity,
      amountIn
    );
  }
}
function getAmountBFromLiquidityDelta(lowerSqrtPrice, upperSqrtPrice, liquidity, rounding) {
  const result = getDeltaAmountBUnsignedUnchecked(
    lowerSqrtPrice,
    upperSqrtPrice,
    liquidity,
    rounding
  );
  return result;
}
function getDeltaAmountBUnsignedUnchecked(lowerSqrtPrice, upperSqrtPrice, liquidity, rounding) {
  const deltaSqrtPrice = upperSqrtPrice.sub(lowerSqrtPrice);
  const prod = liquidity.mul(deltaSqrtPrice);
  const shift = SCALE_OFFSET * 2;
  if (rounding === 0 /* Up */) {
    const denominator = new BN13(1).ushln(shift);
    const result = prod.add(denominator.subn(1)).div(denominator);
    return result;
  } else {
    const result = prod.ushrn(shift);
    return result;
  }
}
function getAmountAFromLiquidityDelta(lowerSqrtPrice, upperSqrtPrice, liquidity, rounding) {
  const result = getDeltaAmountAUnsignedUnchecked(
    lowerSqrtPrice,
    upperSqrtPrice,
    liquidity,
    rounding
  );
  return result;
}
function getDeltaAmountAUnsignedUnchecked(lowerSqrtPrice, upperSqrtPrice, liquidity, rounding) {
  const numerator1 = liquidity;
  const numerator2 = upperSqrtPrice.sub(lowerSqrtPrice);
  const denominator = lowerSqrtPrice.mul(upperSqrtPrice);
  if (denominator.lte(new BN13(0))) {
    throw new Error("Denominator must be greater than zero");
  }
  const result = mulDiv(numerator1, numerator2, denominator, rounding);
  return result;
}
function getLiquidityDeltaFromAmountA(amountA, lowerSqrtPrice, upperSqrtPrice) {
  const product = amountA.mul(lowerSqrtPrice).mul(upperSqrtPrice);
  const denominator = upperSqrtPrice.sub(lowerSqrtPrice);
  return product.div(denominator);
}
function getLiquidityDeltaFromAmountB(amountB, lowerSqrtPrice, upperSqrtPrice) {
  const denominator = upperSqrtPrice.sub(lowerSqrtPrice);
  const product = amountB.shln(128);
  return product.div(denominator);
}

// src/math/quote.ts
function getSwapResultFromExactInput(poolState, amountIn, feeMode, tradeDirection, currentPoint) {
  let actualProtocolFee = new BN14(0);
  let actualTradingFee = new BN14(0);
  let actualReferralFee = new BN14(0);
  let actualPartnerFee = new BN14(0);
  const maxFeeNumerator = getMaxFeeNumerator(poolState.version);
  const tradeFeeNumerator = getTotalTradingFeeFromIncludedFeeAmount(
    poolState.poolFees,
    currentPoint,
    poolState.activationPoint,
    amountIn,
    tradeDirection,
    maxFeeNumerator,
    poolState.poolFees.initSqrtPrice,
    poolState.sqrtPrice
  );
  let actualAmountIn;
  if (feeMode.feesOnInput) {
    const { amount, tradingFee, protocolFee, partnerFee, referralFee } = getFeeOnAmount(
      poolState.poolFees,
      amountIn,
      tradeFeeNumerator,
      feeMode.hasReferral,
      hasPartner(poolState)
    );
    actualProtocolFee = protocolFee;
    actualTradingFee = tradingFee;
    actualReferralFee = referralFee;
    actualPartnerFee = partnerFee;
    actualAmountIn = amount;
  } else {
    actualAmountIn = amountIn;
  }
  let swapAmountFromInput;
  if (tradeDirection === 0 /* AtoB */) {
    swapAmountFromInput = calculateAtoBFromAmountIn(poolState, actualAmountIn);
  } else {
    swapAmountFromInput = calculateBtoAFromAmountIn(poolState, actualAmountIn);
  }
  const { outputAmount, nextSqrtPrice, amountLeft } = swapAmountFromInput;
  let actualAmountOut;
  if (feeMode.feesOnInput) {
    actualAmountOut = outputAmount;
  } else {
    const { amount, tradingFee, protocolFee, partnerFee, referralFee } = getFeeOnAmount(
      poolState.poolFees,
      outputAmount,
      tradeFeeNumerator,
      feeMode.hasReferral,
      hasPartner(poolState)
    );
    actualProtocolFee = protocolFee;
    actualTradingFee = tradingFee;
    actualReferralFee = referralFee;
    actualPartnerFee = partnerFee;
    actualAmountOut = amount;
  }
  return {
    amountLeft,
    includedFeeInputAmount: amountIn,
    excludedFeeInputAmount: actualAmountIn,
    outputAmount: actualAmountOut,
    nextSqrtPrice,
    tradingFee: actualTradingFee,
    protocolFee: actualProtocolFee,
    partnerFee: actualPartnerFee,
    referralFee: actualReferralFee
  };
}
function calculateAtoBFromAmountIn(poolState, amountIn) {
  const nextSqrtPrice = getNextSqrtPriceFromInput(
    poolState.sqrtPrice,
    poolState.liquidity,
    amountIn,
    true
  );
  if (nextSqrtPrice.lt(poolState.sqrtMinPrice)) {
    throw new Error("Price range is violated");
  }
  const outputAmount = getAmountBFromLiquidityDelta(
    nextSqrtPrice,
    poolState.sqrtPrice,
    poolState.liquidity,
    1 /* Down */
  );
  return {
    outputAmount,
    nextSqrtPrice,
    amountLeft: new BN14(0)
  };
}
function calculateBtoAFromAmountIn(poolState, amountIn) {
  const nextSqrtPrice = getNextSqrtPriceFromInput(
    poolState.sqrtPrice,
    poolState.liquidity,
    amountIn,
    false
  );
  if (nextSqrtPrice.gt(poolState.sqrtMaxPrice)) {
    throw new Error("Price range is violated");
  }
  const outputAmount = getAmountAFromLiquidityDelta(
    poolState.sqrtPrice,
    nextSqrtPrice,
    poolState.liquidity,
    1 /* Down */
  );
  return {
    outputAmount,
    nextSqrtPrice,
    amountLeft: new BN14(0)
  };
}
function getSwapResultFromPartialInput(poolState, amountIn, feeMode, tradeDirection, currentPoint) {
  let actualProtocolFee = new BN14(0);
  let actualTradingFee = new BN14(0);
  let actualReferralFee = new BN14(0);
  let actualPartnerFee = new BN14(0);
  const maxFeeNumerator = getMaxFeeNumerator(poolState.version);
  const tradeFeeNumerator = getTotalTradingFeeFromIncludedFeeAmount(
    poolState.poolFees,
    currentPoint,
    poolState.activationPoint,
    amountIn,
    tradeDirection,
    maxFeeNumerator,
    poolState.poolFees.initSqrtPrice,
    poolState.sqrtPrice
  );
  let actualAmountIn;
  if (feeMode.feesOnInput) {
    const { amount, tradingFee, protocolFee, partnerFee, referralFee } = getFeeOnAmount(
      poolState.poolFees,
      amountIn,
      tradeFeeNumerator,
      feeMode.hasReferral,
      hasPartner(poolState)
    );
    actualProtocolFee = protocolFee;
    actualTradingFee = tradingFee;
    actualReferralFee = referralFee;
    actualPartnerFee = partnerFee;
    actualAmountIn = amount;
  } else {
    actualAmountIn = amountIn;
  }
  let swapAmountFromInput;
  if (tradeDirection === 0 /* AtoB */) {
    swapAmountFromInput = calculateAtoBFromPartialAmountIn(
      poolState,
      actualAmountIn
    );
  } else {
    swapAmountFromInput = calculateBtoAFromPartialAmountIn(
      poolState,
      actualAmountIn
    );
  }
  let { amountLeft, outputAmount, nextSqrtPrice } = swapAmountFromInput;
  let includedFeeInputAmount;
  if (amountLeft.gt(new BN14(0))) {
    actualAmountIn = actualAmountIn.sub(amountLeft);
    if (feeMode.feesOnInput) {
      const tradeFeeNumerator2 = getTotalTradingFeeFromExcludedFeeAmount(
        poolState.poolFees,
        currentPoint,
        poolState.activationPoint,
        actualAmountIn,
        tradeDirection,
        maxFeeNumerator,
        poolState.poolFees.initSqrtPrice,
        poolState.sqrtPrice
      );
      const { includedFeeAmount, feeAmount } = getIncludedFeeAmount(
        tradeFeeNumerator2,
        actualAmountIn
      );
      const { tradingFee, protocolFee, referralFee, partnerFee } = splitFees(
        poolState.poolFees,
        feeAmount,
        feeMode.hasReferral,
        hasPartner(poolState)
      );
      actualProtocolFee = protocolFee;
      actualTradingFee = tradingFee;
      actualReferralFee = referralFee;
      actualPartnerFee = partnerFee;
      includedFeeInputAmount = includedFeeAmount;
    } else {
      includedFeeInputAmount = actualAmountIn;
    }
  } else {
    includedFeeInputAmount = amountIn;
  }
  let actualAmountOut;
  if (feeMode.feesOnInput) {
    actualAmountOut = outputAmount;
  } else {
    const { amount, tradingFee, protocolFee, partnerFee, referralFee } = getFeeOnAmount(
      poolState.poolFees,
      outputAmount,
      tradeFeeNumerator,
      feeMode.hasReferral,
      hasPartner(poolState)
    );
    actualProtocolFee = protocolFee;
    actualTradingFee = tradingFee;
    actualReferralFee = referralFee;
    actualPartnerFee = partnerFee;
    actualAmountOut = amount;
  }
  return {
    includedFeeInputAmount,
    excludedFeeInputAmount: actualAmountIn,
    amountLeft,
    outputAmount: actualAmountOut,
    nextSqrtPrice,
    tradingFee: actualTradingFee,
    protocolFee: actualProtocolFee,
    partnerFee: actualPartnerFee,
    referralFee: actualReferralFee
  };
}
function calculateAtoBFromPartialAmountIn(poolState, amountIn) {
  const maxAmountIn = getAmountAFromLiquidityDelta(
    poolState.sqrtMinPrice,
    poolState.sqrtPrice,
    poolState.liquidity,
    0 /* Up */
  );
  let consumedInAmount;
  let nextSqrtPrice;
  if (amountIn.gte(maxAmountIn)) {
    consumedInAmount = maxAmountIn;
    nextSqrtPrice = poolState.sqrtMinPrice;
  } else {
    nextSqrtPrice = getNextSqrtPriceFromInput(
      poolState.sqrtPrice,
      poolState.liquidity,
      amountIn,
      true
    );
    consumedInAmount = amountIn;
  }
  const outputAmount = getAmountBFromLiquidityDelta(
    nextSqrtPrice,
    poolState.sqrtPrice,
    poolState.liquidity,
    1 /* Down */
  );
  const amountLeft = amountIn.sub(consumedInAmount);
  return {
    outputAmount,
    nextSqrtPrice,
    amountLeft
  };
}
function calculateBtoAFromPartialAmountIn(poolState, amountIn) {
  const maxAmountIn = getAmountBFromLiquidityDelta(
    poolState.sqrtPrice,
    poolState.sqrtMaxPrice,
    poolState.liquidity,
    0 /* Up */
  );
  let consumedInAmount;
  let nextSqrtPrice;
  if (amountIn.gte(maxAmountIn)) {
    consumedInAmount = maxAmountIn;
    nextSqrtPrice = poolState.sqrtMaxPrice;
  } else {
    nextSqrtPrice = getNextSqrtPriceFromInput(
      poolState.sqrtPrice,
      poolState.liquidity,
      amountIn,
      false
    );
    consumedInAmount = amountIn;
  }
  const outputAmount = getAmountAFromLiquidityDelta(
    poolState.sqrtPrice,
    nextSqrtPrice,
    poolState.liquidity,
    1 /* Down */
  );
  const amountLeft = amountIn.sub(consumedInAmount);
  return {
    outputAmount,
    nextSqrtPrice,
    amountLeft
  };
}
function getSwapResultFromExactOutput(poolState, amountOut, feeMode, tradeDirection, currentPoint) {
  let actualProtocolFee = new BN14(0);
  let actualTradingFee = new BN14(0);
  let actualReferralFee = new BN14(0);
  let actualPartnerFee = new BN14(0);
  const maxFeeNumerator = getMaxFeeNumerator(poolState.version);
  let includedFeeAmountOut;
  if (feeMode.feesOnInput) {
    includedFeeAmountOut = amountOut;
  } else {
    const tradeFeeNumerator = getTotalTradingFeeFromExcludedFeeAmount(
      poolState.poolFees,
      currentPoint,
      poolState.activationPoint,
      amountOut,
      tradeDirection,
      maxFeeNumerator,
      poolState.poolFees.initSqrtPrice,
      poolState.sqrtPrice
    );
    const { includedFeeAmount, feeAmount } = getIncludedFeeAmount(
      tradeFeeNumerator,
      amountOut
    );
    const split = splitFees(
      poolState.poolFees,
      feeAmount,
      feeMode.hasReferral,
      hasPartner(poolState)
    );
    actualTradingFee = split.tradingFee;
    actualProtocolFee = split.protocolFee;
    actualReferralFee = split.referralFee;
    actualPartnerFee = split.partnerFee;
    includedFeeAmountOut = includedFeeAmount;
  }
  let swapAmountFromOutput;
  if (tradeDirection === 0 /* AtoB */) {
    swapAmountFromOutput = calculateAtoBFromAmountOut(
      poolState,
      includedFeeAmountOut
    );
  } else {
    swapAmountFromOutput = calculateBtoAFromAmountOut(
      poolState,
      includedFeeAmountOut
    );
  }
  const { inputAmount, nextSqrtPrice } = swapAmountFromOutput;
  let includedFeeInputAmount;
  if (feeMode.feesOnInput) {
    const tradeFeeNumerator = getTotalTradingFeeFromExcludedFeeAmount(
      poolState.poolFees,
      currentPoint,
      poolState.activationPoint,
      inputAmount,
      tradeDirection,
      maxFeeNumerator,
      poolState.poolFees.initSqrtPrice,
      poolState.sqrtPrice
    );
    const { includedFeeAmount, feeAmount } = getIncludedFeeAmount(
      tradeFeeNumerator,
      inputAmount
    );
    const split = splitFees(
      poolState.poolFees,
      feeAmount,
      feeMode.hasReferral,
      hasPartner(poolState)
    );
    actualTradingFee = split.tradingFee;
    actualProtocolFee = split.protocolFee;
    actualReferralFee = split.referralFee;
    actualPartnerFee = split.partnerFee;
    includedFeeInputAmount = includedFeeAmount;
  } else {
    includedFeeInputAmount = inputAmount;
  }
  return {
    amountLeft: new BN14(0),
    includedFeeInputAmount,
    excludedFeeInputAmount: inputAmount,
    outputAmount: amountOut,
    nextSqrtPrice,
    tradingFee: actualTradingFee,
    protocolFee: actualProtocolFee,
    partnerFee: actualPartnerFee,
    referralFee: actualReferralFee
  };
}
function calculateAtoBFromAmountOut(poolState, amountOut) {
  const nextSqrtPrice = getNextSqrtPriceFromOutput(
    poolState.sqrtPrice,
    poolState.liquidity,
    amountOut,
    true
  );
  if (nextSqrtPrice.lt(poolState.sqrtMinPrice)) {
    throw new Error("Price Range Violation");
  }
  const inputAmount = getAmountAFromLiquidityDelta(
    nextSqrtPrice,
    poolState.sqrtPrice,
    poolState.liquidity,
    0 /* Up */
  );
  return {
    inputAmount,
    nextSqrtPrice
  };
}
function calculateBtoAFromAmountOut(poolState, amountOut) {
  const nextSqrtPrice = getNextSqrtPriceFromOutput(
    poolState.sqrtPrice,
    poolState.liquidity,
    amountOut,
    false
  );
  if (nextSqrtPrice.gt(poolState.sqrtMaxPrice)) {
    throw new Error("Price Range Violation");
  }
  const inputAmount = getAmountBFromLiquidityDelta(
    poolState.sqrtPrice,
    nextSqrtPrice,
    poolState.liquidity,
    0 /* Up */
  );
  return {
    inputAmount,
    nextSqrtPrice
  };
}
function swapQuoteExactInput(pool, currentPoint, amountIn, slippage, aToB, hasReferral, tokenADecimal, tokenBDecimal, inputTokenInfo, outputTokenInfo) {
  if (amountIn.lte(new BN14(0))) {
    throw new Error("Amount in must be greater than 0");
  }
  if (!isSwapEnabled(pool, currentPoint)) {
    throw new Error("Swap is disabled");
  }
  const tradeDirection = aToB ? 0 /* AtoB */ : 1 /* BtoA */;
  const feeMode = getFeeMode(pool.collectFeeMode, tradeDirection, hasReferral);
  let actualAmountIn = amountIn;
  if (inputTokenInfo) {
    actualAmountIn = calculateTransferFeeExcludedAmount(
      amountIn,
      inputTokenInfo.mint,
      inputTokenInfo.currentEpoch
    ).amount;
  }
  const swapResult = getSwapResultFromExactInput(
    pool,
    actualAmountIn,
    feeMode,
    tradeDirection,
    currentPoint
  );
  let actualAmountOut = swapResult.outputAmount;
  if (outputTokenInfo) {
    actualAmountOut = calculateTransferFeeExcludedAmount(
      swapResult.outputAmount,
      outputTokenInfo.mint,
      outputTokenInfo.currentEpoch
    ).amount;
  }
  const minimumAmountOut = getAmountWithSlippage(
    actualAmountOut,
    slippage,
    0 /* ExactIn */
  );
  const priceImpact = getPriceImpact(
    actualAmountIn,
    actualAmountOut,
    pool.sqrtPrice,
    aToB,
    tokenADecimal,
    tokenBDecimal
  );
  return __spreadProps(__spreadValues({}, swapResult), {
    minimumAmountOut,
    priceImpact
  });
}
function swapQuoteExactOutput(pool, currentPoint, amountOut, slippage, aToB, hasReferral, tokenADecimal, tokenBDecimal, inputTokenInfo, outputTokenInfo) {
  if (amountOut.lte(new BN14(0))) {
    throw new Error("Amount out must be greater than 0");
  }
  if (!isSwapEnabled(pool, currentPoint)) {
    throw new Error("Swap is disabled");
  }
  const tradeDirection = aToB ? 0 /* AtoB */ : 1 /* BtoA */;
  const feeMode = getFeeMode(pool.collectFeeMode, tradeDirection, hasReferral);
  let actualAmountOut = amountOut;
  if (outputTokenInfo) {
    actualAmountOut = calculateTransferFeeIncludedAmount(
      amountOut,
      outputTokenInfo.mint,
      outputTokenInfo.currentEpoch
    ).amount;
  }
  const swapResult = getSwapResultFromExactOutput(
    pool,
    actualAmountOut,
    feeMode,
    tradeDirection,
    currentPoint
  );
  let actualAmountIn = swapResult.includedFeeInputAmount;
  if (inputTokenInfo) {
    actualAmountIn = calculateTransferFeeIncludedAmount(
      swapResult.includedFeeInputAmount,
      inputTokenInfo.mint,
      inputTokenInfo.currentEpoch
    ).amount;
  }
  const maximumAmountIn = getAmountWithSlippage(
    actualAmountIn,
    slippage,
    2 /* ExactOut */
  );
  const priceImpact = getPriceImpact(
    actualAmountIn,
    actualAmountOut,
    pool.sqrtPrice,
    aToB,
    tokenADecimal,
    tokenBDecimal
  );
  return __spreadProps(__spreadValues({}, swapResult), {
    maximumAmountIn,
    priceImpact
  });
}
function swapQuotePartialInput(pool, currentPoint, amountIn, slippage, aToB, hasReferral, tokenADecimal, tokenBDecimal, inputTokenInfo, outputTokenInfo) {
  if (amountIn.lte(new BN14(0))) {
    throw new Error("Amount in must be greater than 0");
  }
  if (!isSwapEnabled(pool, currentPoint)) {
    throw new Error("Swap is disabled");
  }
  const tradeDirection = aToB ? 0 /* AtoB */ : 1 /* BtoA */;
  const feeMode = getFeeMode(pool.collectFeeMode, tradeDirection, hasReferral);
  let actualAmountIn = amountIn;
  if (inputTokenInfo) {
    actualAmountIn = calculateTransferFeeExcludedAmount(
      amountIn,
      inputTokenInfo.mint,
      inputTokenInfo.currentEpoch
    ).amount;
  }
  const swapResult = getSwapResultFromPartialInput(
    pool,
    actualAmountIn,
    feeMode,
    tradeDirection,
    currentPoint
  );
  let actualAmountOut = swapResult.outputAmount;
  if (outputTokenInfo) {
    actualAmountOut = calculateTransferFeeExcludedAmount(
      swapResult.outputAmount,
      outputTokenInfo.mint,
      outputTokenInfo.currentEpoch
    ).amount;
  }
  const minimumAmountOut = getAmountWithSlippage(
    actualAmountOut,
    slippage,
    1 /* PartialFill */
  );
  const priceImpact = getPriceImpact(
    actualAmountIn,
    actualAmountOut,
    pool.sqrtPrice,
    aToB,
    tokenADecimal,
    tokenBDecimal
  );
  return __spreadProps(__spreadValues({}, swapResult), {
    minimumAmountOut,
    priceImpact
  });
}

// src/math/priceMath.ts
import { BN as BN15 } from "@coral-xyz/anchor";
import Decimal3 from "decimal.js";
function calculateInitSqrtPrice(tokenAAmount, tokenBAmount, minSqrtPrice, maxSqrtPrice) {
  if (tokenAAmount.isZero() || tokenBAmount.isZero()) {
    throw new Error("Amount cannot be zero");
  }
  const amountADecimal = new Decimal3(tokenAAmount.toString());
  const amountBDecimal = new Decimal3(tokenBAmount.toString());
  const minSqrtPriceDecimal = new Decimal3(minSqrtPrice.toString()).div(
    Decimal3.pow(2, 64)
  );
  const maxSqrtPriceDecimal = new Decimal3(maxSqrtPrice.toString()).div(
    Decimal3.pow(2, 64)
  );
  const x = new Decimal3(1).div(maxSqrtPriceDecimal);
  const y = amountBDecimal.div(amountADecimal);
  const xy = x.mul(y);
  const paMinusXY = minSqrtPriceDecimal.sub(xy);
  const xyMinusPa = xy.sub(minSqrtPriceDecimal);
  const fourY = new Decimal3(4).mul(y);
  const discriminant = xyMinusPa.mul(xyMinusPa).add(fourY);
  const sqrtDiscriminant = discriminant.sqrt();
  const result = paMinusXY.add(sqrtDiscriminant).div(new Decimal3(2)).mul(Decimal3.pow(2, 64));
  return new BN15(result.floor().toFixed());
}

// src/helpers/validation.ts
function validateFeeTimeScheduler(numberOfPeriod, periodFrequency, reductionFactor, cliffFeeNumerator, baseFeeMode, poolVersion) {
  if (!periodFrequency.eq(new BN16(0)) || numberOfPeriod !== 0 || !reductionFactor.eq(new BN16(0))) {
    if (numberOfPeriod === 0 || periodFrequency.eq(new BN16(0)) || reductionFactor.eq(new BN16(0))) {
      throw new Error("PoolError::InvalidFeeTimeScheduler");
    }
  }
  const minFeeNumerator = getFeeTimeMinBaseFeeNumerator(
    cliffFeeNumerator,
    numberOfPeriod,
    reductionFactor,
    baseFeeMode
  );
  const maxFeeNumerator = getMaxBaseFeeNumerator(cliffFeeNumerator);
  validateFeeFraction(minFeeNumerator, new BN16(FEE_DENOMINATOR));
  validateFeeFraction(maxFeeNumerator, new BN16(FEE_DENOMINATOR));
  if (minFeeNumerator.lt(new BN16(MIN_FEE_NUMERATOR)) || maxFeeNumerator.gt(getMaxFeeNumerator(poolVersion))) {
    throw new Error("PoolError::ExceedMaxFeeBps");
  }
  return true;
}
function validateFeeTimeSchedulerBaseFeeIsStatic(currentPoint, activationPoint, numberOfPeriod, periodFrequency) {
  const schedulerExpirationPoint = activationPoint.add(
    numberOfPeriod.mul(periodFrequency)
  );
  return currentPoint.gt(schedulerExpirationPoint);
}
function validateFeeMarketCapScheduler(cliffFeeNumerator, numberOfPeriod, sqrtPriceStepBps, reductionFactor, schedulerExpirationDuration, feeMarketCapSchedulerMode, poolVersion) {
  if (reductionFactor.lte(new BN16(0))) {
    throw new Error("PoolError::InvalidFeeMarketCapScheduler");
  }
  if (sqrtPriceStepBps.lte(new BN16(0))) {
    throw new Error("PoolError::InvalidFeeMarketCapScheduler");
  }
  if (schedulerExpirationDuration.lte(new BN16(0))) {
    throw new Error("PoolError::InvalidFeeMarketCapScheduler");
  }
  if (numberOfPeriod <= 0) {
    throw new Error("PoolError::InvalidFeeMarketCapScheduler");
  }
  const minFeeNumerator = getFeeMarketCapMinBaseFeeNumerator(
    cliffFeeNumerator,
    numberOfPeriod,
    reductionFactor,
    feeMarketCapSchedulerMode
  );
  const maxFeeNumerator = cliffFeeNumerator;
  validateFeeFraction(minFeeNumerator, new BN16(FEE_DENOMINATOR));
  validateFeeFraction(maxFeeNumerator, new BN16(FEE_DENOMINATOR));
  const maxAllowedFeeNumerator = getMaxFeeNumerator(poolVersion);
  if (minFeeNumerator.lt(new BN16(MIN_FEE_NUMERATOR)) || maxFeeNumerator.gt(maxAllowedFeeNumerator)) {
    throw new Error("PoolError::ExceedMaxFeeBps");
  }
  return true;
}
function validateFeeMarketCapBaseFeeIsStatic(currentPoint, activationPoint, schedulerExpirationDuration) {
  const schedulerExpirationPoint = activationPoint.add(
    schedulerExpirationDuration
  );
  return currentPoint.gt(schedulerExpirationPoint);
}
function validateFeeRateLimiter(cliffFeeNumerator, feeIncrementBps, maxFeeBps, maxLimiterDuration, referenceAmount, collectFeeMode, activationType, poolVersion) {
  if (collectFeeMode !== 1 /* OnlyB */) {
    return false;
  }
  const maxFeeNumeratorFromBps = toNumerator(
    new BN16(maxFeeBps),
    new BN16(FEE_DENOMINATOR)
  );
  if (cliffFeeNumerator.lt(new BN16(MIN_FEE_NUMERATOR)) || cliffFeeNumerator.gt(maxFeeNumeratorFromBps)) {
    return false;
  }
  if (isZeroRateLimiter(
    referenceAmount,
    maxLimiterDuration,
    maxFeeBps,
    feeIncrementBps
  )) {
    return true;
  }
  if (isNonZeroRateLimiter(
    referenceAmount,
    maxLimiterDuration,
    maxFeeBps,
    feeIncrementBps
  )) {
    return false;
  }
  const maxLimiterDurationLimit = activationType === 0 /* Slot */ ? new BN16(MAX_RATE_LIMITER_DURATION_IN_SLOTS) : new BN16(MAX_RATE_LIMITER_DURATION_IN_SECONDS);
  if (new BN16(maxLimiterDuration).gt(maxLimiterDurationLimit)) {
    return false;
  }
  const feeIncrementNumerator = toNumerator(
    new BN16(feeIncrementBps),
    new BN16(FEE_DENOMINATOR)
  );
  if (feeIncrementNumerator.gte(new BN16(FEE_DENOMINATOR))) {
    return false;
  }
  if (maxFeeBps > getMaxFeeBps(poolVersion)) {
    return false;
  }
  const minFeeNumerator = getFeeNumeratorFromIncludedFeeAmount(
    new BN16(0),
    cliffFeeNumerator,
    referenceAmount,
    maxFeeBps,
    feeIncrementBps
  );
  const maxFeeNumeratorFromAmount = getFeeNumeratorFromIncludedFeeAmount(
    new BN16(Number.MAX_SAFE_INTEGER),
    cliffFeeNumerator,
    referenceAmount,
    maxFeeBps,
    feeIncrementBps
  );
  if (minFeeNumerator.lt(new BN16(MIN_FEE_NUMERATOR)) || maxFeeNumeratorFromAmount.gt(getMaxFeeNumerator(poolVersion))) {
    return false;
  }
  return true;
}
function validateFeeRateLimiterBaseFeeIsStatic(currentPoint, activationPoint, maxLimiterDuration, referenceAmount, maxFeeBps, feeIncrementBps) {
  if (isZeroRateLimiter(
    referenceAmount,
    maxLimiterDuration,
    maxFeeBps,
    feeIncrementBps
  )) {
    return true;
  }
  const lastEffectiveRateLimiterPoint = activationPoint.add(
    new BN16(maxLimiterDuration)
  );
  return currentPoint.gt(lastEffectiveRateLimiterPoint);
}
function validateFeeFraction(numerator, denominator) {
  if (denominator.isZero() || numerator.gte(denominator)) {
    throw new Error(
      "InvalidFee: Fee numerator must be less than denominator and denominator must be non-zero"
    );
  }
}

// src/helpers/common.ts
import { PublicKey as PublicKey6 } from "@solana/web3.js";
import BN18 from "bn.js";
import Decimal4 from "decimal.js";

// src/helpers/feeCodec.ts
import BN17 from "bn.js";
import { BorshCoder } from "@coral-xyz/anchor";
var cpAmmCoder = new BorshCoder(cp_amm_default);
function encodeFeeTimeSchedulerParams(cliffFeeNumerator, numberOfPeriod, periodFrequency, reductionFactor, baseFeeMode) {
  const feeTimeScheduler = {
    cliff_fee_numerator: new BN17(cliffFeeNumerator.toString()),
    number_of_period: numberOfPeriod,
    period_frequency: new BN17(periodFrequency.toString()),
    reduction_factor: new BN17(reductionFactor.toString()),
    base_fee_mode: baseFeeMode,
    padding: FEE_PADDING
  };
  return cpAmmCoder.types.encode("BorshFeeTimeScheduler", feeTimeScheduler);
}
function decodeFeeTimeSchedulerParams(data) {
  const decoded = cpAmmCoder.types.decode("BorshFeeTimeScheduler", data);
  return {
    cliffFeeNumerator: decoded.cliff_fee_numerator,
    numberOfPeriod: decoded.number_of_period,
    periodFrequency: decoded.period_frequency,
    reductionFactor: decoded.reduction_factor,
    baseFeeMode: decoded.base_fee_mode,
    padding: decoded.padding
  };
}
function decodePodAlignedFeeTimeScheduler(data) {
  const decoded = cpAmmCoder.types.decode("PodAlignedFeeTimeScheduler", data);
  return {
    cliffFeeNumerator: decoded.cliff_fee_numerator,
    numberOfPeriod: decoded.number_of_period,
    periodFrequency: decoded.period_frequency,
    reductionFactor: decoded.reduction_factor,
    baseFeeMode: decoded.base_fee_mode,
    padding: decoded.padding
  };
}
function encodeFeeMarketCapSchedulerParams(cliffFeeNumerator, numberOfPeriod, sqrtPriceStepBps, schedulerExpirationDuration, reductionFactor, baseFeeMode) {
  const feeMarketCapScheduler = {
    cliff_fee_numerator: new BN17(cliffFeeNumerator.toString()),
    number_of_period: numberOfPeriod,
    sqrt_price_step_bps: sqrtPriceStepBps,
    scheduler_expiration_duration: schedulerExpirationDuration,
    reduction_factor: new BN17(reductionFactor.toString()),
    base_fee_mode: baseFeeMode,
    padding: FEE_PADDING
  };
  return cpAmmCoder.types.encode(
    "BorshFeeMarketCapScheduler",
    feeMarketCapScheduler
  );
}
function decodeFeeMarketCapSchedulerParams(data) {
  const decoded = cpAmmCoder.types.decode("BorshFeeMarketCapScheduler", data);
  return {
    cliffFeeNumerator: decoded.cliff_fee_numerator,
    numberOfPeriod: decoded.number_of_period,
    sqrtPriceStepBps: decoded.sqrt_price_step_bps,
    schedulerExpirationDuration: decoded.scheduler_expiration_duration,
    reductionFactor: decoded.reduction_factor,
    baseFeeMode: decoded.base_fee_mode,
    padding: decoded.padding
  };
}
function decodePodAlignedFeeMarketCapScheduler(data) {
  const decoded = cpAmmCoder.types.decode(
    "PodAlignedFeeMarketCapScheduler",
    data
  );
  return {
    cliffFeeNumerator: decoded.cliff_fee_numerator,
    numberOfPeriod: decoded.number_of_period,
    sqrtPriceStepBps: decoded.sqrt_price_step_bps,
    schedulerExpirationDuration: decoded.scheduler_expiration_duration,
    reductionFactor: decoded.reduction_factor,
    baseFeeMode: decoded.base_fee_mode,
    padding: decoded.padding
  };
}
function encodeFeeRateLimiterParams(cliffFeeNumerator, feeIncrementBps, maxLimiterDuration, maxFeeBps, referenceAmount) {
  const feeRateLimiter = {
    cliff_fee_numerator: new BN17(cliffFeeNumerator.toString()),
    fee_increment_bps: feeIncrementBps,
    max_limiter_duration: maxLimiterDuration,
    max_fee_bps: maxFeeBps,
    reference_amount: new BN17(referenceAmount.toString()),
    base_fee_mode: 2 /* RateLimiter */,
    padding: FEE_PADDING
  };
  return cpAmmCoder.types.encode("BorshFeeRateLimiter", feeRateLimiter);
}
function decodeFeeRateLimiterParams(data) {
  const decoded = cpAmmCoder.types.decode("BorshFeeRateLimiter", data);
  return {
    cliffFeeNumerator: decoded.cliff_fee_numerator,
    feeIncrementBps: decoded.fee_increment_bps,
    maxLimiterDuration: decoded.max_limiter_duration,
    maxFeeBps: decoded.max_fee_bps,
    referenceAmount: decoded.reference_amount,
    baseFeeMode: decoded.base_fee_mode,
    padding: decoded.padding
  };
}
function decodePodAlignedFeeRateLimiter(data) {
  const decoded = cpAmmCoder.types.decode("PodAlignedFeeRateLimiter", data);
  return {
    cliffFeeNumerator: decoded.cliff_fee_numerator,
    feeIncrementBps: decoded.fee_increment_bps,
    maxLimiterDuration: decoded.max_limiter_duration,
    maxFeeBps: decoded.max_fee_bps,
    referenceAmount: decoded.reference_amount,
    baseFeeMode: decoded.base_fee_mode,
    padding: decoded.padding
  };
}

// src/helpers/common.ts
function hasPartner(poolState) {
  return !poolState.partner.equals(PublicKey6.default);
}
function getCurrentPoint(connection, activationType) {
  return __async(this, null, function* () {
    const currentSlot = yield connection.getSlot();
    if (activationType === 0 /* Slot */) {
      return new BN18(currentSlot);
    } else {
      const currentTime = yield connection.getBlockTime(currentSlot);
      return new BN18(currentTime);
    }
  });
}
function isSwapEnabled(pool, currentPoint) {
  return pool.poolStatus === 0 /* Enable */ && currentPoint.gte(pool.activationPoint);
}
function convertToFeeSchedulerSecondFactor(value) {
  return Array.from(value.toArrayLike(Buffer, "le", 8));
}
function parseFeeSchedulerSecondFactor(secondFactor) {
  return new BN18(Buffer.from(secondFactor), "le");
}
function convertToRateLimiterSecondFactor(maxLimiterDuration, maxFeeBps) {
  const buffer1 = maxLimiterDuration.toArrayLike(Buffer, "le", 4);
  const buffer2 = maxFeeBps.toArrayLike(Buffer, "le", 4);
  const buffer = Buffer.concat([buffer1, buffer2]);
  return Array.from(buffer);
}
function parseRateLimiterSecondFactor(secondFactor) {
  const buffer = Buffer.from(secondFactor);
  return {
    maxLimiterDuration: buffer.readUInt32LE(0),
    maxFeeBps: buffer.readUInt32LE(4)
  };
}
function bpsToFeeNumerator(bps) {
  return new BN18(bps * FEE_DENOMINATOR).divn(BASIS_POINT_MAX);
}
function feeNumeratorToBps(feeNumerator) {
  return feeNumerator.muln(BASIS_POINT_MAX).div(new BN18(FEE_DENOMINATOR)).toNumber();
}
function convertToLamports(amount, tokenDecimal) {
  const valueInLamports = new Decimal4(amount).mul(
    Decimal4.pow(10, tokenDecimal)
  );
  return fromDecimalToBN(valueInLamports);
}
function fromDecimalToBN(value) {
  return new BN18(value.floor().toFixed());
}
function getFeeTimeSchedulerParams(startingBaseFeeBps, endingBaseFeeBps, baseFeeMode, numberOfPeriod, totalDuration) {
  if (startingBaseFeeBps == endingBaseFeeBps) {
    if (numberOfPeriod != 0 || totalDuration != 0) {
      throw new Error("numberOfPeriod and totalDuration must both be zero");
    }
    const data2 = encodeFeeTimeSchedulerParams(
      bpsToFeeNumerator(startingBaseFeeBps),
      0,
      new BN18(0),
      new BN18(0),
      0 /* FeeTimeSchedulerLinear */
    );
    return {
      data: Array.from(data2)
    };
  }
  if (numberOfPeriod <= 0) {
    throw new Error("Total periods must be greater than zero");
  }
  const poolMaxFeeBps = getMaxFeeBps(CURRENT_POOL_VERSION);
  if (startingBaseFeeBps > poolMaxFeeBps) {
    throw new Error(
      `startingBaseFeeBps (${startingBaseFeeBps} bps) exceeds maximum allowed value of ${poolMaxFeeBps} bps`
    );
  }
  if (endingBaseFeeBps > startingBaseFeeBps) {
    throw new Error(
      "endingBaseFeeBps bps must be less than or equal to startingBaseFeeBps bps"
    );
  }
  if (numberOfPeriod == 0 || totalDuration == 0) {
    throw new Error(
      "numberOfPeriod and totalDuration must both greater than zero"
    );
  }
  const maxBaseFeeNumerator = bpsToFeeNumerator(startingBaseFeeBps);
  const minBaseFeeNumerator = bpsToFeeNumerator(endingBaseFeeBps);
  const periodFrequency = new BN18(totalDuration / numberOfPeriod);
  let reductionFactor;
  if (baseFeeMode == 0 /* FeeTimeSchedulerLinear */) {
    const totalReduction = maxBaseFeeNumerator.sub(minBaseFeeNumerator);
    reductionFactor = totalReduction.divn(numberOfPeriod);
  } else {
    const ratio = minBaseFeeNumerator.toNumber() / maxBaseFeeNumerator.toNumber();
    const decayBase = Math.pow(ratio, 1 / numberOfPeriod);
    reductionFactor = new BN18(BASIS_POINT_MAX * (1 - decayBase));
  }
  const data = encodeFeeTimeSchedulerParams(
    maxBaseFeeNumerator,
    numberOfPeriod,
    periodFrequency,
    reductionFactor,
    baseFeeMode
  );
  return {
    data: Array.from(data)
  };
}
function getFeeMarketCapSchedulerParams(startingBaseFeeBps, endingBaseFeeBps, baseFeeMode, numberOfPeriod, sqrtPriceStepBps, schedulerExpirationDuration) {
  if (numberOfPeriod <= 0) {
    throw new Error("Total periods must be greater than zero");
  }
  const poolMaxFeeBps = getMaxFeeBps(CURRENT_POOL_VERSION);
  if (startingBaseFeeBps <= endingBaseFeeBps) {
    throw new Error(
      `startingBaseFeeBps (${startingBaseFeeBps} bps) must be greater than endingBaseFeeBps (${endingBaseFeeBps} bps)`
    );
  }
  if (startingBaseFeeBps > poolMaxFeeBps) {
    throw new Error(
      `startingBaseFeeBps (${startingBaseFeeBps} bps) exceeds maximum allowed value of ${poolMaxFeeBps} bps`
    );
  }
  if (numberOfPeriod == 0 || sqrtPriceStepBps == 0 || schedulerExpirationDuration == 0) {
    throw new Error(
      "numberOfPeriod, sqrtPriceStepBps, and schedulerExpirationDuration must be greater than zero"
    );
  }
  const maxBaseFeeNumerator = bpsToFeeNumerator(startingBaseFeeBps);
  const minBaseFeeNumerator = bpsToFeeNumerator(endingBaseFeeBps);
  let reductionFactor;
  if (baseFeeMode == 3 /* FeeMarketCapSchedulerLinear */) {
    const totalReduction = maxBaseFeeNumerator.sub(minBaseFeeNumerator);
    reductionFactor = totalReduction.divn(numberOfPeriod);
  } else {
    const ratio = minBaseFeeNumerator.toNumber() / maxBaseFeeNumerator.toNumber();
    const decayBase = Math.pow(ratio, 1 / numberOfPeriod);
    reductionFactor = new BN18(BASIS_POINT_MAX * (1 - decayBase));
  }
  const data = encodeFeeMarketCapSchedulerParams(
    maxBaseFeeNumerator,
    numberOfPeriod,
    sqrtPriceStepBps,
    schedulerExpirationDuration,
    reductionFactor,
    baseFeeMode
  );
  return {
    data: Array.from(data)
  };
}
function getRateLimiterParams(baseFeeBps, feeIncrementBps, referenceAmount, maxLimiterDuration, maxFeeBps, tokenBDecimal, activationType) {
  const cliffFeeNumerator = bpsToFeeNumerator(baseFeeBps);
  const feeIncrementNumerator = bpsToFeeNumerator(feeIncrementBps);
  if (baseFeeBps <= 0 || feeIncrementBps <= 0 || referenceAmount <= 0 || maxLimiterDuration <= 0) {
    throw new Error("All rate limiter parameters must be greater than zero");
  }
  const poolMaxFeeBps = getMaxFeeBps(CURRENT_POOL_VERSION);
  const poolMaxFeeNumerator = getMaxFeeNumerator(CURRENT_POOL_VERSION);
  if (baseFeeBps > poolMaxFeeBps) {
    throw new Error(
      `Base fee (${baseFeeBps} bps) exceeds maximum allowed value of ${poolMaxFeeBps} bps`
    );
  }
  if (feeIncrementBps > poolMaxFeeBps) {
    throw new Error(
      `Fee increment (${feeIncrementBps} bps) exceeds maximum allowed value of ${poolMaxFeeBps} bps`
    );
  }
  if (feeIncrementNumerator.gte(new BN18(FEE_DENOMINATOR))) {
    throw new Error(
      "Fee increment numerator must be less than FEE_DENOMINATOR"
    );
  }
  if (maxFeeBps > poolMaxFeeBps) {
    throw new Error(
      `Max fee (${maxFeeBps} bps) exceeds maximum allowed value of ${poolMaxFeeBps} bps for PoolVersion V${CURRENT_POOL_VERSION}`
    );
  }
  const deltaNumerator = new BN18(poolMaxFeeNumerator).sub(cliffFeeNumerator);
  const maxIndex = deltaNumerator.div(feeIncrementNumerator);
  if (maxIndex.lt(new BN18(1))) {
    throw new Error("Fee increment is too large for the given base fee");
  }
  if (cliffFeeNumerator.lt(new BN18(MIN_FEE_NUMERATOR)) || cliffFeeNumerator.gt(new BN18(poolMaxFeeNumerator))) {
    throw new Error("Base fee must be between 0.01% and 99%");
  }
  const maxDuration = activationType === 0 /* Slot */ ? MAX_RATE_LIMITER_DURATION_IN_SLOTS : MAX_RATE_LIMITER_DURATION_IN_SECONDS;
  if (maxLimiterDuration > maxDuration) {
    throw new Error(
      `Max duration exceeds maximum allowed value of ${maxDuration}`
    );
  }
  const referenceAmountInLamports = convertToLamports(
    referenceAmount,
    tokenBDecimal
  );
  const data = encodeFeeRateLimiterParams(
    cliffFeeNumerator,
    feeIncrementBps,
    maxLimiterDuration,
    maxFeeBps,
    referenceAmountInLamports
  );
  return {
    data: Array.from(data)
  };
}
function getBaseFeeParams(baseFeeParams, tokenBDecimal, activationType) {
  switch (baseFeeParams.baseFeeMode) {
    case 0 /* FeeTimeSchedulerLinear */:
    case 1 /* FeeTimeSchedulerExponential */: {
      if (!baseFeeParams.feeTimeSchedulerParam) {
        throw new Error(
          "Fee scheduler parameters are required for FeeTimeScheduler mode"
        );
      }
      const { startingFeeBps, endingFeeBps, numberOfPeriod, totalDuration } = baseFeeParams.feeTimeSchedulerParam;
      return getFeeTimeSchedulerParams(
        startingFeeBps,
        endingFeeBps,
        baseFeeParams.baseFeeMode,
        numberOfPeriod,
        totalDuration
      );
    }
    case 2 /* RateLimiter */: {
      if (!baseFeeParams.rateLimiterParam) {
        throw new Error(
          "Rate limiter parameters are required for RateLimiter mode"
        );
      }
      const {
        baseFeeBps,
        feeIncrementBps,
        referenceAmount,
        maxLimiterDuration,
        maxFeeBps
      } = baseFeeParams.rateLimiterParam;
      return getRateLimiterParams(
        baseFeeBps,
        feeIncrementBps,
        referenceAmount,
        maxLimiterDuration,
        maxFeeBps,
        tokenBDecimal,
        activationType
      );
    }
    case 3 /* FeeMarketCapSchedulerLinear */:
    case 4 /* FeeMarketCapSchedulerExponential */: {
      if (!baseFeeParams.feeMarketCapSchedulerParam) {
        throw new Error(
          "Fee scheduler parameters are required for FeeMarketCapScheduler mode"
        );
      }
      const {
        startingFeeBps,
        endingFeeBps,
        numberOfPeriod,
        sqrtPriceStepBps,
        schedulerExpirationDuration
      } = baseFeeParams.feeMarketCapSchedulerParam;
      return getFeeMarketCapSchedulerParams(
        startingFeeBps,
        endingFeeBps,
        baseFeeParams.baseFeeMode,
        numberOfPeriod,
        sqrtPriceStepBps,
        schedulerExpirationDuration
      );
    }
    default:
      throw new Error("Invalid base fee mode");
  }
}
function getDynamicFeeParams(baseFeeBps, maxPriceChangeBps = MAX_PRICE_CHANGE_BPS_DEFAULT) {
  if (maxPriceChangeBps > MAX_PRICE_CHANGE_BPS_DEFAULT) {
    throw new Error(
      `maxPriceChangeBps (${maxPriceChangeBps} bps) must be less than or equal to ${MAX_PRICE_CHANGE_BPS_DEFAULT}`
    );
  }
  const priceRatio = maxPriceChangeBps / BASIS_POINT_MAX + 1;
  const sqrtPriceRatioQ64 = new BN18(
    Decimal4.sqrt(priceRatio.toString()).mul(Decimal4.pow(2, 64)).floor().toFixed()
  );
  const deltaBinId = sqrtPriceRatioQ64.sub(ONE_Q64).div(BIN_STEP_BPS_U128_DEFAULT).muln(2);
  const maxVolatilityAccumulator = new BN18(deltaBinId.muln(BASIS_POINT_MAX));
  const squareVfaBin = maxVolatilityAccumulator.mul(new BN18(BIN_STEP_BPS_DEFAULT)).pow(new BN18(2));
  const baseFeeNumerator = new BN18(bpsToFeeNumerator(baseFeeBps));
  const maxDynamicFeeNumerator = baseFeeNumerator.muln(20).divn(100);
  const vFee = maxDynamicFeeNumerator.mul(new BN18(1e11)).sub(new BN18(99999999999));
  const variableFeeControl = vFee.div(squareVfaBin);
  return {
    binStep: BIN_STEP_BPS_DEFAULT,
    binStepU128: BIN_STEP_BPS_U128_DEFAULT,
    filterPeriod: DYNAMIC_FEE_FILTER_PERIOD_DEFAULT,
    decayPeriod: DYNAMIC_FEE_DECAY_PERIOD_DEFAULT,
    reductionFactor: DYNAMIC_FEE_REDUCTION_FACTOR_DEFAULT,
    maxVolatilityAccumulator: maxVolatilityAccumulator.toNumber(),
    variableFeeControl: variableFeeControl.toNumber()
  };
}

// src/CpAmm.ts
import BN19, { min as min2, max } from "bn.js";
var CpAmm = class {
  constructor(connection) {
    this._program = new Program(cp_amm_default, {
      connection
    });
    this.poolAuthority = derivePoolAuthority();
  }
  //// ANCHOR: PRIVATE FUNCTIONS //////
  /**
   * Prepares token accounts for a transaction by retrieving or creating associated token accounts.
   * @private
   * @param {PublicKey} owner - The owner of the token accounts
   * @param {PublicKey} tokenAMint - Mint address of token A
   * @param {PublicKey} tokenBMint - Mint address of token B
   * @param {PublicKey} tokenAProgram - Program ID for token A (Token or Token2022)
   * @param {PublicKey} tokenBProgram - Program ID for token B (Token or Token2022)
   * @returns {Promise<{tokenAAta: PublicKey, tokenBAta: PublicKey, instructions: TransactionInstruction[]}>}
   *          The token account addresses and any instructions needed to create them
   */
  prepareTokenAccounts(params) {
    return __async(this, null, function* () {
      const {
        payer,
        tokenAOwner,
        tokenBOwner,
        tokenAMint,
        tokenBMint,
        tokenAProgram,
        tokenBProgram
      } = params;
      const instructions = [];
      const [
        { ataPubkey: tokenAAta, ix: createInputTokenAccountIx },
        { ataPubkey: tokenBAta, ix: createOutputTokenAccountIx }
      ] = yield Promise.all([
        getOrCreateATAInstruction(
          this._program.provider.connection,
          tokenAMint,
          tokenAOwner,
          payer,
          true,
          tokenAProgram
        ),
        getOrCreateATAInstruction(
          this._program.provider.connection,
          tokenBMint,
          tokenBOwner,
          payer,
          true,
          tokenBProgram
        )
      ]);
      createInputTokenAccountIx && instructions.push(createInputTokenAccountIx);
      createOutputTokenAccountIx && instructions.push(createOutputTokenAccountIx);
      return { tokenAAta, tokenBAta, instructions };
    });
  }
  /**
   * Derives token badge account metadata
   * @param tokenAMint - Public key of token A mint
   * @param tokenBMint - Public key of token B mint
   * @returns Array of account metadata for token badges
   */
  getTokenBadgeAccounts(tokenAMint, tokenBMint) {
    return [
      {
        pubkey: deriveTokenBadgeAddress(tokenAMint),
        isWritable: false,
        isSigner: false
      },
      {
        pubkey: deriveTokenBadgeAddress(tokenBMint),
        isWritable: false,
        isSigner: false
      }
    ];
  }
  /**
   * Builds an instruction to add liquidity to a position.
   * @private
   * @param {BuildAddLiquidityParams} params - Parameters for adding liquidity
   * @returns {Promise<TransactionInstruction>} Instruction to add liquidity
   */
  buildAddLiquidityInstruction(params) {
    return __async(this, null, function* () {
      const {
        pool,
        position,
        positionNftAccount,
        owner,
        tokenAAccount,
        tokenBAccount,
        tokenAMint,
        tokenBMint,
        tokenAVault,
        tokenBVault,
        tokenAProgram,
        tokenBProgram,
        liquidityDelta,
        tokenAAmountThreshold,
        tokenBAmountThreshold
      } = params;
      return yield this._program.methods.addLiquidity({
        liquidityDelta,
        tokenAAmountThreshold,
        tokenBAmountThreshold
      }).accountsPartial({
        pool,
        position,
        positionNftAccount,
        owner,
        tokenAAccount,
        tokenBAccount,
        tokenAMint,
        tokenBMint,
        tokenAVault,
        tokenBVault,
        tokenAProgram,
        tokenBProgram
      }).instruction();
    });
  }
  /**
   * Builds an instruction to remove all liquidity from a position.
   * @private
   * @param {BuildRemoveAllLiquidityInstructionParams} params - Parameters for removing all liquidity
   * @returns {Promise<TransactionInstruction>} Instruction to remove all liquidity
   */
  buildRemoveAllLiquidityInstruction(params) {
    return __async(this, null, function* () {
      const {
        poolAuthority,
        owner,
        pool,
        position,
        positionNftAccount,
        tokenAAccount,
        tokenBAccount,
        tokenAAmountThreshold,
        tokenBAmountThreshold,
        tokenAMint,
        tokenBMint,
        tokenAVault,
        tokenBVault,
        tokenAProgram,
        tokenBProgram
      } = params;
      return yield this._program.methods.removeAllLiquidity(tokenAAmountThreshold, tokenBAmountThreshold).accountsPartial({
        poolAuthority,
        pool,
        position,
        positionNftAccount,
        owner,
        tokenAAccount,
        tokenBAccount,
        tokenAMint,
        tokenBMint,
        tokenAVault,
        tokenBVault,
        tokenAProgram,
        tokenBProgram
      }).instruction();
    });
  }
  /**
   * Builds an instruction to claim fees accumulated by a position.
   * @private
   * @param {ClaimPositionFeeInstructionParams} params - Parameters for claiming position fees
   * @returns {Promise<TransactionInstruction>} Instruction to claim position fees
   */
  buildClaimPositionFeeInstruction(params) {
    return __async(this, null, function* () {
      const {
        owner,
        poolAuthority,
        pool,
        position,
        positionNftAccount,
        tokenAAccount,
        tokenBAccount,
        tokenAVault,
        tokenBVault,
        tokenAMint,
        tokenBMint,
        tokenAProgram,
        tokenBProgram
      } = params;
      return yield this._program.methods.claimPositionFee().accountsPartial({
        poolAuthority,
        owner,
        pool,
        position,
        positionNftAccount,
        tokenAAccount,
        tokenBAccount,
        tokenAVault,
        tokenBVault,
        tokenAMint,
        tokenBMint,
        tokenAProgram,
        tokenBProgram
      }).instruction();
    });
  }
  /**
   * Builds an instruction to close a position.
   * @private
   * @param {ClosePositionInstructionParams} params - Parameters for closing a position
   * @returns {Promise<TransactionInstruction>} Instruction to close the position
   */
  buildClosePositionInstruction(params) {
    return __async(this, null, function* () {
      const {
        owner,
        poolAuthority,
        pool,
        position,
        positionNftAccount,
        positionNftMint
      } = params;
      return yield this._program.methods.closePosition().accountsPartial({
        positionNftMint,
        positionNftAccount,
        pool,
        position,
        poolAuthority,
        rentReceiver: owner,
        owner,
        tokenProgram: TOKEN_2022_PROGRAM_ID3
      }).instruction();
    });
  }
  /**
   * Builds an instruction to refresh vesting for a position
   * @param params Parameters required for the refresh vesting instruction
   * @returns Transaction instruction or null if no vestings to refresh
   */
  buildRefreshVestingInstruction(params) {
    return __async(this, null, function* () {
      const { owner, position, positionNftAccount, pool, vestingAccounts } = params;
      if (vestingAccounts.length == 0) {
        return null;
      }
      return yield this._program.methods.refreshVesting().accountsPartial({
        position,
        positionNftAccount,
        pool,
        owner
      }).remainingAccounts(
        vestingAccounts.map((pubkey) => {
          return {
            isSigner: false,
            isWritable: true,
            pubkey
          };
        })
      ).instruction();
    });
  }
  /**
   * Helper function that builds instructions to claim fees, remove liquidity, and close a position
   * @param {BuildLiquidatePositionInstructionParams} params - Parameters for liquidating a position
   * @returns {Promise<TransactionInstruction[]>} Array of instructions
   * @private
   */
  buildLiquidatePositionInstruction(params) {
    return __async(this, null, function* () {
      const {
        owner,
        position,
        positionNftAccount,
        positionState,
        poolState,
        tokenAAccount,
        tokenBAccount,
        tokenAAmountThreshold,
        tokenBAmountThreshold
      } = params;
      const { nftMint: positionNftMint, pool } = positionState;
      const { tokenAMint, tokenBMint, tokenAVault, tokenBVault } = poolState;
      const tokenAProgram = getTokenProgram(poolState.tokenAFlag);
      const tokenBProgram = getTokenProgram(poolState.tokenBFlag);
      const instructions = [];
      const claimPositionFeeInstruction = yield this.buildClaimPositionFeeInstruction({
        owner,
        poolAuthority: this.poolAuthority,
        pool,
        position,
        positionNftAccount,
        tokenAAccount,
        tokenBAccount,
        tokenAVault,
        tokenBVault,
        tokenAMint,
        tokenBMint,
        tokenAProgram,
        tokenBProgram
      });
      instructions.push(claimPositionFeeInstruction);
      const removeAllLiquidityInstruction = yield this.buildRemoveAllLiquidityInstruction({
        poolAuthority: this.poolAuthority,
        owner,
        pool,
        position,
        positionNftAccount,
        tokenAAccount,
        tokenBAccount,
        tokenAAmountThreshold,
        tokenBAmountThreshold,
        tokenAMint,
        tokenBMint,
        tokenAVault,
        tokenBVault,
        tokenAProgram,
        tokenBProgram
      });
      instructions.push(removeAllLiquidityInstruction);
      const closePositionInstruction = yield this.buildClosePositionInstruction({
        owner,
        poolAuthority: this.poolAuthority,
        pool,
        position,
        positionNftMint,
        positionNftAccount
      });
      instructions.push(closePositionInstruction);
      return instructions;
    });
  }
  /**
   * Builds a instruction to create a position.
   * @param {CreatePositionParams} params - Parameters for position creation.
   * @returns Transaction instruction.
   */
  buildCreatePositionInstruction(params) {
    return __async(this, null, function* () {
      const { owner, payer, pool, positionNft } = params;
      const position = derivePositionAddress(positionNft);
      const positionNftAccount = derivePositionNftAccount(positionNft);
      const ix = yield this._program.methods.createPosition().accountsPartial({
        owner,
        positionNftMint: positionNft,
        poolAuthority: this.poolAuthority,
        positionNftAccount,
        payer,
        pool,
        position,
        tokenProgram: TOKEN_2022_PROGRAM_ID3,
        systemProgram: SystemProgram2.programId
      }).instruction();
      return {
        ix,
        position,
        positionNftAccount
      };
    });
  }
  /**
   * Private helper method to prepare common customizable pool creation logic
   * @param {PrepareCustomizablePoolParams} params - Common parameters for pool creation
   * @returns Prepared transaction data including instructions and accounts
   */
  prepareCreatePoolParams(params) {
    return __async(this, null, function* () {
      const {
        pool,
        tokenAMint,
        tokenBMint,
        tokenAAmount,
        tokenBAmount,
        payer,
        positionNft,
        tokenAProgram,
        tokenBProgram
      } = params;
      const position = derivePositionAddress(positionNft);
      const positionNftAccount = derivePositionNftAccount(positionNft);
      const tokenAVault = deriveTokenVaultAddress(tokenAMint, pool);
      const tokenBVault = deriveTokenVaultAddress(tokenBMint, pool);
      const {
        tokenAAta: payerTokenA,
        tokenBAta: payerTokenB,
        instructions: preInstructions
      } = yield this.prepareTokenAccounts({
        payer,
        tokenAOwner: payer,
        tokenBOwner: payer,
        tokenAMint,
        tokenBMint,
        tokenAProgram,
        tokenBProgram
      });
      if (tokenAMint.equals(NATIVE_MINT2)) {
        const wrapSOLIx = wrapSOLInstruction(
          payer,
          payerTokenA,
          BigInt(tokenAAmount.toString())
        );
        preInstructions.push(...wrapSOLIx);
      }
      if (tokenBMint.equals(NATIVE_MINT2)) {
        const wrapSOLIx = wrapSOLInstruction(
          payer,
          payerTokenB,
          BigInt(tokenBAmount.toString())
        );
        preInstructions.push(...wrapSOLIx);
      }
      const tokenBadgeAccounts = this.getTokenBadgeAccounts(
        tokenAMint,
        tokenBMint
      );
      return {
        position,
        positionNftAccount,
        tokenAVault,
        tokenBVault,
        payerTokenA,
        payerTokenB,
        preInstructions,
        tokenBadgeAccounts
      };
    });
  }
  /**
   * Sets up token accounts and instructions for fee claim operations.
   * @private
   * @param {SetupFeeClaimAccountsParams} params - Parameters for setting up fee claim accounts.
   * @returns Token accounts and instructions for fee claiming.
   */
  setupFeeClaimAccounts(params) {
    return __async(this, null, function* () {
      const {
        payer,
        owner,
        tokenAMint,
        tokenBMint,
        tokenAProgram,
        tokenBProgram,
        receiver,
        tempWSolAccount
      } = params;
      const tokenAIsSOL = tokenAMint.equals(NATIVE_MINT2);
      const tokenBIsSOL = tokenBMint.equals(NATIVE_MINT2);
      const hasSolToken = tokenAIsSOL || tokenBIsSOL;
      const preInstructions = [];
      const postInstructions = [];
      let tokenAAccount;
      let tokenBAccount;
      let tokenAOwner = owner;
      let tokenBOwner = owner;
      if (receiver) {
        tokenAOwner = tokenAIsSOL ? tempWSolAccount : receiver;
        tokenBOwner = tokenBIsSOL ? tempWSolAccount : receiver;
      }
      const { tokenAAta, tokenBAta, instructions } = yield this.prepareTokenAccounts({
        payer,
        tokenAOwner,
        tokenBOwner,
        tokenAMint,
        tokenBMint,
        tokenAProgram,
        tokenBProgram
      });
      tokenAAccount = tokenAAta;
      tokenBAccount = tokenBAta;
      preInstructions.push(...instructions);
      if (hasSolToken) {
        const closeWrappedSOLIx = yield unwrapSOLInstruction(
          tempWSolAccount != null ? tempWSolAccount : owner,
          receiver != null ? receiver : owner
        );
        closeWrappedSOLIx && postInstructions.push(closeWrappedSOLIx);
      }
      return {
        tokenAAccount,
        tokenBAccount,
        preInstructions,
        postInstructions
      };
    });
  }
  //// ANCHOR: GETTER/FETCHER FUNCTIONS //////
  /**
   * Fetches the Config state of the program.
   * @param config - Public key of the config account.
   * @returns Parsed ConfigState.
   */
  fetchConfigState(config) {
    return __async(this, null, function* () {
      const configState = yield this._program.account.config.fetchNullable(config);
      invariant(configState, `Config account: ${config} not found`);
      return configState;
    });
  }
  /**
   * Fetches the Pool state.
   * @param pool - Public key of the pool.
   * @returns Parsed PoolState.
   */
  fetchPoolState(pool) {
    return __async(this, null, function* () {
      const poolState = yield this._program.account.pool.fetchNullable(pool);
      invariant(poolState, `Pool account: ${pool} not found`);
      return poolState;
    });
  }
  /**
   * Fetches all Pool states by tokenAMint.
   * @param tokenAMint - Public key of the tokenA mint.
   * @returns Array of matched pool accounts and their state.
   */
  fetchPoolStatesByTokenAMint(tokenAMint) {
    return __async(this, null, function* () {
      const filters = offsetBasedFilter(tokenAMint, 168);
      const pools = yield this._program.account.pool.all(filters);
      return pools;
    });
  }
  fetchPoolFees(pool) {
    return __async(this, null, function* () {
      const poolState = yield this._program.account.pool.fetchNullable(pool);
      if (!poolState) {
        throw new Error(`Pool account: ${pool} not found`);
      }
      const data = Buffer.from(poolState.poolFees.baseFee.baseFeeInfo.data);
      const modeIndex = data.readUInt8(8);
      const baseFeeMode = modeIndex;
      switch (baseFeeMode) {
        case 0 /* FeeTimeSchedulerLinear */:
        case 1 /* FeeTimeSchedulerExponential */: {
          const poolFees = decodePodAlignedFeeTimeScheduler(data);
          return poolFees;
        }
        case 2 /* RateLimiter */: {
          const poolFees = decodePodAlignedFeeRateLimiter(data);
          return poolFees;
        }
        case 3 /* FeeMarketCapSchedulerLinear */:
        case 4 /* FeeMarketCapSchedulerExponential */: {
          const poolFees = decodePodAlignedFeeMarketCapScheduler(data);
          return poolFees;
        }
        default: {
          throw new Error(`Invalid base fee mode: ${baseFeeMode}`);
        }
      }
    });
  }
  /**
   * Fetches the Position state.
   * @param position - Public key of the position.
   * @returns Parsed PositionState.
   */
  fetchPositionState(position) {
    return __async(this, null, function* () {
      const positionState = yield this._program.account.position.fetchNullable(position);
      invariant(positionState, `Position account: ${position} not found`);
      return positionState;
    });
  }
  /**
   * Fetches multiple Config states.
   * @param configs - Array of public keys of config accounts.
   * @returns Array of parsed ConfigState.
   */
  getMultipleConfigs(configs) {
    return __async(this, null, function* () {
      const configStates = yield this._program.account.config.fetchMultiple(configs);
      configStates.forEach((configState, index) => {
        invariant(configState, `Config account: ${configs[index]} not found`);
      });
      return configStates;
    });
  }
  /**
   * Fetches multiple Pool states.
   * @param pools - Array of public keys of pool accounts.
   * @returns Array of parsed PoolState.
   */
  getMultiplePools(pools) {
    return __async(this, null, function* () {
      const poolStates = yield this._program.account.pool.fetchMultiple(pools);
      poolStates.forEach((poolState, index) => {
        invariant(poolState, `Pool account: ${pools[index]} not found`);
      });
      return poolStates;
    });
  }
  /**
   * Fetches multiple Position states.
   * @param positions - Array of public keys of position accounts.
   * @returns Array of parsed PositionState.
   */
  getMultiplePositions(positions) {
    return __async(this, null, function* () {
      const positionStates = yield this._program.account.position.fetchMultiple(positions);
      positionStates.forEach((positionState, index) => {
        invariant(
          positionState,
          `Position account: ${positions[index]} not found`
        );
      });
      return positionStates;
    });
  }
  /**
   * Retrieves all config accounts.
   * @returns Array of config public keys and their states.
   */
  getAllConfigs() {
    return __async(this, null, function* () {
      const configAccounts = yield this._program.account.config.all();
      return configAccounts;
    });
  }
  /**
   * Retrieves all pool accounts.
   * @returns Array of pool public keys and their states.
   */
  getAllPools() {
    return __async(this, null, function* () {
      const poolAccounts = yield this._program.account.pool.all();
      return poolAccounts;
    });
  }
  /**
   * Retrieves all position accounts.
   * @returns Array of position public keys and their states.
   */
  getAllPositions() {
    return __async(this, null, function* () {
      const poolAccounts = yield this._program.account.position.all();
      return poolAccounts;
    });
  }
  /**
   * Gets all positions a specific pool.
   * @param pool - Public key of the pool.
   * @returns List of user positions for the pool.
   */
  getAllPositionsByPool(pool) {
    return __async(this, null, function* () {
      return yield this._program.account.position.all([
        positionByPoolFilter(pool)
      ]);
    });
  }
  /**
   * Gets all positions of a user for a specific pool.
   * @param pool - Public key of the pool.
   * @param user - Public key of the user.
   * @returns List of user positions for the pool.
   */
  getUserPositionByPool(pool, user) {
    return __async(this, null, function* () {
      const allUserPositions = yield this.getPositionsByUser(user);
      return allUserPositions.filter(
        (position) => position.positionState.pool.equals(pool)
      );
    });
  }
  /**
   * Gets all positions of a user across all pools.
   * @param user - Public key of the user.
   * @returns Array of user positions already sorted by liquidity
   */
  getPositionsByUser(user) {
    return __async(this, null, function* () {
      const userPositionAccounts = yield getAllPositionNftAccountByOwner(
        this._program.provider.connection,
        user
      );
      if (userPositionAccounts.length === 0) {
        return [];
      }
      const positionAddresses = userPositionAccounts.map(
        (account) => derivePositionAddress(account.positionNft)
      );
      const positionStates = yield this._program.account.position.fetchMultiple(positionAddresses);
      const positionResult = userPositionAccounts.map((account, index) => {
        const positionState = positionStates[index];
        if (!positionState) return null;
        return {
          positionNftAccount: account.positionNftAccount,
          position: positionAddresses[index],
          positionState
        };
      }).filter(Boolean);
      positionResult.sort((a, b) => {
        const totalLiquidityA = a.positionState.vestedLiquidity.add(a.positionState.permanentLockedLiquidity).add(a.positionState.unlockedLiquidity);
        const totalLiquidityB = b.positionState.vestedLiquidity.add(b.positionState.permanentLockedLiquidity).add(b.positionState.unlockedLiquidity);
        return totalLiquidityB.cmp(totalLiquidityA);
      });
      return positionResult;
    });
  }
  /**
   * Retrieves all vesting accounts associated with a position.
   * @param position - Public key of the position.
   * @returns Array of vesting account public keys and their states.
   */
  getAllVestingsByPosition(position) {
    return __async(this, null, function* () {
      const vestings = yield this._program.account.vesting.all([
        vestingByPositionFilter(position)
      ]);
      return vestings;
    });
  }
  /**
   * Checks if a position has any locked liquidity.
   * @param position - Position state.
   * @returns True if the position has locked liquidity, false otherwise.
   */
  isLockedPosition(position) {
    const totalLockedLiquidity = position.vestedLiquidity.add(
      position.permanentLockedLiquidity
    );
    return totalLockedLiquidity.gtn(0);
  }
  /**
   * Checks if a position is permanently locked.
   * @param positionState - Position state.
   * @returns True if the position is permanently locked, false otherwise.
   */
  isPermanentLockedPosition(positionState) {
    return positionState.permanentLockedLiquidity.gtn(0);
  }
  /**
   * Checks if a position can be unlocked based on its locking state and vesting schedules.
   *
   * This method evaluates whether a position is eligible for operations that require
   * unlocked liquidity, such as removing all liquidity or closing the position. It checks both
   * permanent locks and time-based vesting schedules.
   *
   * @private
   * @param {PositionState} positionState - The current state of the position
   * @param {Array<{account: PublicKey; vestingState: VestingState}>} vestings - Array of vesting accounts and their states
   * @param {BN} currentPoint - Current timestamp or slot number (depending on activation type of pool)
   *
   * @returns {Object} Result object containing unlock status and reason
   * @returns {boolean} result.canUnlock - Whether the position can be unlocked
   * @returns {string|undefined} result.reason - Reason why position cannot be unlocked (if applicable)
   */
  canUnlockPosition(positionState, vestings, currentPoint) {
    if (vestings.length > 0) {
      if (this.isPermanentLockedPosition(positionState)) {
        return {
          canUnlock: false,
          reason: "Position is permanently locked"
        };
      }
      for (const vesting of vestings) {
        if (!isVestingComplete(vesting.vestingState, currentPoint)) {
          return {
            canUnlock: false,
            reason: "Position has incomplete vesting schedule"
          };
        }
      }
    }
    return { canUnlock: true };
  }
  /**
   * Checks if a pool exists.
   * @param pool - Public key of the pool.
   * @returns True if the pool exists, false otherwise.
   */
  isPoolExist(pool) {
    return __async(this, null, function* () {
      const poolState = yield this._program.account.pool.fetchNullable(pool);
      return poolState !== null;
    });
  }
  /**
   * Computes the liquidity delta based on the provided token amounts and sqrt price
   *
   * @param {LiquidityDeltaParams} params - The parameters for liquidity calculation
   * @returns {Promise<BN>} - The computed liquidity delta in Q64 value.
   */
  getLiquidityDelta(params) {
    const {
      maxAmountTokenA,
      maxAmountTokenB,
      sqrtMaxPrice,
      sqrtMinPrice,
      sqrtPrice
    } = params;
    const liquidityDeltaFromAmountA = getLiquidityDeltaFromAmountA(
      maxAmountTokenA,
      sqrtPrice,
      sqrtMaxPrice
    );
    const liquidityDeltaFromAmountB = getLiquidityDeltaFromAmountB(
      maxAmountTokenB,
      sqrtMinPrice,
      sqrtPrice
    );
    return min2(liquidityDeltaFromAmountA, liquidityDeltaFromAmountB);
  }
  /**
   * Calculates swap quote based on input amount and pool state.
   * @param params - Swap parameters including input amount, pool state, slippage, etc.
   * @returns Swap quote including expected output amount, fee, and price impact.
   */
  getQuote(params) {
    const {
      inAmount,
      inputTokenMint,
      slippage,
      poolState,
      currentTime,
      currentSlot,
      inputTokenInfo,
      outputTokenInfo,
      tokenADecimal,
      tokenBDecimal,
      hasReferral
    } = params;
    const { activationType } = poolState;
    const aToB = poolState.tokenAMint.equals(inputTokenMint);
    const currentPoint = activationType ? new BN19(currentTime) : new BN19(currentSlot);
    const swapResult = swapQuoteExactInput(
      poolState,
      currentPoint,
      inAmount,
      slippage,
      aToB,
      hasReferral,
      tokenADecimal,
      tokenBDecimal,
      inputTokenInfo,
      outputTokenInfo
    );
    return {
      swapInAmount: inAmount,
      consumedInAmount: swapResult.includedFeeInputAmount,
      swapOutAmount: swapResult.outputAmount,
      minSwapOutAmount: swapResult.minimumAmountOut,
      totalFee: swapResult.tradingFee.add(swapResult.protocolFee).add(swapResult.partnerFee).add(swapResult.referralFee),
      priceImpact: swapResult.priceImpact
    };
  }
  /**
   * Calculates the expected output amount or input amount for a swap depending on the swap mode.
   * @param params GetQuote2Params
   * @returns Quote2Result
   */
  getQuote2(params) {
    const {
      inputTokenMint,
      slippage,
      poolState,
      currentPoint,
      inputTokenInfo,
      outputTokenInfo,
      hasReferral,
      tokenADecimal,
      tokenBDecimal,
      swapMode
    } = params;
    const aToB = poolState.tokenAMint.equals(inputTokenMint);
    switch (swapMode) {
      case 0 /* ExactIn */:
        if ("amountIn" in params) {
          return swapQuoteExactInput(
            poolState,
            currentPoint,
            params.amountIn,
            slippage,
            aToB,
            hasReferral,
            tokenADecimal,
            tokenBDecimal,
            inputTokenInfo,
            outputTokenInfo
          );
        }
        throw new Error("amountIn is required for ExactIn swap mode");
      case 2 /* ExactOut */:
        if ("amountOut" in params) {
          return swapQuoteExactOutput(
            poolState,
            currentPoint,
            params.amountOut,
            slippage,
            aToB,
            hasReferral,
            tokenADecimal,
            tokenBDecimal,
            inputTokenInfo,
            outputTokenInfo
          );
        }
        throw new Error("outAmount is required for ExactOut swap mode");
      case 1 /* PartialFill */:
        if ("amountIn" in params) {
          return swapQuotePartialInput(
            poolState,
            currentPoint,
            params.amountIn,
            slippage,
            aToB,
            hasReferral,
            tokenADecimal,
            tokenBDecimal,
            inputTokenInfo,
            outputTokenInfo
          );
        }
        throw new Error("amountIn is required for PartialFill swap mode");
      default:
        throw new Error(`Unsupported swap mode: ${swapMode}`);
    }
  }
  /**
   * Calculates the deposit quote for liquidity pool.
   *
   * @param {GetDepositQuoteParams} params - The parameters for calculating the deposit quote.
   *
   * @returns {Promise<Object>} Deposit quote results
   * @returns {BN} returns.actualInputAmount - The actual amount used as input (after deducting transfer fees).
   * @returns {BN} returns.outputAmount - The calculated corresponding amount of the other token.
   * @returns {BN} returns.liquidityDelta - The amount of liquidity that will be added to the pool.
   */
  getDepositQuote(params) {
    const {
      inAmount,
      isTokenA,
      inputTokenInfo,
      outputTokenInfo,
      minSqrtPrice,
      maxSqrtPrice,
      sqrtPrice
    } = params;
    const actualAmountIn = inputTokenInfo ? calculateTransferFeeExcludedAmount(
      inAmount,
      inputTokenInfo.mint,
      inputTokenInfo.currentEpoch
    ).amount : inAmount;
    const { liquidityDelta, rawAmount } = isTokenA ? {
      liquidityDelta: getLiquidityDeltaFromAmountA(
        actualAmountIn,
        sqrtPrice,
        maxSqrtPrice
      ),
      rawAmount: (delta) => getAmountBFromLiquidityDelta(
        minSqrtPrice,
        sqrtPrice,
        delta,
        0 /* Up */
      )
    } : {
      liquidityDelta: getLiquidityDeltaFromAmountB(
        actualAmountIn,
        minSqrtPrice,
        sqrtPrice
      ),
      rawAmount: (delta) => getAmountAFromLiquidityDelta(
        sqrtPrice,
        maxSqrtPrice,
        delta,
        0 /* Up */
      )
    };
    const rawOutputAmount = new BN19(rawAmount(liquidityDelta));
    const outputAmount = outputTokenInfo ? calculateTransferFeeIncludedAmount(
      rawOutputAmount,
      outputTokenInfo.mint,
      outputTokenInfo.currentEpoch
    ).amount : rawOutputAmount;
    return {
      actualInputAmount: actualAmountIn,
      consumedInputAmount: inAmount,
      liquidityDelta,
      outputAmount
    };
  }
  /**
   * Calculates the withdrawal quote for removing liquidity from a concentrated liquidity pool.
   *
   * @param {GetWithdrawQuoteParams} params - The parameters for calculating the withdraw quote
   *
   * @param {Object|null} params.tokenATokenInfo - must provide if token a is token2022
   * @param {Object|null} params.tokenBTokenInfo - must provide if token b is token2022
   *
   * @returns {Promise<Object>} Withdrawal quote results
   * @returns {BN} returns.liquidityDelta - The amount of liquidity that will be removed from the pool
   * @returns {BN} returns.outAmountA - The calculated amount of token A to be received (after deducting transfer fees)
   * @returns {BN} returns.outAmountB - The calculated amount of token B to be received (after deducting transfer fees)
   */
  getWithdrawQuote(params) {
    const {
      liquidityDelta,
      sqrtPrice,
      maxSqrtPrice,
      minSqrtPrice,
      tokenATokenInfo,
      tokenBTokenInfo
    } = params;
    const amountA = getAmountAFromLiquidityDelta(
      sqrtPrice,
      maxSqrtPrice,
      liquidityDelta,
      1 /* Down */
    );
    const amountB = getAmountBFromLiquidityDelta(
      minSqrtPrice,
      sqrtPrice,
      liquidityDelta,
      1 /* Down */
    );
    return {
      liquidityDelta,
      outAmountA: tokenATokenInfo ? calculateTransferFeeExcludedAmount(
        amountA,
        tokenATokenInfo.mint,
        tokenATokenInfo.currentEpoch
      ).amount : amountA,
      outAmountB: tokenBTokenInfo ? calculateTransferFeeExcludedAmount(
        amountB,
        tokenBTokenInfo.mint,
        tokenBTokenInfo.currentEpoch
      ).amount : amountB
    };
  }
  /**
   * Calculates liquidity and corresponding token amounts for token A single-sided pool creation
   * Only supports initialization where initial price equals min sqrt price
   * @param params Parameters for single-sided pool creation
   * @returns Calculated liquidity delta
   */
  preparePoolCreationSingleSide(params) {
    const {
      tokenAAmount,
      initSqrtPrice,
      minSqrtPrice,
      maxSqrtPrice,
      tokenAInfo
    } = params;
    if (!initSqrtPrice.eq(minSqrtPrice)) {
      throw new Error("Only support single side for base token.");
    }
    const actualAmountIn = tokenAInfo ? tokenAAmount.sub(
      calculateTransferFeeIncludedAmount(
        tokenAAmount,
        tokenAInfo.mint,
        tokenAInfo.currentEpoch
      ).transferFee
    ) : tokenAAmount;
    const liquidityDelta = getLiquidityDeltaFromAmountA(
      actualAmountIn,
      initSqrtPrice,
      maxSqrtPrice
    );
    return liquidityDelta;
  }
  /**
   * Prepares parameters required for pool creation, including initial sqrt price and liquidity.
   * @private
   * @param {PreparePoolCreationParams} params - Initial token amounts for pool creation.
   * @returns init sqrt price and liquidity in Q64 format.
   */
  preparePoolCreationParams(params) {
    const {
      tokenAAmount,
      tokenBAmount,
      minSqrtPrice,
      maxSqrtPrice,
      tokenAInfo,
      tokenBInfo
    } = params;
    if (tokenAAmount.eq(new BN19(0)) && tokenBAmount.eq(new BN19(0))) {
      throw new Error("Invalid input amount");
    }
    const actualAmountAIn = tokenAInfo ? tokenAAmount.sub(
      calculateTransferFeeIncludedAmount(
        tokenAAmount,
        tokenAInfo.mint,
        tokenAInfo.currentEpoch
      ).transferFee
    ) : tokenAAmount;
    const actualAmountBIn = tokenBInfo ? tokenBAmount.sub(
      calculateTransferFeeIncludedAmount(
        tokenBAmount,
        tokenBInfo.mint,
        tokenBInfo.currentEpoch
      ).transferFee
    ) : tokenBAmount;
    const initSqrtPrice = calculateInitSqrtPrice(
      tokenAAmount,
      tokenBAmount,
      minSqrtPrice,
      maxSqrtPrice
    );
    const liquidityDeltaFromAmountA = getLiquidityDeltaFromAmountA(
      actualAmountAIn,
      initSqrtPrice,
      maxSqrtPrice
    );
    const liquidityDeltaFromAmountB = getLiquidityDeltaFromAmountB(
      actualAmountBIn,
      minSqrtPrice,
      initSqrtPrice
    );
    const liquidityDelta = min2(
      liquidityDeltaFromAmountA,
      liquidityDeltaFromAmountB
    );
    return {
      initSqrtPrice,
      liquidityDelta
    };
  }
  //// ANCHOR: MAIN ENDPOINT //////
  /**
   * Builds a transaction to create a permissionless pool.
   * @param params - Parameters for pool creation.
   * @returns Transaction builder.
   */
  createPool(params) {
    return __async(this, null, function* () {
      const {
        payer,
        creator,
        config,
        positionNft,
        tokenAMint,
        tokenBMint,
        initSqrtPrice,
        liquidityDelta,
        activationPoint,
        tokenAAmount,
        tokenBAmount,
        tokenAProgram,
        tokenBProgram,
        isLockLiquidity
      } = params;
      const pool = derivePoolAddress(config, tokenAMint, tokenBMint);
      const {
        position,
        positionNftAccount,
        tokenAVault,
        tokenBVault,
        payerTokenA,
        payerTokenB,
        preInstructions,
        tokenBadgeAccounts
      } = yield this.prepareCreatePoolParams({
        pool,
        tokenAMint,
        tokenBMint,
        tokenAAmount,
        tokenBAmount,
        payer,
        positionNft,
        tokenAProgram,
        tokenBProgram
      });
      const postInstruction = [];
      if (isLockLiquidity) {
        const permanentLockIx = yield this._program.methods.permanentLockPosition(liquidityDelta).accountsPartial({
          position,
          positionNftAccount,
          pool,
          owner: creator
        }).instruction();
        postInstruction.push(permanentLockIx);
      }
      const tx = yield this._program.methods.initializePool({
        liquidity: liquidityDelta,
        sqrtPrice: initSqrtPrice,
        activationPoint
      }).accountsPartial({
        creator,
        positionNftAccount,
        positionNftMint: positionNft,
        payer,
        config,
        poolAuthority: this.poolAuthority,
        pool,
        position,
        tokenAMint,
        tokenBMint,
        tokenAVault,
        tokenBVault,
        payerTokenA,
        payerTokenB,
        token2022Program: TOKEN_2022_PROGRAM_ID3,
        tokenAProgram,
        tokenBProgram,
        systemProgram: SystemProgram2.programId
      }).preInstructions(preInstructions).postInstructions(postInstruction).remainingAccounts(tokenBadgeAccounts).transaction();
      return tx;
    });
  }
  /**
   * Builds a transaction to create a customizable pool.
   * @param params - Parameters for customizable pool creation.
   * @returns Transaction and related addresses.
   */
  createCustomPool(params) {
    return __async(this, null, function* () {
      const {
        tokenAMint,
        tokenBMint,
        tokenAAmount,
        tokenBAmount,
        sqrtMinPrice,
        sqrtMaxPrice,
        liquidityDelta,
        initSqrtPrice,
        payer,
        creator,
        positionNft,
        poolFees,
        hasAlphaVault,
        collectFeeMode,
        activationPoint,
        activationType,
        tokenAProgram,
        tokenBProgram,
        isLockLiquidity
      } = params;
      const pool = deriveCustomizablePoolAddress(tokenAMint, tokenBMint);
      const {
        position,
        positionNftAccount,
        tokenAVault,
        tokenBVault,
        payerTokenA,
        payerTokenB,
        preInstructions,
        tokenBadgeAccounts
      } = yield this.prepareCreatePoolParams({
        pool,
        tokenAMint,
        tokenBMint,
        tokenAAmount,
        tokenBAmount: tokenBMint.equals(NATIVE_MINT2) ? max(tokenBAmount, new BN19(1)) : tokenBAmount,
        payer,
        positionNft,
        tokenAProgram,
        tokenBProgram
      });
      const postInstruction = [];
      if (isLockLiquidity) {
        const permanentLockIx = yield this._program.methods.permanentLockPosition(liquidityDelta).accountsPartial({
          position,
          positionNftAccount,
          pool,
          owner: creator
        }).instruction();
        postInstruction.push(permanentLockIx);
      }
      const transaction = yield this._program.methods.initializeCustomizablePool({
        poolFees,
        sqrtMinPrice,
        sqrtMaxPrice,
        hasAlphaVault,
        liquidity: liquidityDelta,
        sqrtPrice: initSqrtPrice,
        activationType,
        collectFeeMode,
        activationPoint
      }).accountsPartial({
        creator,
        positionNftAccount,
        positionNftMint: positionNft,
        payer,
        poolAuthority: this.poolAuthority,
        pool,
        position,
        tokenAMint,
        tokenBMint,
        tokenAVault,
        tokenBVault,
        payerTokenA,
        payerTokenB,
        token2022Program: TOKEN_2022_PROGRAM_ID3,
        tokenAProgram,
        tokenBProgram,
        systemProgram: SystemProgram2.programId
      }).preInstructions(preInstructions).postInstructions(postInstruction).remainingAccounts(tokenBadgeAccounts).transaction();
      return { tx: transaction, pool, position };
    });
  }
  /**
   * Builds a transaction to create a customizable pool with dynamic config.
   * @param params InitializeCustomizeablePoolWithDynamicConfigParams
   * @returns Transaction and related addresses.
   */
  createCustomPoolWithDynamicConfig(params) {
    return __async(this, null, function* () {
      const {
        tokenAMint,
        tokenBMint,
        tokenAAmount,
        tokenBAmount,
        sqrtMinPrice,
        sqrtMaxPrice,
        liquidityDelta,
        initSqrtPrice,
        payer,
        config,
        poolCreatorAuthority,
        creator,
        positionNft,
        poolFees,
        hasAlphaVault,
        collectFeeMode,
        activationPoint,
        activationType,
        tokenAProgram,
        tokenBProgram,
        isLockLiquidity
      } = params;
      const pool = derivePoolAddress(config, tokenAMint, tokenBMint);
      const {
        position,
        positionNftAccount,
        tokenAVault,
        tokenBVault,
        payerTokenA,
        payerTokenB,
        preInstructions,
        tokenBadgeAccounts
      } = yield this.prepareCreatePoolParams({
        pool,
        tokenAMint,
        tokenBMint,
        tokenAAmount,
        tokenBAmount,
        payer,
        positionNft,
        tokenAProgram,
        tokenBProgram
      });
      const postInstruction = [];
      if (isLockLiquidity) {
        const permanentLockIx = yield this._program.methods.permanentLockPosition(liquidityDelta).accountsPartial({
          position,
          positionNftAccount,
          pool,
          owner: creator
        }).instruction();
        postInstruction.push(permanentLockIx);
      }
      const transaction = yield this._program.methods.initializePoolWithDynamicConfig({
        poolFees,
        sqrtMinPrice,
        sqrtMaxPrice,
        hasAlphaVault,
        liquidity: liquidityDelta,
        sqrtPrice: initSqrtPrice,
        activationType,
        collectFeeMode,
        activationPoint
      }).accountsPartial({
        creator,
        positionNftAccount,
        positionNftMint: positionNft,
        payer,
        poolAuthority: this.poolAuthority,
        pool,
        position,
        poolCreatorAuthority,
        config,
        tokenAMint,
        tokenBMint,
        tokenAVault,
        tokenBVault,
        payerTokenA,
        payerTokenB,
        token2022Program: TOKEN_2022_PROGRAM_ID3,
        tokenAProgram,
        tokenBProgram,
        systemProgram: SystemProgram2.programId
      }).preInstructions(preInstructions).postInstructions(postInstruction).remainingAccounts(tokenBadgeAccounts).transaction();
      return { tx: transaction, pool, position };
    });
  }
  /**
   * Builds a transaction to create a position.
   * @param {CreatePositionParams} params - Parameters for position creation.
   * @returns Transaction builder.
   */
  createPosition(params) {
    return __async(this, null, function* () {
      const { ix } = yield this.buildCreatePositionInstruction(params);
      return new Transaction().add(ix);
    });
  }
  /**
   * Builds a transaction to add liquidity to an existing position.
   * @param {AddLiquidityParams} params - Parameters for adding liquidity.
   * @returns Transaction builder.
   */
  addLiquidity(params) {
    return __async(this, null, function* () {
      const {
        owner,
        pool,
        position,
        positionNftAccount,
        liquidityDelta,
        maxAmountTokenA,
        maxAmountTokenB,
        tokenAAmountThreshold,
        tokenBAmountThreshold,
        tokenAMint,
        tokenBMint,
        tokenAVault,
        tokenBVault,
        tokenAProgram,
        tokenBProgram
      } = params;
      const {
        tokenAAta: tokenAAccount,
        tokenBAta: tokenBAccount,
        instructions: preInstructions
      } = yield this.prepareTokenAccounts({
        payer: owner,
        tokenAOwner: owner,
        tokenBOwner: owner,
        tokenAMint,
        tokenBMint,
        tokenAProgram,
        tokenBProgram
      });
      if (tokenAMint.equals(NATIVE_MINT2)) {
        const wrapSOLIx = wrapSOLInstruction(
          owner,
          tokenAAccount,
          BigInt(maxAmountTokenA.toString())
        );
        preInstructions.push(...wrapSOLIx);
      }
      if (tokenBMint.equals(NATIVE_MINT2)) {
        const wrapSOLIx = wrapSOLInstruction(
          owner,
          tokenBAccount,
          BigInt(maxAmountTokenB.toString())
        );
        preInstructions.push(...wrapSOLIx);
      }
      const postInstructions = [];
      if ([tokenAMint.toBase58(), tokenBMint.toBase58()].includes(
        NATIVE_MINT2.toBase58()
      )) {
        const closeWrappedSOLIx = yield unwrapSOLInstruction(owner);
        closeWrappedSOLIx && postInstructions.push(closeWrappedSOLIx);
      }
      const addLiquidityInstruction = yield this.buildAddLiquidityInstruction({
        pool,
        position,
        positionNftAccount,
        owner,
        tokenAAccount,
        tokenBAccount,
        tokenAMint,
        tokenBMint,
        tokenAVault,
        tokenBVault,
        tokenAProgram,
        tokenBProgram,
        liquidityDelta,
        tokenAAmountThreshold,
        tokenBAmountThreshold
      });
      const transaction = new Transaction();
      transaction.add(
        ...preInstructions.length > 0 ? preInstructions : [],
        addLiquidityInstruction,
        ...postInstructions.length > 0 ? postInstructions : []
      );
      return transaction;
    });
  }
  /**
   * Creates a new position and add liquidity to position it in a single transaction.
   * Handles both native SOL and other tokens, automatically wrapping/unwrapping SOL as needed.
   *
   * @param {CreatePositionAndAddLiquidity} params - Parameters for creating position and adding liquidity
   *
   * @returns {Transaction} A transaction that creates a position and adds liquidity
   *
   **/
  createPositionAndAddLiquidity(params) {
    return __async(this, null, function* () {
      const {
        owner,
        pool,
        positionNft,
        liquidityDelta,
        maxAmountTokenA,
        maxAmountTokenB,
        tokenAAmountThreshold,
        tokenBAmountThreshold,
        tokenAMint,
        tokenBMint,
        tokenAProgram,
        tokenBProgram
      } = params;
      const {
        tokenAAta: tokenAAccount,
        tokenBAta: tokenBAccount,
        instructions: preInstructions
      } = yield this.prepareTokenAccounts({
        payer: owner,
        tokenAOwner: owner,
        tokenBOwner: owner,
        tokenAMint,
        tokenBMint,
        tokenAProgram,
        tokenBProgram
      });
      const tokenAVault = deriveTokenVaultAddress(tokenAMint, pool);
      const tokenBVault = deriveTokenVaultAddress(tokenBMint, pool);
      if (tokenAMint.equals(NATIVE_MINT2)) {
        const wrapSOLIx = wrapSOLInstruction(
          owner,
          tokenAAccount,
          BigInt(maxAmountTokenA.toString())
        );
        preInstructions.push(...wrapSOLIx);
      }
      if (tokenBMint.equals(NATIVE_MINT2)) {
        const wrapSOLIx = wrapSOLInstruction(
          owner,
          tokenBAccount,
          BigInt(maxAmountTokenB.toString())
        );
        preInstructions.push(...wrapSOLIx);
      }
      const postInstructions = [];
      if ([tokenAMint.toBase58(), tokenBMint.toBase58()].includes(
        NATIVE_MINT2.toBase58()
      )) {
        const closeWrappedSOLIx = yield unwrapSOLInstruction(owner);
        closeWrappedSOLIx && postInstructions.push(closeWrappedSOLIx);
      }
      const {
        ix: createPositionIx,
        position,
        positionNftAccount
      } = yield this.buildCreatePositionInstruction({
        owner,
        payer: owner,
        pool,
        positionNft
      });
      const addLiquidityInstruction = yield this.buildAddLiquidityInstruction({
        pool,
        position,
        positionNftAccount,
        owner,
        tokenAAccount,
        tokenBAccount,
        tokenAMint,
        tokenBMint,
        tokenAVault,
        tokenBVault,
        tokenAProgram,
        tokenBProgram,
        liquidityDelta,
        tokenAAmountThreshold,
        tokenBAmountThreshold
      });
      const transaction = new Transaction();
      transaction.add(createPositionIx);
      transaction.add(
        ...preInstructions.length > 0 ? preInstructions : [],
        addLiquidityInstruction,
        ...postInstructions.length > 0 ? postInstructions : []
      );
      return transaction;
    });
  }
  /**
   * Builds a transaction to remove liquidity from a position.
   * @param {RemoveLiquidityParams} params - Parameters for removing liquidity.
   * @returns Transaction builder.
   */
  removeLiquidity(params) {
    return __async(this, null, function* () {
      const {
        owner,
        pool,
        position,
        positionNftAccount,
        liquidityDelta,
        tokenAAmountThreshold,
        tokenBAmountThreshold,
        tokenAMint,
        tokenBMint,
        tokenAVault,
        tokenBVault,
        tokenAProgram,
        tokenBProgram,
        vestings
      } = params;
      const {
        tokenAAta: tokenAAccount,
        tokenBAta: tokenBAccount,
        instructions: preInstructions
      } = yield this.prepareTokenAccounts({
        payer: owner,
        tokenAOwner: owner,
        tokenBOwner: owner,
        tokenAMint,
        tokenBMint,
        tokenAProgram,
        tokenBProgram
      });
      const postInstructions = [];
      if ([tokenAMint.toBase58(), tokenBMint.toBase58()].includes(
        NATIVE_MINT2.toBase58()
      )) {
        const closeWrappedSOLIx = yield unwrapSOLInstruction(owner);
        closeWrappedSOLIx && postInstructions.push(closeWrappedSOLIx);
      }
      if (vestings.length > 0) {
        const refreshVestingInstruction = yield this.buildRefreshVestingInstruction({
          owner,
          position,
          positionNftAccount,
          pool,
          vestingAccounts: vestings.map((item) => item.account)
        });
        refreshVestingInstruction && preInstructions.push(refreshVestingInstruction);
      }
      return yield this._program.methods.removeLiquidity({
        liquidityDelta,
        tokenAAmountThreshold,
        tokenBAmountThreshold
      }).accountsPartial({
        poolAuthority: this.poolAuthority,
        pool,
        position,
        positionNftAccount,
        owner,
        tokenAAccount,
        tokenBAccount,
        tokenAMint,
        tokenBMint,
        tokenAVault,
        tokenBVault,
        tokenAProgram,
        tokenBProgram
      }).preInstructions(preInstructions).postInstructions(postInstructions).transaction();
    });
  }
  /**
   * Builds a transaction to remove liquidity from a position.
   * @param {RemoveLiquidityParams} params - Parameters for removing liquidity.
   * @returns Transaction builder.
   */
  removeAllLiquidity(params) {
    return __async(this, null, function* () {
      const {
        owner,
        pool,
        position,
        positionNftAccount,
        tokenAAmountThreshold,
        tokenBAmountThreshold,
        tokenAMint,
        tokenBMint,
        tokenAVault,
        tokenBVault,
        tokenAProgram,
        tokenBProgram,
        vestings
      } = params;
      const {
        tokenAAta: tokenAAccount,
        tokenBAta: tokenBAccount,
        instructions: preInstructions
      } = yield this.prepareTokenAccounts({
        payer: owner,
        tokenAOwner: owner,
        tokenBOwner: owner,
        tokenAMint,
        tokenBMint,
        tokenAProgram,
        tokenBProgram
      });
      const postInstructions = [];
      if ([tokenAMint.toBase58(), tokenBMint.toBase58()].includes(
        NATIVE_MINT2.toBase58()
      )) {
        const closeWrappedSOLIx = yield unwrapSOLInstruction(owner);
        closeWrappedSOLIx && postInstructions.push(closeWrappedSOLIx);
      }
      if (vestings.length > 0) {
        const refreshVestingInstruction = yield this.buildRefreshVestingInstruction({
          owner,
          position,
          positionNftAccount,
          pool,
          vestingAccounts: vestings.map((item) => item.account)
        });
        refreshVestingInstruction && preInstructions.push(refreshVestingInstruction);
      }
      const removeAllLiquidityInstruction = yield this.buildRemoveAllLiquidityInstruction({
        poolAuthority: this.poolAuthority,
        owner,
        pool,
        position,
        positionNftAccount,
        tokenAAccount,
        tokenBAccount,
        tokenAAmountThreshold,
        tokenBAmountThreshold,
        tokenAMint,
        tokenBMint,
        tokenAVault,
        tokenBVault,
        tokenAProgram,
        tokenBProgram
      });
      const transaction = new Transaction();
      transaction.add(
        ...preInstructions.length > 0 ? preInstructions : [],
        removeAllLiquidityInstruction,
        ...postInstructions.length > 0 ? postInstructions : []
      );
      return transaction;
    });
  }
  /**
   * Builds a transaction to perform a swap in the pool.
   * @param {SwapParams} params - Parameters for swapping tokens.
   * @returns Transaction builder.
   */
  swap(params) {
    return __async(this, null, function* () {
      const {
        payer,
        pool,
        inputTokenMint,
        outputTokenMint,
        amountIn,
        minimumAmountOut,
        tokenAVault,
        tokenBVault,
        tokenAMint,
        tokenBMint,
        tokenAProgram,
        tokenBProgram,
        referralTokenAccount,
        receiver
      } = params;
      const [inputTokenProgram, outputTokenProgram] = inputTokenMint.equals(
        tokenAMint
      ) ? [tokenAProgram, tokenBProgram] : [tokenBProgram, tokenAProgram];
      const tradeDirection = inputTokenMint.equals(tokenAMint) ? 0 /* AtoB */ : 1 /* BtoA */;
      const {
        tokenAAta: inputTokenAccount,
        tokenBAta: outputTokenAccount,
        instructions: preInstructions
      } = yield this.prepareTokenAccounts({
        payer,
        tokenAOwner: receiver != null ? receiver : payer,
        tokenBOwner: receiver != null ? receiver : payer,
        tokenAMint: inputTokenMint,
        tokenBMint: outputTokenMint,
        tokenAProgram: inputTokenProgram,
        tokenBProgram: outputTokenProgram
      });
      if (inputTokenMint.equals(NATIVE_MINT2)) {
        const wrapSOLIx = wrapSOLInstruction(
          receiver != null ? receiver : payer,
          inputTokenAccount,
          BigInt(amountIn.toString())
        );
        preInstructions.push(...wrapSOLIx);
      }
      const postInstructions = [];
      if ([tokenAMint.toBase58(), tokenBMint.toBase58()].includes(
        NATIVE_MINT2.toBase58()
      )) {
        const closeWrappedSOLIx = yield unwrapSOLInstruction(receiver != null ? receiver : payer);
        closeWrappedSOLIx && postInstructions.push(closeWrappedSOLIx);
      }
      let { poolState } = params;
      poolState = poolState != null ? poolState : yield this.fetchPoolState(pool);
      const data = Buffer.from(poolState.poolFees.baseFee.baseFeeInfo.data);
      const modeIndex = data.readUInt8(8);
      const baseFeeMode = modeIndex;
      let rateLimiterApplied = false;
      if (baseFeeMode === 2 /* RateLimiter */) {
        const currentPoint = yield getCurrentPoint(
          this._program.provider.connection,
          poolState.activationType
        );
        const rateLimiterPoolFees = decodePodAlignedFeeRateLimiter(data);
        rateLimiterApplied = isRateLimiterApplied(
          rateLimiterPoolFees.referenceAmount,
          rateLimiterPoolFees.maxLimiterDuration,
          rateLimiterPoolFees.maxFeeBps,
          rateLimiterPoolFees.feeIncrementBps,
          currentPoint,
          poolState.activationPoint,
          tradeDirection
        );
      }
      const remainingAccounts = rateLimiterApplied ? [
        {
          isSigner: false,
          isWritable: false,
          pubkey: SYSVAR_INSTRUCTIONS_PUBKEY
        }
      ] : [];
      return yield this._program.methods.swap({
        amountIn,
        minimumAmountOut
      }).accountsPartial({
        poolAuthority: this.poolAuthority,
        pool,
        payer: receiver != null ? receiver : payer,
        inputTokenAccount,
        outputTokenAccount,
        tokenAVault,
        tokenBVault,
        tokenAMint,
        tokenBMint,
        tokenAProgram,
        tokenBProgram,
        referralTokenAccount
      }).remainingAccounts(remainingAccounts).preInstructions(preInstructions).postInstructions(postInstructions).transaction();
    });
  }
  /**
   * Builds a transaction to perform a swap in the pool.
   * @param params Swap2Params
   * @returns Transaction builder.
   */
  swap2(params) {
    return __async(this, null, function* () {
      const {
        payer,
        pool,
        inputTokenMint,
        outputTokenMint,
        tokenAVault,
        tokenBVault,
        tokenAMint,
        tokenBMint,
        tokenAProgram,
        tokenBProgram,
        referralTokenAccount,
        swapMode,
        receiver
      } = params;
      const [inputTokenProgram, outputTokenProgram] = inputTokenMint.equals(
        tokenAMint
      ) ? [tokenAProgram, tokenBProgram] : [tokenBProgram, tokenAProgram];
      const tradeDirection = inputTokenMint.equals(tokenAMint) ? 0 /* AtoB */ : 1 /* BtoA */;
      const {
        tokenAAta: inputTokenAccount,
        tokenBAta: outputTokenAccount,
        instructions: preInstructions
      } = yield this.prepareTokenAccounts({
        payer,
        tokenAOwner: receiver != null ? receiver : payer,
        tokenBOwner: receiver != null ? receiver : payer,
        tokenAMint: inputTokenMint,
        tokenBMint: outputTokenMint,
        tokenAProgram: inputTokenProgram,
        tokenBProgram: outputTokenProgram
      });
      let amount0;
      let amount1;
      if (swapMode === 2 /* ExactOut */) {
        amount0 = params.amountOut;
        amount1 = params.maximumAmountIn;
      } else {
        amount0 = params.amountIn;
        amount1 = params.minimumAmountOut;
      }
      if (inputTokenMint.equals(NATIVE_MINT2)) {
        const amount = swapMode === 0 /* ExactIn */ || swapMode === 1 /* PartialFill */ ? amount0 : amount1;
        const wrapSOLIx = wrapSOLInstruction(
          receiver != null ? receiver : payer,
          inputTokenAccount,
          BigInt(amount.toString())
        );
        preInstructions.push(...wrapSOLIx);
      }
      const postInstructions = [];
      if ([tokenAMint.toBase58(), tokenBMint.toBase58()].includes(
        NATIVE_MINT2.toBase58()
      )) {
        const closeWrappedSOLIx = yield unwrapSOLInstruction(receiver != null ? receiver : payer);
        closeWrappedSOLIx && postInstructions.push(closeWrappedSOLIx);
      }
      let { poolState } = params;
      poolState = poolState != null ? poolState : yield this.fetchPoolState(pool);
      const data = Buffer.from(poolState.poolFees.baseFee.baseFeeInfo.data);
      const modeIndex = data.readUInt8(8);
      const baseFeeMode = modeIndex;
      let rateLimiterApplied = false;
      if (baseFeeMode === 2 /* RateLimiter */) {
        const currentPoint = yield getCurrentPoint(
          this._program.provider.connection,
          poolState.activationType
        );
        const rateLimiterPoolFees = decodePodAlignedFeeRateLimiter(data);
        rateLimiterApplied = isRateLimiterApplied(
          rateLimiterPoolFees.referenceAmount,
          rateLimiterPoolFees.maxLimiterDuration,
          rateLimiterPoolFees.maxFeeBps,
          rateLimiterPoolFees.feeIncrementBps,
          currentPoint,
          poolState.activationPoint,
          tradeDirection
        );
      }
      const remainingAccounts = rateLimiterApplied ? [
        {
          isSigner: false,
          isWritable: false,
          pubkey: SYSVAR_INSTRUCTIONS_PUBKEY
        }
      ] : [];
      return yield this._program.methods.swap2({
        amount0,
        amount1,
        swapMode
      }).accountsPartial({
        poolAuthority: this.poolAuthority,
        pool,
        payer: receiver != null ? receiver : payer,
        inputTokenAccount,
        outputTokenAccount,
        tokenAVault,
        tokenBVault,
        tokenAMint,
        tokenBMint,
        tokenAProgram,
        tokenBProgram,
        referralTokenAccount
      }).remainingAccounts(remainingAccounts).preInstructions(preInstructions).postInstructions(postInstructions).transaction();
    });
  }
  /**
   * Builds a transaction to lock a position with vesting schedule.
   * @param {LockPositionParams} params - Locking parameters.
   * @returns Transaction builder.
   */
  lockPosition(params) {
    return __async(this, null, function* () {
      const {
        owner,
        pool,
        payer,
        vestingAccount,
        position,
        positionNftAccount,
        cliffPoint,
        periodFrequency,
        cliffUnlockLiquidity,
        liquidityPerPeriod,
        numberOfPeriod
      } = params;
      const lockPositionParams = {
        cliffPoint,
        periodFrequency,
        cliffUnlockLiquidity,
        liquidityPerPeriod,
        numberOfPeriod
      };
      return yield this._program.methods.lockPosition(lockPositionParams).accountsPartial({
        position,
        positionNftAccount,
        vesting: vestingAccount,
        pool,
        owner,
        payer,
        systemProgram: SystemProgram2.programId
      }).transaction();
    });
  }
  /**
   * Builds a transaction to permanently lock a position.
   * @param {PermanentLockParams} params - Parameters for permanent locking.
   * @returns Transaction builder.
   */
  permanentLockPosition(params) {
    return __async(this, null, function* () {
      const { owner, position, positionNftAccount, pool, unlockedLiquidity } = params;
      return yield this._program.methods.permanentLockPosition(unlockedLiquidity).accountsPartial({
        position,
        positionNftAccount,
        pool,
        owner
      }).transaction();
    });
  }
  /**
   * Builds a transaction to refresh vesting status of a position.
   * @param {RefreshVestingParams} params - Refresh vesting parameters.
   * @returns Transaction builder.
   */
  refreshVesting(params) {
    return __async(this, null, function* () {
      const instruction = yield this.buildRefreshVestingInstruction(params);
      return new Transaction().add(instruction);
    });
  }
  /**
   * Builds a transaction to close a position.
   * @param params ClosePositionParams
   * @returns Transaction builder.
   */
  closePosition(params) {
    return __async(this, null, function* () {
      const { owner, pool, position, positionNftMint, positionNftAccount } = params;
      const instruction = yield this.buildClosePositionInstruction({
        owner,
        poolAuthority: this.poolAuthority,
        pool,
        position,
        positionNftMint,
        positionNftAccount
      });
      return new Transaction().add(instruction);
    });
  }
  /**
   * Builds a transaction to remove all liquidity from a position and close it.
   * This combines several operations in a single transaction:
   * 1. Claims any accumulated fees
   * 2. Removes all liquidity
   * 3. Closes the position
   *
   * @param {RemoveAllLiquidityAndClosePositionParams} params - Combined parameters
   * @returns {TxBuilder} Transaction builder with all required instructions
   * @throws {Error} If the position is locked or cannot be closed
   */
  removeAllLiquidityAndClosePosition(params) {
    return __async(this, null, function* () {
      const {
        owner,
        position,
        positionNftAccount,
        positionState,
        poolState,
        tokenAAmountThreshold,
        tokenBAmountThreshold,
        vestings,
        currentPoint
      } = params;
      const { pool } = positionState;
      const { tokenAMint, tokenBMint } = poolState;
      const { canUnlock, reason } = this.canUnlockPosition(
        positionState,
        vestings,
        currentPoint
      );
      if (!canUnlock) {
        throw new Error(`Cannot remove liquidity: ${reason}`);
      }
      const tokenAProgram = getTokenProgram(poolState.tokenAFlag);
      const tokenBProgram = getTokenProgram(poolState.tokenBFlag);
      const {
        tokenAAta: tokenAAccount,
        tokenBAta: tokenBAccount,
        instructions: preInstructions
      } = yield this.prepareTokenAccounts({
        payer: owner,
        tokenAOwner: owner,
        tokenBOwner: owner,
        tokenAMint,
        tokenBMint,
        tokenAProgram,
        tokenBProgram
      });
      const postInstructions = [];
      if ([tokenAMint.toBase58(), tokenBMint.toBase58()].includes(
        NATIVE_MINT2.toBase58()
      )) {
        const closeWrappedSOLIx = yield unwrapSOLInstruction(owner);
        closeWrappedSOLIx && postInstructions.push(closeWrappedSOLIx);
      }
      if (vestings.length > 0) {
        const refreshVestingInstruction = yield this.buildRefreshVestingInstruction({
          owner,
          position,
          positionNftAccount,
          pool,
          vestingAccounts: vestings.map((item) => item.account)
        });
        refreshVestingInstruction && preInstructions.push(refreshVestingInstruction);
      }
      const transaction = new Transaction();
      if (preInstructions.length > 0) {
        transaction.add(...preInstructions);
      }
      const liquidatePositionInstructions = yield this.buildLiquidatePositionInstruction({
        owner,
        position,
        positionNftAccount,
        positionState,
        poolState,
        tokenAAccount,
        tokenBAccount,
        tokenAAmountThreshold,
        tokenBAmountThreshold
      });
      transaction.add(...liquidatePositionInstructions);
      if (postInstructions.length > 0) {
        transaction.add(...postInstructions);
      }
      return transaction;
    });
  }
  /**
   * Builds a transaction to merge liquidity from one position into another.
   * This process:
   * 1. Claims fees from the source position
   * 2. Removes all liquidity from the source position
   * 3. Adds that liquidity to the target position
   * 4. Closes the source position
   *
   * @param {MergePositionParams} params - Parameters for merging positions
   * @returns {TxBuilder} Transaction builder with all required instructions
   * @throws {Error} If either position is locked or incompatible
   */
  mergePosition(params) {
    return __async(this, null, function* () {
      const {
        owner,
        positionA,
        positionB,
        positionBState,
        poolState,
        positionBNftAccount,
        positionANftAccount,
        tokenAAmountAddLiquidityThreshold,
        tokenBAmountAddLiquidityThreshold,
        tokenAAmountRemoveLiquidityThreshold,
        tokenBAmountRemoveLiquidityThreshold,
        positionBVestings,
        currentPoint
      } = params;
      const { canUnlock, reason } = this.canUnlockPosition(
        positionBState,
        positionBVestings,
        currentPoint
      );
      if (!canUnlock) {
        throw new Error(`Cannot remove liquidity: ${reason}`);
      }
      const pool = positionBState.pool;
      const { tokenAMint, tokenBMint, tokenAVault, tokenBVault } = poolState;
      const tokenAProgram = getTokenProgram(poolState.tokenAFlag);
      const tokenBProgram = getTokenProgram(poolState.tokenBFlag);
      const {
        tokenAAta: tokenAAccount,
        tokenBAta: tokenBAccount,
        instructions: preInstructions
      } = yield this.prepareTokenAccounts({
        payer: owner,
        tokenAOwner: owner,
        tokenBOwner: owner,
        tokenAMint,
        tokenBMint,
        tokenAProgram,
        tokenBProgram
      });
      let positionBLiquidityDelta = positionBState.unlockedLiquidity;
      if (positionBVestings.length > 0) {
        const totalAvailableVestingLiquidity = positionBVestings.reduce(
          (total, position) => {
            const available = getAvailableVestingLiquidity(
              position.vestingState,
              currentPoint
            );
            return total.add(available);
          },
          new BN19(0)
        );
        positionBLiquidityDelta = positionBLiquidityDelta.add(
          totalAvailableVestingLiquidity
        );
        const refreshVestingInstruction = yield this.buildRefreshVestingInstruction({
          owner,
          position: positionB,
          positionNftAccount: positionBNftAccount,
          pool,
          vestingAccounts: positionBVestings.map((item) => item.account)
        });
        refreshVestingInstruction && preInstructions.push(refreshVestingInstruction);
      }
      const tokenAWithdrawAmount = getAmountAFromLiquidityDelta(
        poolState.sqrtPrice,
        poolState.sqrtMaxPrice,
        positionBLiquidityDelta,
        1 /* Down */
      );
      const tokenBWithdrawAmount = getAmountBFromLiquidityDelta(
        poolState.sqrtMinPrice,
        poolState.sqrtPrice,
        positionBLiquidityDelta,
        1 /* Down */
      );
      const newLiquidityDelta = this.getLiquidityDelta({
        maxAmountTokenA: tokenAWithdrawAmount,
        maxAmountTokenB: tokenBWithdrawAmount,
        sqrtMaxPrice: poolState.sqrtMaxPrice,
        sqrtMinPrice: poolState.sqrtMinPrice,
        sqrtPrice: poolState.sqrtPrice
      });
      const transaction = new Transaction();
      if (preInstructions.length > 0) {
        transaction.add(...preInstructions);
      }
      const liquidatePositionInstructions = yield this.buildLiquidatePositionInstruction({
        owner,
        position: positionB,
        positionNftAccount: positionBNftAccount,
        positionState: positionBState,
        poolState,
        tokenAAccount,
        tokenBAccount,
        tokenAAmountThreshold: tokenAAmountRemoveLiquidityThreshold,
        tokenBAmountThreshold: tokenBAmountRemoveLiquidityThreshold
      });
      transaction.add(...liquidatePositionInstructions);
      const addLiquidityInstruction = yield this.buildAddLiquidityInstruction({
        pool,
        position: positionA,
        positionNftAccount: positionANftAccount,
        owner,
        tokenAAccount,
        tokenBAccount,
        tokenAMint,
        tokenBMint,
        tokenAVault,
        tokenBVault,
        tokenAProgram,
        tokenBProgram,
        liquidityDelta: newLiquidityDelta,
        tokenAAmountThreshold: tokenAAmountAddLiquidityThreshold,
        tokenBAmountThreshold: tokenBAmountAddLiquidityThreshold
      });
      transaction.add(addLiquidityInstruction);
      if ([tokenAMint.toBase58(), tokenBMint.toBase58()].includes(
        NATIVE_MINT2.toBase58()
      )) {
        const closeWrappedSOLIx = yield unwrapSOLInstruction(owner);
        closeWrappedSOLIx && transaction.add(closeWrappedSOLIx);
      }
      return transaction;
    });
  }
  /**
   * Builds a transaction to initialize a reward for a pool.
   * @param params InitializeRewardParams
   * @returns Transaction builder.
   */
  initializeReward(params) {
    return __async(this, null, function* () {
      const {
        rewardIndex,
        rewardDuration,
        funder,
        pool,
        creator,
        payer,
        rewardMint,
        rewardMintProgram
      } = params;
      const rewardVault = deriveRewardVaultAddress(pool, rewardIndex);
      const tokenBadge = deriveTokenBadgeAddress(rewardMint);
      const operator = deriveOperatorAddress(creator);
      const remainingAccounts = [];
      const [tokenBadgeInfo, operatorInfo] = yield Promise.all([
        this._program.provider.connection.getAccountInfo(tokenBadge),
        this._program.provider.connection.getAccountInfo(operator)
      ]);
      if (tokenBadgeInfo) {
        remainingAccounts.push({
          pubkey: tokenBadge,
          isSigner: false,
          isWritable: false
        });
      } else {
        remainingAccounts.push({
          pubkey: CP_AMM_PROGRAM_ID,
          isSigner: false,
          isWritable: false
        });
      }
      if (operatorInfo) {
        remainingAccounts.push({
          pubkey: operator,
          isSigner: false,
          isWritable: false
        });
      }
      return yield this._program.methods.initializeReward(rewardIndex, rewardDuration, funder).accountsPartial({
        poolAuthority: this.poolAuthority,
        pool,
        rewardVault,
        rewardMint,
        signer: creator,
        payer,
        tokenProgram: rewardMintProgram
      }).remainingAccounts(remainingAccounts).transaction();
    });
  }
  /**
   * Builds a transaction to initialize and fund a reward for a pool.
   * @param params InitializeAndFundReward
   * @returns Transaction builder.
   */
  initializeAndFundReward(params) {
    return __async(this, null, function* () {
      const {
        rewardIndex,
        rewardDuration,
        pool,
        creator,
        payer,
        rewardMint,
        carryForward,
        amount,
        rewardMintProgram
      } = params;
      const rewardVault = deriveRewardVaultAddress(pool, rewardIndex);
      const initializeRewardTx = yield this.initializeReward({
        rewardIndex,
        rewardDuration,
        funder: payer,
        pool,
        creator,
        payer,
        rewardMint,
        rewardMintProgram
      });
      const fundRewardTx = yield this.fundReward({
        rewardIndex,
        carryForward,
        pool,
        funder: payer,
        amount,
        rewardMint,
        rewardVault,
        rewardMintProgram
      });
      return new Transaction().add(initializeRewardTx).add(fundRewardTx);
    });
  }
  /**
   * Builds a transaction to update reward duration.
   * @param {UpdateRewardDurationParams} params - Parameters including pool and new duration.
   * @returns Transaction builder.
   */
  updateRewardDuration(params) {
    return __async(this, null, function* () {
      const { pool, signer, rewardIndex, newDuration } = params;
      return yield this._program.methods.updateRewardDuration(rewardIndex, newDuration).accountsPartial({
        pool,
        signer
      }).transaction();
    });
  }
  /**
   * Builds a transaction to update reward funder address.
   * @param {UpdateRewardFunderParams} params - Parameters including pool and new funder address.
   * @returns Transaction builder.
   */
  updateRewardFunder(params) {
    return __async(this, null, function* () {
      const { pool, signer, rewardIndex, newFunder } = params;
      return yield this._program.methods.updateRewardFunder(rewardIndex, newFunder).accountsPartial({
        pool,
        signer
      }).transaction();
    });
  }
  /**
   * Builds a transaction to fund rewards in a pool.
   * @param {FundRewardParams} params - Funding parameters.
   * @returns Transaction builder.
   */
  fundReward(params) {
    return __async(this, null, function* () {
      const {
        funder,
        rewardIndex,
        pool,
        carryForward,
        amount,
        rewardMint,
        rewardVault,
        rewardMintProgram
      } = params;
      const preInstructions = [];
      const { ataPubkey: funderTokenAccount, ix: createFunderTokenAccountIx } = yield getOrCreateATAInstruction(
        this._program.provider.connection,
        rewardMint,
        funder,
        funder,
        true,
        rewardMintProgram
      );
      createFunderTokenAccountIx && preInstructions.push(createFunderTokenAccountIx);
      if (rewardMint.equals(NATIVE_MINT2) && !amount.isZero()) {
        const wrapSOLIx = wrapSOLInstruction(
          funder,
          funderTokenAccount,
          BigInt(amount.toString())
        );
        preInstructions.push(...wrapSOLIx);
      }
      return yield this._program.methods.fundReward(rewardIndex, amount, carryForward).accountsPartial({
        pool,
        rewardVault,
        rewardMint,
        funderTokenAccount,
        funder,
        tokenProgram: rewardMintProgram
      }).preInstructions(preInstructions).transaction();
    });
  }
  /**
   * Builds a transaction to withdraw ineligible rewards from a pool.
   * @param {WithdrawIneligibleRewardParams} params - Parameters for withdrawal.
   * @returns Transaction builder.
   */
  withdrawIneligibleReward(params) {
    return __async(this, null, function* () {
      const { rewardIndex, pool, funder } = params;
      const poolState = yield this.fetchPoolState(pool);
      const rewardInfo = poolState.rewardInfos[rewardIndex];
      const { mint, vault, rewardTokenFlag } = rewardInfo;
      const tokenProgram = getTokenProgram(rewardTokenFlag);
      const preInstructions = [];
      const postInstructions = [];
      const { ataPubkey: funderTokenAccount, ix: createFunderTokenAccountIx } = yield getOrCreateATAInstruction(
        this._program.provider.connection,
        mint,
        funder,
        funder,
        true,
        tokenProgram
      );
      createFunderTokenAccountIx && preInstructions.push(createFunderTokenAccountIx);
      if (mint.equals(NATIVE_MINT2)) {
        const closeWrappedSOLIx = yield unwrapSOLInstruction(funder);
        closeWrappedSOLIx && postInstructions.push(closeWrappedSOLIx);
      }
      return yield this._program.methods.withdrawIneligibleReward(rewardIndex).accountsPartial({
        pool,
        rewardVault: vault,
        rewardMint: mint,
        poolAuthority: this.poolAuthority,
        funderTokenAccount,
        funder,
        tokenProgram
      }).preInstructions(preInstructions).postInstructions(postInstructions).transaction();
    });
  }
  /**
   * Builds a transaction to claim partner fee rewards.
   * @param {ClaimPartnerFeeParams} params - Claim parameters including amounts and partner address.
   * @returns Transaction builder.
   */
  claimPartnerFee(params) {
    return __async(this, null, function* () {
      const {
        feePayer,
        receiver,
        tempWSolAccount,
        partner,
        pool,
        maxAmountA,
        maxAmountB
      } = params;
      const poolState = yield this.fetchPoolState(pool);
      const {
        tokenAVault,
        tokenBVault,
        tokenAMint,
        tokenBMint,
        tokenAFlag,
        tokenBFlag
      } = poolState;
      const tokenAProgram = getTokenProgram(tokenAFlag);
      const tokenBProgram = getTokenProgram(tokenBFlag);
      const payer = feePayer != null ? feePayer : partner;
      const { tokenAAccount, tokenBAccount, preInstructions, postInstructions } = yield this.setupFeeClaimAccounts({
        payer,
        owner: partner,
        tokenAMint,
        tokenBMint,
        tokenAProgram,
        tokenBProgram,
        receiver,
        tempWSolAccount
      });
      return yield this._program.methods.claimPartnerFee(maxAmountA, maxAmountB).accountsPartial({
        poolAuthority: this.poolAuthority,
        pool,
        tokenAAccount,
        tokenBAccount,
        tokenAVault,
        tokenBVault,
        tokenAMint,
        tokenBMint,
        partner,
        tokenAProgram,
        tokenBProgram
      }).preInstructions(preInstructions).postInstructions(postInstructions).transaction();
    });
  }
  /**
   * Builds a transaction to claim position fee rewards.
   * @param {ClaimPositionFeeParams} params - Parameters for claiming position fee.
   * @returns Transaction builder.
   */
  claimPositionFee(params) {
    return __async(this, null, function* () {
      const {
        receiver,
        tempWSolAccount,
        feePayer,
        owner,
        pool,
        position,
        positionNftAccount,
        tokenAVault,
        tokenBVault,
        tokenAMint,
        tokenBMint,
        tokenAProgram,
        tokenBProgram
      } = params;
      const payer = feePayer != null ? feePayer : owner;
      const { tokenAAccount, tokenBAccount, preInstructions, postInstructions } = yield this.setupFeeClaimAccounts({
        payer,
        owner,
        tokenAMint,
        tokenBMint,
        tokenAProgram,
        tokenBProgram,
        receiver,
        tempWSolAccount
      });
      const claimPositionFeeInstruction = yield this.buildClaimPositionFeeInstruction({
        owner,
        poolAuthority: this.poolAuthority,
        pool,
        position,
        positionNftAccount,
        tokenAAccount,
        tokenBAccount,
        tokenAVault,
        tokenBVault,
        tokenAMint,
        tokenBMint,
        tokenAProgram,
        tokenBProgram
      });
      const transaction = new Transaction();
      transaction.add(
        ...preInstructions.length > 0 ? preInstructions : [],
        claimPositionFeeInstruction,
        ...postInstructions.length > 0 ? postInstructions : []
      );
      return transaction;
    });
  }
  /**
   * Builds a transaction to claim position fee rewards.
   * @param {ClaimPositionFeeParams2} params - Parameters for claiming position fee.
   * @returns Transaction builder.
   */
  claimPositionFee2(params) {
    return __async(this, null, function* () {
      const {
        receiver,
        feePayer,
        owner,
        pool,
        position,
        positionNftAccount,
        tokenAVault,
        tokenBVault,
        tokenAMint,
        tokenBMint,
        tokenAProgram,
        tokenBProgram
      } = params;
      const payer = feePayer != null ? feePayer : owner;
      let tokenAOwner = receiver;
      let tokenBOwner = receiver;
      if (tokenAMint.equals(NATIVE_MINT2)) {
        tokenAOwner = owner;
      }
      if (tokenBMint.equals(NATIVE_MINT2)) {
        tokenBOwner = owner;
      }
      const {
        tokenAAta: tokenAAccount,
        tokenBAta: tokenBAccount,
        instructions: preInstruction
      } = yield this.prepareTokenAccounts({
        payer,
        tokenAOwner,
        tokenBOwner,
        tokenAMint,
        tokenBMint,
        tokenAProgram,
        tokenBProgram
      });
      const postInstructions = [];
      if (tokenAMint.equals(NATIVE_MINT2) || tokenBMint.equals(NATIVE_MINT2)) {
        const closeWrappedSOLIx = yield unwrapSOLInstruction(owner, receiver);
        closeWrappedSOLIx && postInstructions.push(closeWrappedSOLIx);
      }
      const claimPositionFeeInstruction = yield this.buildClaimPositionFeeInstruction({
        owner,
        poolAuthority: this.poolAuthority,
        pool,
        position,
        positionNftAccount,
        tokenAAccount,
        tokenBAccount,
        tokenAVault,
        tokenBVault,
        tokenAMint,
        tokenBMint,
        tokenAProgram,
        tokenBProgram
      });
      const transaction = new Transaction();
      transaction.add(
        ...preInstruction.length > 0 ? preInstruction : [],
        claimPositionFeeInstruction,
        ...postInstructions.length > 0 ? postInstructions : []
      );
      return transaction;
    });
  }
  /**
   * Builds a transaction to claim reward from a position.
   * @param {ClaimRewardParams} params - Parameters for claiming reward.
   * @returns Transaction builder.
   */
  claimReward(params) {
    return __async(this, null, function* () {
      const {
        feePayer,
        user,
        position,
        positionNftAccount,
        rewardIndex,
        poolState,
        positionState,
        isSkipReward
      } = params;
      const rewardInfo = poolState.rewardInfos[rewardIndex];
      const tokenProgram = getTokenProgram(rewardInfo.rewardTokenFlag);
      const preInstructions = [];
      const postInstructions = [];
      const { ataPubkey: userTokenAccount, ix: createUserTokenAccountIx } = yield getOrCreateATAInstruction(
        this._program.provider.connection,
        rewardInfo.mint,
        user,
        feePayer != null ? feePayer : user,
        true,
        tokenProgram
      );
      createUserTokenAccountIx && preInstructions.push(createUserTokenAccountIx);
      if (rewardInfo.mint.equals(NATIVE_MINT2)) {
        const closeWrappedSOLIx = yield unwrapSOLInstruction(user);
        closeWrappedSOLIx && postInstructions.push(closeWrappedSOLIx);
      }
      const skipReward = isSkipReward ? 1 : 0;
      return yield this._program.methods.claimReward(rewardIndex, skipReward).accountsPartial({
        pool: positionState.pool,
        positionNftAccount,
        rewardVault: rewardInfo.vault,
        rewardMint: rewardInfo.mint,
        poolAuthority: this.poolAuthority,
        position,
        userTokenAccount,
        owner: user,
        tokenProgram
      }).preInstructions(preInstructions).postInstructions(postInstructions).transaction();
    });
  }
  /**
   * Builds a transaction to split a position into two positions.
   * @param params SplitPositionParams
   * @returns Transaction builder.
   */
  splitPosition(params) {
    return __async(this, null, function* () {
      const {
        firstPositionOwner,
        secondPositionOwner,
        pool,
        firstPosition,
        firstPositionNftAccount,
        secondPosition,
        secondPositionNftAccount,
        permanentLockedLiquidityPercentage,
        unlockedLiquidityPercentage,
        feeAPercentage,
        feeBPercentage,
        reward0Percentage,
        reward1Percentage
      } = params;
      return yield this._program.methods.splitPosition({
        permanentLockedLiquidityPercentage,
        unlockedLiquidityPercentage,
        feeAPercentage,
        feeBPercentage,
        reward0Percentage,
        reward1Percentage,
        padding: new Array(16).fill(0)
      }).accountsPartial({
        pool,
        firstPosition,
        firstPositionNftAccount,
        secondPosition,
        secondPositionNftAccount,
        firstOwner: firstPositionOwner,
        secondOwner: secondPositionOwner
      }).transaction();
    });
  }
  /**
   * Builds a transaction to split a position into two positions.
   * @param params SplitPosition2Params
   * @returns Transaction builder.
   */
  splitPosition2(params) {
    return __async(this, null, function* () {
      const {
        firstPositionOwner,
        secondPositionOwner,
        pool,
        firstPosition,
        firstPositionNftAccount,
        secondPosition,
        secondPositionNftAccount,
        numerator
      } = params;
      return yield this._program.methods.splitPosition2(numerator).accountsPartial({
        pool,
        firstPosition,
        firstPositionNftAccount,
        secondPosition,
        secondPositionNftAccount,
        firstOwner: firstPositionOwner,
        secondOwner: secondPositionOwner
      }).transaction();
    });
  }
};
export {
  ActivationPoint,
  ActivationType,
  BASIS_POINT_MAX,
  BIN_STEP_BPS_DEFAULT,
  BIN_STEP_BPS_U128_DEFAULT,
  BaseFeeMode,
  CP_AMM_PROGRAM_ID,
  CURRENT_POOL_VERSION,
  CollectFeeMode,
  CpAmm,
  cp_amm_default as CpAmmIdl,
  DYNAMIC_FEE_DECAY_PERIOD_DEFAULT,
  DYNAMIC_FEE_FILTER_PERIOD_DEFAULT,
  DYNAMIC_FEE_REDUCTION_FACTOR_DEFAULT,
  DYNAMIC_FEE_ROUNDING_OFFSET,
  DYNAMIC_FEE_SCALING_FACTOR,
  FEE_DENOMINATOR,
  FEE_PADDING,
  FeeMarketCapScheduler,
  FeeRateLimiter,
  FeeTimeScheduler,
  LIQUIDITY_SCALE,
  MAX,
  MAX_CU_BUFFER,
  MAX_EXPONENTIAL,
  MAX_FEE_BPS_V0,
  MAX_FEE_BPS_V1,
  MAX_FEE_NUMERATOR_V0,
  MAX_FEE_NUMERATOR_V1,
  MAX_PRICE_CHANGE_BPS_DEFAULT,
  MAX_RATE_LIMITER_DURATION_IN_SECONDS,
  MAX_RATE_LIMITER_DURATION_IN_SLOTS,
  MAX_SQRT_PRICE,
  MIN_CU_BUFFER,
  MIN_FEE_BPS,
  MIN_FEE_NUMERATOR,
  MIN_SQRT_PRICE,
  ONE_Q64,
  PoolStatus,
  PoolVersion,
  Rounding,
  SCALE_OFFSET,
  SPLIT_POSITION_DENOMINATOR,
  SwapMode,
  TradeDirection,
  U128_MAX,
  U16_MAX,
  U64_MAX,
  bpsToFeeNumerator,
  calculateAtoBFromAmountIn,
  calculateAtoBFromAmountOut,
  calculateAtoBFromPartialAmountIn,
  calculateBtoAFromAmountIn,
  calculateBtoAFromAmountOut,
  calculateBtoAFromPartialAmountIn,
  calculateInitSqrtPrice,
  calculateTransferFeeExcludedAmount,
  calculateTransferFeeIncludedAmount,
  convertToFeeSchedulerSecondFactor,
  convertToLamports,
  convertToRateLimiterSecondFactor,
  cpAmmCoder,
  decimalToQ64,
  decodeFeeMarketCapSchedulerParams,
  decodeFeeRateLimiterParams,
  decodeFeeTimeSchedulerParams,
  decodePodAlignedFeeMarketCapScheduler,
  decodePodAlignedFeeRateLimiter,
  decodePodAlignedFeeTimeScheduler,
  deriveClaimFeeOperatorAddress,
  deriveConfigAddress,
  deriveCustomizablePoolAddress,
  deriveOperatorAddress,
  derivePoolAddress,
  derivePoolAuthority,
  derivePositionAddress,
  derivePositionNftAccount,
  deriveRewardVaultAddress,
  deriveTokenBadgeAddress,
  deriveTokenVaultAddress,
  encodeFeeMarketCapSchedulerParams,
  encodeFeeRateLimiterParams,
  encodeFeeTimeSchedulerParams,
  feeNumeratorToBps,
  fromDecimalToBN,
  getAllPositionNftAccountByOwner,
  getAllUserPositionNftAccount,
  getAmountAFromLiquidityDelta,
  getAmountBFromLiquidityDelta,
  getAmountWithSlippage,
  getAvailableVestingLiquidity,
  getBaseFeeHandler,
  getBaseFeeParams,
  getCheckedAmounts,
  getCurrentPoint,
  getDynamicFeeNumerator,
  getDynamicFeeParams,
  getEstimatedComputeUnitIxWithBuffer,
  getEstimatedComputeUnitUsageWithBuffer,
  getExcludedFeeAmount,
  getExcludedFeeAmountFromIncludedFeeAmount,
  getFeeInPeriod,
  getFeeMarketCapBaseFeeNumerator,
  getFeeMarketCapBaseFeeNumeratorByPeriod,
  getFeeMarketCapMinBaseFeeNumerator,
  getFeeMarketCapSchedulerParams,
  getFeeMode,
  getFeeNumeratorFromExcludedFeeAmount,
  getFeeNumeratorFromIncludedFeeAmount,
  getFeeNumeratorOnExponentialFeeScheduler,
  getFeeNumeratorOnLinearFeeScheduler,
  getFeeOnAmount,
  getFeeTimeBaseFeeNumerator,
  getFeeTimeBaseFeeNumeratorByPeriod,
  getFeeTimeMinBaseFeeNumerator,
  getFeeTimeSchedulerParams,
  getFirstKey,
  getIncludedFeeAmount,
  getLiquidityDeltaFromAmountA,
  getLiquidityDeltaFromAmountB,
  getMaxAmountWithSlippage,
  getMaxBaseFeeNumerator,
  getMaxFeeBps,
  getMaxFeeNumerator,
  getMaxIndex,
  getNextSqrtPriceFromAmountInARoundingUp,
  getNextSqrtPriceFromAmountInBRoundingDown,
  getNextSqrtPriceFromAmountOutARoundingUp,
  getNextSqrtPriceFromAmountOutBRoundingDown,
  getNextSqrtPriceFromInput,
  getNextSqrtPriceFromOutput,
  getOrCreateATAInstruction,
  getPriceChange,
  getPriceFromSqrtPrice,
  getPriceImpact,
  getRateLimiterParams,
  getRewardInfo,
  getSecondKey,
  getSimulationComputeUnits,
  getSqrtPriceFromPrice,
  getSwapResultFromExactInput,
  getSwapResultFromExactOutput,
  getSwapResultFromPartialInput,
  getTokenDecimals,
  getTokenProgram,
  getTotalFeeNumerator,
  getTotalLockedLiquidity,
  getTotalTradingFeeFromExcludedFeeAmount,
  getTotalTradingFeeFromIncludedFeeAmount,
  getUnClaimLpFee,
  getUserRewardPending,
  hasPartner,
  hasTransferHookExtension,
  isDynamicFeeEnabled,
  isNonZeroRateLimiter,
  isRateLimiterApplied,
  isSwapEnabled,
  isVestingComplete,
  isZeroRateLimiter,
  mulDiv,
  offsetBasedFilter,
  parseFeeSchedulerSecondFactor,
  parseRateLimiterSecondFactor,
  positionByPoolFilter,
  pow,
  q64ToDecimal,
  splitFees,
  sqrt,
  swapQuoteExactInput,
  swapQuoteExactOutput,
  swapQuotePartialInput,
  toNumerator,
  unwrapSOLInstruction,
  validateFeeFraction,
  validateFeeMarketCapBaseFeeIsStatic,
  validateFeeMarketCapScheduler,
  validateFeeRateLimiter,
  validateFeeRateLimiterBaseFeeIsStatic,
  validateFeeTimeScheduler,
  validateFeeTimeSchedulerBaseFeeIsStatic,
  validateNoTransferHook,
  vestingByPositionFilter,
  wrapSOLInstruction
};
//# sourceMappingURL=index.mjs.map